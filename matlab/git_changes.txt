diff --git a/.gitignore b/.gitignore
index 30775df..045b725 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,11 +4,12 @@
 .classpath
 .project
 *.class
+*.jar
 *.war
 *.ear
 META-INF/
 target/
 .settings/
 .DS_Store
-*.pyc
 bin
+*.pyc
\ No newline at end of file
diff --git a/README.md b/README.md
index a505e03..bac6088 100644
--- a/README.md
+++ b/README.md
@@ -1,30 +1,16 @@
-# JAR3D is Java-based Alignment of RNA using 3D structure information
+#JAR3D is Java-based Alignment of RNA using 3D structure information
 
-## Motivation
-Correctly predicting RNA 3D structures starting from sequence is a major, unsolved challenge in bioinformatics. An important sub-goal is the identification of the 3D structures of recurrent hairpin and internal RNA 3D motifs that appear as unpaired â€œloopsâ€ on secondary structure diagrams. Recurrent 3D motif functions include:
+##Motivation
+Correctly predicting RNA 3D structures starting from sequence is a major, unsolved challenge in bioinformatics. An important sub-goal is the identification of the 3D structures of recurrent hairpin and internal RNA 3D motifs that appear as unpaired “loops” on secondary structure diagrams. Recurrent 3D motif functions include:
 
-* Architectural roles introducing bends in helices (e.g., kink-turns) or changing helical twist (e.g., C-loops)
+* Architectural roles introducing bends in helices (e.g. kink-turns) or changing helical twist (e.g. C-loops)
 * Anchoring RNA tertiary interactions (e.g., GNRA loops and loop-receptors)
 * Providing sites for proteins or small molecules to bind.
-* Analysis of 3D structures (see, for example, the [RNA 3D Motif Atlas](https://rna.bgsu.edu/rna3dhub/motifs)) shows that different RNA sequences can form the same RNA 3D motif. Since not all sequence variants of a given motif are present in the 3D database, accurate methods are needed to predict which sequences are likely to form known 3D motifs. This is the purpose of JAR3D.
+* Analysis of 3D structures (for example using WebFR3D) shows that different RNA sequences can form the same RNA 3D motif. Since not all sequence variants of a given motif are present in the 3D database, accurate methods are needed to predict which sequences are likely to form known 3D motifs. This is the purpose of JAR3D.
 
-## Methodology
-We extract all hairpin and internal loops from a [representative set of RNA 3D structures](https://rna.bgsu.edu/rna3dhub/nrlist) from the PDB and cluster them in geometrically similar families, with the results being organized into the [RNA 3D Motif Atlas](https://rna.bgsu.edu/rna3dhub/motifs).
+##Methodology
+We extract all hairpin and internal loops from a non-redundant set of RNA 3D structures from the PDB/NDB and cluster them in geometrically similar families, with the results being organized into the RNA 3D Motif Atlas.
 For each recurrent motif, we construct a probabilistic model for sequence variability based on a hybrid Stochastic Context-Free Grammar/Markov Random Field (SCFG/MRF) method we developed.
 To parameterize each model, we use all instances of the motif found in the Motif Atlas and knowledge of nucleotide interactions, especially isosteric basepairs and their substitution patterns.
 Given the sequence of a hairpin or internal loop from a secondary structure as input, we score the sequence against each motif group to obtain both the alignment score against the SCFG/MRF model and the minimum interior edit distance to known 3D sequences, combining these into a Cutoff score which is calibrated to be 100 for perfect matches and greater than or equal to zero for reasonable matches.
 If the Cutoff score is above 0, we infer that the new sequence can form the same 3D structure as in the motif group.
-
-## Installation
-
-The installation instructions and user manual can be found in this repository in [docs/howto.md](https://github.com/BGSU-RNA/JAR3D/blob/master/docs/howto.md).
-
-## Data files and jar files
-
-Data files for each release of the motif atlas and Java executable .jar files are available in the models folder in this repository.
-They are also available at https://rna.bgsu.edu/data/jar3d/models/
-
-## JAR3D web server
-
-The JAR3D web server is ideal for relatively small investigations.
-See https://rna.bgsu.edu/jar3d
diff --git a/docs/howto.md b/docs/howto.md
deleted file mode 100644
index 7b009db..0000000
--- a/docs/howto.md
+++ /dev/null
@@ -1,209 +0,0 @@
-# How to run JAR3D
-
-## Installation
-
-1. The executable version of JAR3D, named using the scheme `jar3d_DATE.jar`, can be downloaded from https://rna.bgsu.edu/data/jar3d/models/. Use the most current *DATE* if more than one is available.  Jar files from 2015 were tested with Java version 8.
-
-2. The most current model files for hairpin loops (HL) and internal loops (IL) for each release of the [RNA 3D Motif Atlas](https://rna.bgsu.edu/rna3dhub/motifs) are found in directories at the same URL.
-
-## Input file format
-
-Use [FASTA format](https://en.wikipedia.org/wiki/FASTA_format), alternating a header line starting with `>` and a line with one sequence of a hairpin or internal loop. The break between strands in IL should be indicated by the `*` character. Include flanking Watson-Crick basepairs *AU*, *GC*, and *GU* in the sequence, since this is how hairpins and internal loops are extracted from 3D structures. The only allowed characters in each line are A, C, G, U, * and -.  Leave no blank lines.
-
-**Examples:**
-
-Single internal loop:
-
-```
->sarcin 1
-CUCAGUAU*AGAACCG
-```
-
-Multiple internal loops:
-
-```
->sarcin 1
-CUCAGUAU*AGAACCG
->sarcin 2
-CUCAGUAC*GGAACCG
->sarcin 3
-CUCAGUAC*GGAACUG
-```
-
-Save the file with a name like *SequenceFile.fasta* or *SequenceFile.txt*.
-
-## Scoring a sequence file against motif groups
-
-From the command line, run the *.jar* file like this:
-
-```
-java -jar JARFILE SEQUENCEFILE MODELLISTFILE LOOPOUTPUT SEQUENCEOUTPUT
-```
-
-where
-
-* **JARFILE** is the name of the *.jar* file. At the time of publication, this was *jar3d_2014-12-11.jar*
-
-* **SEQUENCEFILE** is the path to a fasta-formatted file containing the sequences to score
-
-* **MODELLISTFILE** is the path to a text file listing the names of the model files to use. The file *all.txt* is
-provided with JAR3D distributions, for example, `IL/1.13/lib/all.txt`. The model files themselves need to be in the same folder as the file listing the names of the models files to use. A number of other files need to be in the same folder as well. These are provided with the model files for RNA 3D Motif Atlas motif groups.
-
-* **LOOPOUTPUT** is the path to a file where JAR3D will write output telling the overall score of all sequences against each model along with other diagnostics
-
-* **SEQUENCEOUTPUT** is the path to a file where JAR3D will write output telling, for each sequence in the input file, the score and other diagnostics against each model
-
-For example, issuing this command from the JAR3D folder containing the .jar file and release *IL/1.13* will score sequences from the 3D motif group *IL_85647.3* against all IL motif groups in release 1.13:
-
-```
-java -jar jar3d_2014-12-11.jar IL/1.13/lib/IL_85647.3.fasta IL/1.13/lib/all.txt IL_85647.3_loop.txt IL_85647.3_sequence.txt
-```
-
-## Explanation of JAR3D loop-level output
-
-This is a **comma-delimited file** with a header line. Each line tells summary statistics covering all sequences in the input fasta file against each of the specified models. The header line is:
-
-```
-filename,motifId,%passedCutoff,meanCutoffScore,meanScore,medianScore,meanDeficit,medianDeficit,meanInteriorEditDistance,medianInteriorEditDistance,meanFullEditDistance,medianFullEditDistance,rotation
-```
-
-Here is an explanation of each field:
-
-1. **filename** is the filename of the fasta file of sequences that were run against JAR3D
-
-2. **motifId** is the name of the motif group that is being reported on this lineï¿¼
-
-3. **%passedCutoff** is the percentage of sequences in the input file which fall into the acceptance region of the motif group on this line, ranging from 0 to 100
-
-4. **meanCutoffScore** is the average CutoffScore against the present motif group, ranging from 100 downward
-
-5. **meanScore** is the alignment score against this model, averaged across all sequences in the fasta file. The alignment score is the maximum log probability score returned by the CYK algorithm when a sequence is aligned to the SCFG/MRF model.
-
-6. **medianScore** is the median alignment score against this model across all sequences
-
-7. **meanDeficit** is the average alignment score deficit; for a single sequence, the deficit is the difference between the highest alignment score over all 3D instances of the motif and the score of the current sequence
-
-8. **medianDeficit** is the median alignment score deficit
-
-9. **meanInteriorEditDistance** refers to the edit distance between sequences in the provided fasta file and known instances of the motif from 3D structure; interior means that flanking cWW pairs are not included in the calculation of the edit distance, only the interior nucleotides. For each sequence in the fasta file, the minimum interior edit distance across all known instances from 3D is computed, then this is averaged over the sequences in the fasta file to give the meanInteriorEditDistance. So this could be called the meanMinimumInteriorEditDistance.
-
-10. **medianInteriorEditDistance** is similar, but the median of the minimum edit distances is reported
-
-11. **meanFullEditDistance** is similar, but includes the sequence of the flanking cWW basepairs in the calculation of the edit distance
-
-12. **medianFullEditDistance** uses the median of the minimum edit distances
-
-13. **rotation** is 0 for hairpin loops, 0 or 1 for internal loops, depending on whether the sequences matched the model better with the given strand order (rotation 0) or with the strands reversed (rotation 1)
-
-## Explanation of JAR3D sequence-specific output
-
-This is a **comma-delimited file** with a header line. The file contains one line for each sequence in the input fasta file and one line for each model, telling how the sequence scores against the model. The header line is:
-
-```
-filename,identifier,motifId,passedCutoff,meanCutoffScore,score,deficit,interiorEditDistance,fullEditDistance,rotation
-```
-
-Here is an explanation of each field on each line:
-
-1. **filename** is the filename of the .fasta file of sequences that were run against JAR3D
-
-2. **identifier** is the text on the line before each sequence, after the `>` character
-
-3. **motifId** is the name of the model that is being reported on this line
-
-4. **passedCutoff** is `true` or `false`, depending on whether the sequence is accepted or rejected by the motif group on this line
-
-5. **meanCutoffScore** is the cutoff score of the sequence against the motif group on this line
-
-6. **score** is the alignment score, the maximum log probability score returned by the CYK algorithm when the sequence is aligned to the SCFG/MRF model
-
-7. **deficit** is the difference between the highest alignment score over all 3D instances of the motif and the score of the current sequence
-
-8. **interiorEditDistance**  is the minimum edit distance between the non-flanking bases of the input sequence and each of the sequences in the current motif group, known from 3D
-
-9. **fullEditDistance** is similar, but includes the flanking cWW basepairs in the calculation of edit distance
-
-10. **rotation** is 0 for hairpin loops, 0 or 1 for internal loops, depending whether the sequences in the fasta file, as a whole, match the model better in the original strand order or with the strands reversed.
-
-## Aligning sequences to a specific JAR3D motif group
-
-Once a suitable motif group is identified, JAR3D can align the sequences to the SCFG/MRF model. The executable file *jar3dalign.jar* is used for this purpose:
-
-`java -jar JARFILE SEQUENCEFILE MODELPATH MODELNAME ROTATION CORRESPONDENCEFILE`
-
-where
-
-* **JARFILE** is the name of the .jar file. At the time of publication, this was *jar3dalign_2014-12-10.jar*
-
-* **SEQUENCEFILE** is the path to a fasta-formatted file containing the sequences to score
-
-* **MODELPATH** is the path to the JAR3D models for the desired loop type and release, for example, *IL/1.13/lib*
-
-* **MODELNAME** is the name of a JAR3D model, for example, **IL_85647.3**
-
-* **ROTATION** indicates if the strands in the sequence file are reversed relative to their orientation in theï¿¼model. This is one of the output columns of the loop and sequence-level output of the JAR3D scoring programs described above. This parameter should be 0 for non-rotated internal loops and all hairpin loops, and 1 for rotated internal loop groups.
-
-* **CORRESPONDENCEFILE** is the path to a file where JAR3D will write output telling how each sequence position corresponds to the JAR3D model
-For example, the following command will work when run from a directory containing release *IL/1.13* and the correct .jar file:
-
-```
-java -jar jar3dalign_2014-12-10.jar IL/1.13/lib/IL_85647.3.fasta IL/1.13/lib IL_85647.3 0 IL_85647.3_correspondences.txt
-```
-
-The CORRESPONDENCEFILE can be read by a human, but more readable output is produced by the Python program *fastatomodelalignment.py*. To get this program, get the JAR3D source code from [Github](https://github.com/BGSU-RNA/JAR3D) and install Python 2.7 on your computer. You do not need to compile Java programs or run Matlab programs. Run it this way:
-
-```
-python PYTHONFILE LIBDIRECTORY MOTIFID CORRESPONDENCEFILE OUTPUTFILE where
-```
-
-* **PYTHONFILE** is the path to the program fastatomodelalignment.py in the JAR3D/python directory
-
-* **LIBDIRECTORY** is the path to the JAR3D models, such as IL/1.13/lib
-
-* **MOTIFID** is the motif id, such as *IL_85647.3*
-
-* **CORRESPONDENCEFILE** is the file produced by *jar3dalign* in the previous step
-
-* **OUTPUTFILE** is an .html file which presents the alignment of the sequences in SEQUENCEFILE to the model of MOTIFID. First listed are the sequences in the motif group and how they actually correspond to the model. Second are the sequences in SEQUENCEFILE. For example, the following command turns the correspondences file produced above into an html file that displays the alignment (the final output is then the file IL_85647.3.html):
-
-```
-python jar3d/python/fastatomodelalignment.py Il/1.13/lib IL_85647.3 IL_85647.3_correspondences.txt IL_85647.3.html
-```
-
-## Getting and installing the JAR3D source code
-
-The Matlab source code for generating SCFG/MRF probabilistic models, the Java code for parsing and aligning, and Python code for producing a presentation of the alignment are available through [Github](https://github.com/BGSU-RNA/JAR3D). The version used for the production of the article is **v1.1**.
-
-### Running the Python code to show correspondences between sequences and a model
-
-Install Python 2.7 and follow the instructions in Section F.6.
-
-### Compiling the Java code to score sequences against SCFG/MRF models
-
-This is not necessary for most users. Requires the Java Development Kit and [Maven](https://maven.apache.org/). The project is built using maven so this is done through the command line with:
-
-```
-cd jar3d
-mvn package -P csv # to produce jar3d.jar, the JAR3D inference program
-mvn package -P corr # to produce jar3dalign.jar, for aligning sequences to a model
-```
-
-Users interested in creating their own main class will need to edit the *pom.xml* file to use the desired *MainClass*. Packaging produces a jar file *target/jar3d-0.0.1-SNAPSHOT.jar* , which can be used to run JAR3D from the command line.
-
-### Running the Matlab code to build SCFG/MRF models
-
-This is not necessary for most users. In order to run the Matlab code to build SCFG/MRF models for each motif group yourself:
-
-1. download and unzip the Matlab binary files for the desired release of the RNA 3D Motif Atlas from https://rna.bgsu.edu/data/jar3d/models/ and put them in a directory which we will call `JAR3DMOTIFDIRECTORY`.
-
-2. Start Matlab and set the working directory to where you would like the models to be written; they will be written to subfolders with names such as *IL/1.13*.
-
-3. Add to the path the directory *JAR3D/Matlab* from the Github distribution.
-
-4. Edit the program *JAR3D/Matlab/pJAR3DMaster.m* to set the `MotifLibraryLocation` to `JAR3DMOTIFDIRECTORY`.
-
-5. Set `JAR3Dpath` to the location of the Java code, ending with *JAR3D/target/classes*.
-
-6. Set `Pythonpath` to the location of the Python code, ending with *JAR3D\python*.
-
-7. Run pJAR3DMaster.m from Matlab.
diff --git a/matlab/convert_motif_groups_to_matlab.m b/matlab/convert_motif_groups_to_matlab.m
new file mode 100644
index 0000000..3ecbf0e
--- /dev/null
+++ b/matlab/convert_motif_groups_to_matlab.m
@@ -0,0 +1,257 @@
+function [void] = convert_motif_groups_to_matlab(MotifLibraryLocation,Input,loop_type,version,MotifLibraryPath)
+
+    [modified_base_to_parent,modified_base_atom_list,modified_atom_to_parent,parent_atom_to_modified,modified_base_to_hydrogens,modified_base_to_hydrogen_coordinates] = zDefineModifiedNucleotides();  % load in the modified nucleotide definitions
+
+	if ~exist([MotifLibraryLocation Input filesep 'release.json'],'file')
+		% download the release from the RNA Motif Atlas website
+		% https://rna.bgsu.edu/rna3dhub/motifs/release/il/3.92/json
+		url = ['https://rna.bgsu.edu/rna3dhub/motifs/release/' lower(loop_type) '/' version '/json'];
+		fprintf('pJAR3DMaster: downloading %s from the RNA Motif Atlas %s\n', Input, url)
+		options = weboptions('Timeout', 45); % Set timeout to 45 seconds
+		websave([MotifLibraryLocation Input filesep 'release.json'],url,options);
+	end
+
+	% read the json file into text
+	[MotifLibraryLocation Input filesep 'release.json']
+	json = fileread([MotifLibraryLocation Input filesep 'release.json']);
+
+	% replace ||||P_1 with empty string because motif atlas keeps them but Matlab does not
+	% may cause problems later if we download interactions from the RNA 3D Hub,
+	% we'll have to strip them out again there
+	json = regexprep(json,'(\|\|\|\|P_1)','');
+
+	% load the json file into a Matlab data structure
+	motif_list = jsondecode(json);
+
+	% we don't know ahead of time how many distinct pdb ids there will be
+	% make a set data structure that we can add to without duplication
+	pdb_ids = {};
+	% motif_structure is a cell array of structured variables
+	motif_structure = cell(1,length(motif_list));
+    GroupData(length(motif_list)) = struct();
+    pdb_id_to_motif_and_loop = containers.Map();
+
+    % get all pdb ids, and set up empty motif structure for each motif group
+	for i = 1:length(motif_list)
+		i
+		motif_list{i}
+		loop_ids = fieldnames(motif_list{i}.alignment);
+		for j = 1:numel(loop_ids)
+			loop_id = loop_ids{j};
+			fields = split(loop_ids{j},'_');
+			pdb_id = fields{2};
+			pdb_ids = [pdb_ids pdb_id];
+            if ~isKey(pdb_id_to_motif_and_loop,pdb_id)
+                pdb_id_to_motif_and_loop(pdb_id) = [];
+            end
+            pdb_id_to_motif_and_loop(pdb_id) = [pdb_id_to_motif_and_loop(pdb_id); [i j]];
+        end
+
+		num_instances = length(motif_list{i}.alignment);
+		num_positions = length(motif_list{i}.alignment.(loop_ids{1}));
+
+		% this is the structure we need to produce, although not all of these fields
+		% Candidates: [278Ã—7 uint16]
+		% File: [1Ã—278 struct]
+		% Query: [1Ã—1 struct]
+		% consensusEdge: [6Ã—6 double]
+		% Signature: 'cWW-cWW-cWW'
+
+		motif_structure{i} = struct();
+        motif_structure{i}.motid_id = motif_list{i}.motif_id;
+        motif_structure{i}.Candidates = zeros(num_instances,num_positions+1,'uint16');
+		motif_structure{i}.consensusEdge = zeros(num_positions,num_positions);
+		motif_structure{i}.bp_signature = motif_list{i}.bp_signature;  % text string
+		motif_structure{i}.Signature = motif_list{i}.bp_signature;  % text string
+		motif_structure{i}.chainbreak = motif_list{i}.chainbreak;
+
+		% create Truncate variable needed later
+		Truncate = zeros(length(motif_structure{i}.chainbreak),1);
+		if iscell(motif_structure{i}.chainbreak)
+		  for j = 1:length(motif_structure{i}.chainbreak)
+			% this code uses the index of the nucleotide after the break
+			Truncate(j) = str2double(motif_structure{i}.chainbreak{j})+1;
+		  end
+		else
+		  for j = 1:length(motif_structure{i}.chainbreak)
+			% this code uses the index of the nucleotide after the break
+			Truncate(j) = motif_structure{i}.chainbreak(j)+1;
+		  end
+		end
+		motif_structure{i}.Truncate = Truncate;
+
+        % some functions look for information in a Query field
+        motif_structure{i}.Query = struct();
+        motif_structure{i}.Query.Name = motif_list{i}.motif_id;
+        motif_structure{i}.MaxDiffMat = ones(1,num_positions);
+        for k = 1:length(motif_list{i}.chainbreak)
+            cb = motif_list{i}.chainbreak{k};
+            % pretty sure that you put Inf to indicate a chain break after position cb
+            % this is used in xFASTACandidates.m
+            motif_structure{i}.MaxDiffMat(cb) = Inf;
+        end
+
+        GroupData(i).MotifID = motif_list{i}.motif_id;
+        % GroupData(i).Signature = cell();
+        % GroupData(i).Signature{1} = motif_list{i}.signature;
+        % GroupData(i).NumNT = num_positions;
+        % GroupData(i).NumInstances = num_instances;
+        % GroupData(i).Structured = 1;   % just set it this way, maybe that's OK
+        % GroupData(i).NumStacks = 0;
+        % GroupData(i).NumBPh = 0;
+        % GroupData(i).NumBR = 0;
+        % GroupData(i).NumBasepairs = 0;
+        % GroupData(i).OwnSequence = cell(1,num_instances);
+        % GroupData(i).OwnScore = zeros(1,num_instances);
+        % GroupData(i).SequenceLengths = zeros(1,num_instances);
+	end
+
+	pdb_ids = unique(pdb_ids);
+	fprintf('pJAR3DMaster: found %d pdb ids\n',length(pdb_ids))
+
+	% loop over pdb_ids to only load each one once since that is slow
+
+	for p = 1:length(pdb_ids)
+		pdb_id_loaded = pdb_ids{p};
+		File = zAddNTData(pdb_id_loaded);
+
+        % remove the AA field from File
+        File = rmfield(File,'AA');
+        File = rmfield(File,'Het');
+
+		% download full loops in the structure so we can load any bulges
+		loop_filename = ['..\..\..\PDBFiles' filesep pdb_id_loaded '_loops.csv'];
+		if ~exist(loop_filename,'file')
+			url = ['https://rna.bgsu.edu/rna3dhub/loops/download_with_breaks/' pdb_id_loaded];
+			websave(loop_filename,url);
+			fprintf('Saved %s in %s', url, loop_filename);
+		end
+
+		% read the full loops in the structure into a Matlab data structure
+		fid = fopen(loop_filename);
+		lines = textscan(fid, '%s', 'Delimiter', '\n');
+		fclose(fid);
+		lines = lines{1};
+		loop_id_to_unit_ids = containers.Map('KeyType','char','ValueType','char');
+        % loop_id_to_border = containers.Map('KeyType','char','ValueType','uint16');
+		for a = 1:length(lines)
+			% remove leading and trailing double quotes
+			L = lines{a}(2:end-1);
+			% replace ||||P_1 with empty string because motif atlas keeps them but Matlab does not
+			% may cause problems later if we download interactions from the RNA 3D Hub,
+			% we'll have to strip them out again there
+			L = regexprep(L,'(\|\|\|\|P_1)','');
+			% split the line into fields by ","
+			fields = strsplit(L,'","');
+			loop_id = fields{1};
+			% map loop_id to comma-separated list of unit ids
+			loop_id_to_unit_ids(loop_id) = fields{2};
+            % loop_id_to_border(loop_id) = strsplit(fields{3},',');
+		end
+
+		% make a container to map unit ids to indices in the File structure
+		unit_id_to_index = containers.Map('KeyType','char','ValueType','uint16');
+		for n = 1:length(File.NT)
+			unit_id_to_index(File.NT(n).ID) = n;
+		end
+
+		% loop over motif_list many times, even though inefficient
+		for i = 1:length(motif_list)
+			% motif_list{i}.motif_id
+			loop_ids = fieldnames(motif_list{i}.alignment);
+
+			% loop over loop_ids in the motif group
+			for j = 1:numel(loop_ids)
+				loop_id = loop_ids{j};
+				fields = split(loop_id,'_');
+				pdb_id = fields{2};
+
+				if strcmp(pdb_id,pdb_id_loaded)
+					fprintf('%s %s %s %s\n',motif_list{i}.motif_id,loop_id,pdb_id,pdb_id_loaded)
+
+					% indices of core and bulged positions in the overall File.NT
+					all_unit_ids = strsplit(loop_id_to_unit_ids(loop_id),",");
+					all_indices = zeros(1,length(all_unit_ids));
+                    % border = 0;
+                    % sequence = '';
+                    % position_to_border = loop_id_to_border(loop_id);
+					for k = 1:length(all_unit_ids)
+						all_indices(k) = map_unit_id_to_index(unit_id_to_index,all_unit_ids{k});
+                        % fields = split(all_unit_ids{k},'|');
+                        % unit = fields{4};
+                        % if ismember(unit,{'A','C','G','U'})
+                        %     parent = unit;
+                        % elseif isKey(modified_base_to_parent,unit)
+                        %     parent = modified_base_to_parent(unit);
+                        % else
+                        %     fprintf('Could not find parent for %s\n',unit)
+                        %     crash
+                        % end
+                        % sequence = [sequence parent];
+
+                        % border = border + str2num(position_to_border{k});
+
+                        % % if border is a multiple of 2,
+                        % if border % 2 == 0
+                        %     sequence = [sequence '*'];
+                        % end
+					end
+
+                    % GroupData(i).OwnSequence{j} = sequence;
+
+                    % make sub-File including all nucleotides in each strand
+					sf = zSubFile(File,all_indices);
+
+					% map unit ids to indices in the sub-file
+					sf_unit_id_to_index = containers.Map('KeyType','char','ValueType','uint16');
+					for k = 1:length(sf.NT)
+						sf_unit_id_to_index(sf.NT(k).ID) = k;
+                        if sf.NT(k).Code > 4
+                            C = find(sf.NT(k).Base == 'ACGU');    % code number of parent base
+                            sf.NT(k).Code = C;                 % ignore that this is a modified base
+                        end
+					end
+
+					% get indices of each unit id relative to the subfile to save in candidates
+					% unit_ids in core positions in this loop
+					unit_ids = motif_list{i}.alignment.(loop_id);
+					candidate_indices = zeros(1,length(unit_ids)+1);
+					for k = 1:length(unit_ids)
+						candidate_indices(k) = map_unit_id_to_index(sf_unit_id_to_index,unit_ids{k});
+					end
+					% list column of candidate_indices points to the sub-file index
+					candidate_indices(end) = j;
+
+                    % make sure that the Edge matrix of basepairs includes all
+                    % flanking basepairs, even if they might not have been annotated
+                    % that way by Matlab code.
+                    % Some basepairs are assumed to be there because they are AU or GC or GU
+                    % even if they do not have good enough geometry to be annotated.
+                    % first and last nucleotides make a cWW pair in every loop
+                    sf.Edge(candidate_indices(1),candidate_indices(end-1)) = 1;
+                    for k = 1:length(motif_list{i}.chainbreak)
+                        cb = motif_list{i}.chainbreak{k};
+                        sf.Edge(cb,cb+1) = 1;
+                    end
+					% add a row to the candidate list
+					motif_structure{i}.Candidates(j,:) = candidate_indices;
+					% add the sub-file to the motif group in the correct place
+					motif_structure{i}.File(j) = sf;
+				end
+			end
+		end
+	end
+
+    % save the motif group data
+    % group_data_filename = [MotifLibraryLocation Input filesep upper(loop_type) '_GroupData.mat'];
+    % save(group_data_filename,'GroupData','-v7.3');
+
+	% loop over motif groups and save the individual files
+	fprintf('Saving motif group .mat files\n')
+	for i = 1:length(motif_list)
+		% save the motif group
+        fprintf('Saving %s\n',motif_list{i}.motif_id)
+		fn = [MotifLibraryPath filesep motif_list{i}.motif_id '.mat'];
+		Search = motif_structure{i};
+		save(fn,'Search','-v7.3');
+	end
diff --git a/matlab/map_unit_id_to_index.m b/matlab/map_unit_id_to_index.m
new file mode 100644
index 0000000..3359e62
--- /dev/null
+++ b/matlab/map_unit_id_to_index.m
@@ -0,0 +1,17 @@
+
+function index = map_unit_id_to_index(unit_id_to_index, unit_id)
+    if isKey(unit_id_to_index, unit_id)
+        index = unit_id_to_index(unit_id);
+    else
+        fields = split(unit_id, '|');
+        if length(fields) == 5 && isKey(unit_id_to_index,[unit_id '||A'])
+            index = unit_id_to_index([unit_id '||A']);
+        elseif length(fields) == 8 && fields{8} == 'a'
+            fields{8} = 'A';
+            fix_id = strjoin(fields, '|');
+            if isKey(unit_id_to_index, fix_id)
+                index = unit_id_to_index(fix_id);
+            end
+        end
+    end
+end
\ No newline at end of file
diff --git a/matlab/myrandsample.m b/matlab/myrandsample.m
index 0ce0005..9e9c7eb 100644
--- a/matlab/myrandsample.m
+++ b/matlab/myrandsample.m
@@ -1,3 +1,5 @@
+% use the probabilities in x to generate a matrix with M rows and N columns
+
 function [r] = rando(x,M,N)
 
 n = length(x);
diff --git a/matlab/pCalculateTransitions.m b/matlab/pCalculateTransitions.m
index 1a5079c..8dd12f1 100644
--- a/matlab/pCalculateTransitions.m
+++ b/matlab/pCalculateTransitions.m
@@ -11,20 +11,26 @@ transitionCounts = zeros(4,4);    %(A,C,G,U)^2
 initialTransitionCounts = zeros(4,4);    %(A,C,G,U)^2
 TransitionFile = [OutputPath filesep 'transitions.mat'];
 
-for m = 1:length(Filenames),
+for m = 1:length(Filenames)
   MotifName = Filenames(m).name;
   load([MotifLibraryPath filesep MotifName '.mat']);
-  [Search,Node] = pMakeSingleJAR3DModel(Search,Param,Prior,loopType);
 
-  if isempty(Node),
+  % [Search,Node] = pMakeSingleJAR3DModel(Search,Param,Prior,loopType);
+
+  Node = [1,2];   % spoof it for next line
+
+  if isempty(Node)
 %    mkdir([MotifLibraryPath filesep 'trouble']);
-%    movefile([MotifLibraryPath filesep MotifName '.mat'],[MotifLibraryPath filesep 'trouble' filesep MotifName '.mat']); 
-    fprintf('@@@@@@@@@@@@ pCalculateTransitions: Motif %s could not be modeled\n', MotifName);
+%    movefile([MotifLibraryPath filesep MotifName '.mat'],[MotifLibraryPath filesep 'trouble' filesep MotifName '.mat']);
+    fprintf('@@@@@@@@@@@@ pCalculateTransitions: Motif %s has no Node and so could not be modeled\n', MotifName);
   else
     [Text,T3,T4,T5] = xFASTACandidates(Search.File,Search,1,MotifName);
 
-    % ---------- extract sequences counts for transition matricies
-  
+    % ---------- extract sequence counts for transition matricies
+
+    fprintf('pCalculateTransitions:  processing %s\n', MotifName);
+    disp(Text)
+
     [cWW, initial, transition, core, initialTransition] = pExtractSequenceCounts(Text);
     cWWCounts = cWWCounts + cWW;
     initialCounts = initialCounts + initial;
@@ -34,7 +40,7 @@ for m = 1:length(Filenames),
   end
 end
 
-cWW_M = cWWCounts/sum(cWWCounts); 
+cWW_M = cWWCounts/sum(cWWCounts);
 initial_M = initialCounts/sum(initialCounts);
 core_M = coreCounts/sum(coreCounts);
 transition_M(1,:) = transitionCounts(1,:)/sum(transitionCounts(1,:));
@@ -48,12 +54,15 @@ initialTransition_M(4,:) = initialTransitionCounts(4,:)/sum(initialTransitionCou
 
 save(TransitionFile, 'cWW_M', 'initial_M', 'transition_M');
 
-fprintf('pCalculateTransitions:  cWW basepair probabilities are\n');
+fprintf('pCalculateTransitions:  cWW basepair probabilities for CG, GC, AU, UA, GU, UG are\n');
 cWW_M
 
-fprintf('pCalculateTransitions:  initial distribution is\n');
+fprintf('pCalculateTransitions:  initial distribution for A, C, G, U is\n');
 initial_M
 
-fprintf('pCalculateTransitions:  transition matrix is\n');
+fprintf('pCalculateTransitions:  initial transition matrix is\n');
+initialTransition_M
+
+fprintf('pCalculateTransitions:  interior transition matrix is\n');
 transition_M
 
diff --git a/matlab/pColumnsForModelRecursive.m b/matlab/pColumnsForModelRecursive.m
index 3595aba..f7f28cb 100644
--- a/matlab/pColumnsForModelRecursive.m
+++ b/matlab/pColumnsForModelRecursive.m
@@ -1,6 +1,6 @@
 % pColumnsForModel lists out what column each part of a JAR3D model should go into when displayed
 
-% This program needs to call itself recursively to deal with junctions!!!
+% This program needs to call itself recursively to deal with junctions
 
 % load 'MotifLibrary\IL_018.mat'
 % JAR3D_path
@@ -15,30 +15,32 @@ clear T                                % build up lines from the left
 r = 1;
 clear U                                % build up lines from the right,
                                        % will be read backwards
+U = [];
+
 s = 1;
 
-n = N;
+n = N;                                 % node number to start working
 continu = 1;
 
 while continu > 0,
   if strcmp(Node(n).type,'Initial')
-    if length(Node(n).leftLengthDist) > 1,
+    if length(Node(n).leftLengthDist) > 1
       T{r} = sprintf('Node_%d_Position_1_Insertion', n);
       r = r + 1;
     end
-    if length(Node(n).rightLengthDist) > 1,
+    if length(Node(n).rightLengthDist) > 1
       U{s} = sprintf('Node_%d_Position_2_Insertion', n);
       s = s + 1;
     end
-  elseif strcmp(Node(n).type,'Fixed'),
-    if length(Node(n).leftLengthDist) > 1,
+  elseif strcmp(Node(n).type,'Fixed')
+    if length(Node(n).leftLengthDist) > 1
       T{r} = sprintf('Node_%d_Position_1', n);
       r = r + 1;
     else
       U{s} = sprintf('Node_%d_Position_2', n);
       s = s + 1;
     end
-  elseif strcmp(Node(n).type,'Basepair'),
+  elseif strcmp(Node(n).type,'Basepair')
     T{r} = sprintf('Node_%d_Position_1', n);
     r = r + 1;
     T{r} = sprintf('Node_%d_Position_1_Insertion', n);
@@ -49,7 +51,7 @@ while continu > 0,
     s = s + 1;
   elseif strcmp(Node(n).type,'Cluster')
     k = 1;
-    for j = 1:(length(Node(n).LeftIndex)-1),
+    for j = 1:(length(Node(n).LeftIndex)-1)
       T{r} = sprintf('Node_%d_Position_%d', n, k);
       r = r + 1;
       T{r} = sprintf('Node_%d_Position_%d-%d_Insertion', n, k, k+1);
@@ -62,7 +64,7 @@ while continu > 0,
 
     kk = length(Node(n).LeftIndex) + length(Node(n).RightIndex);
 
-    for j = 1:(length(Node(n).RightIndex)-1),
+    for j = 1:(length(Node(n).RightIndex)-1)
       U{s} = sprintf('Node_%d_Position_%d', n, kk);
       s = s + 1;
       U{s} = sprintf('Node_%d_Position_%d-%d_Insertion', n, kk-1, kk);
@@ -73,7 +75,7 @@ while continu > 0,
     s = s + 1;
   elseif strcmp(Node(n).type,'Hairpin')
     k = 1;
-    for j = 1:(length(Node(n).MiddleIndex)-1),
+    for j = 1:(length(Node(n).MiddleIndex)-1)
       T{r} = sprintf('Node_%d_Position_%d', n, k);
       r = r + 1;
       T{r} = sprintf('Node_%d_Position_%d-%d_Insertion', n, k, k+1);
@@ -83,21 +85,22 @@ while continu > 0,
     T{r} = sprintf('Node_%d_Position_%d', n, k);
     r = r + 1;
 
-    T = [T fliplr(U)];                  % append, reverse entries of U
     continu = 0;                        % stop after a hairpin
   elseif strcmp(Node(n).type,'Junction')
-    disp('Junction nodes have not been tested in pColumnsForModelRecursive');
-    T = [T pColumnsForModelRecursive(Node,ModelName,Node(n).nextnode(1))];
-    T = [T pColumnsForModelRecursive(Node,ModelName,Node(n).nextnode(2))];
-    T = [T fliplr(U)];
+    T = [T pColumnsForModelRecursive(Node,Node(n).nextnode(1))];
+    T = [T pColumnsForModelRecursive(Node,Node(n).nextnode(2))];
     continu = 0;
   elseif strcmp(Node(n).type,'Alternative')
     disp('Alternative nodes are not set up in pColumnsForModelRecursive');
     continu = 0;
   end
 
+  if continu == 0
+    T = [T fliplr(U)];                  % append, reverse entries of U
+  end
+
   n = n + 1;
-  if n > length(Node),
+  if n > length(Node)
     continu = 0;
   end
 end
diff --git a/matlab/pConsensusPairSubstitution.m b/matlab/pConsensusPairSubstitution.m
index 8a50618..bb69421 100644
--- a/matlab/pConsensusPairSubstitution.m
+++ b/matlab/pConsensusPairSubstitution.m
@@ -1,4 +1,4 @@
-% pConsensusPairSubstitution(a,b,f,File,F,L,Search) looks at the letter pairs corresponding to nucleotides a and b of the query motif in Search, uses interactions in F as the consensus, 
+% pConsensusPairSubstitution(a,b,f,File,F,L,Search) looks at the letter pairs corresponding to nucleotides a and b of the query motif in Search, uses interactions in F as the consensus,
 
 % The argument Noncanonical being set to 1 means that this pair should set low probabilities for CG, GC, AU, and UA base combinations, because this pair is the first non-canonical pair in a motif.
 
@@ -10,7 +10,7 @@ end
 
 Verbose = Param(1);
 
-Score = zeros(4,4);                       % ready to sum IsoScores for this pair 
+Score = zeros(4,4);                       % ready to sum IsoScores for this pair
 Count = zeros(4,4);                       % tally observed basepairs here
 
 [L,N] = size(Search.Candidates);          % L = num instances; N = num NT
@@ -148,7 +148,7 @@ else                                      % conserved but non-basepairing positi
       fprintf('pConsensusPairSubstitution: File %4s has non-basepairing core base %s%4s\n', File(f(c)).Filename, NT1.Base, NT1.Number);
     end
 
-    Count(1,NT1.Code) = Count(1,NT1.Code) + 1;    
+    Count(1,NT1.Code) = Count(1,NT1.Code) + 1;
   end
 
   Pr = Prior(1:4);
diff --git a/matlab/pEditDistance.m b/matlab/pEditDistance.m
index c916368..c977491 100644
--- a/matlab/pEditDistance.m
+++ b/matlab/pEditDistance.m
@@ -1,12 +1,17 @@
-% pEditDistance calculates the pairwise edit distances between the sequences in F and G, which are assumed to be of type loopType.  It returns a length(F) x length(G) matrix of pairwise edit distances.
-% For internal loops, D1 is the minimum edit distance over both strand orders, D2 is the edit distance in the given order, D3 reversed order
+% deprecated
+
+% pEditDistance calculates the pairwise edit distances between the sequences in F and G,
+% which are assumed to be of type loopType.
+% It returns a length(F) x length(G) matrix of pairwise edit distances.
+% For internal loops, D1 is the minimum edit distance over both strand orders,
+% D2 is the edit distance in the given order, D3 reversed order
 % location can be 'full' or 'core'
 
 function [D1,D2,D3] = pEditDistance(F,G,loopType,location)
 
 m = length(F);
 
-if isempty(G),
+if isempty(G)
   G = F;
   self = 1;
 else
@@ -15,11 +20,11 @@ end
 
 n = length(G);
 
-if nargin < 3,
+if nargin < 3
   loopType = 'HL';
 end
 
-if nargin < 4,
+if nargin < 4
   location = 'Full';
 end
 
@@ -27,15 +32,15 @@ D1 = Inf * ones(m,n);
 D2 = Inf * ones(m,n);
 D3 = Inf * ones(m,n);
 
-if strcmp(class(F),'struct') && strcmp(class(G),'struct'),
+if strcmp(class(F),'struct') && strcmp(class(G),'struct')
   F = lower(F);
   G = lower(G);
-  if strcmp(loopType,'HL'),
-    for a = 1:m,
-      if self > 0,
+  if strcmp(loopType,'HL')
+    for a = 1:m
+      if self > 0
         D2(a,a) = 0;
         D3(a,a) = 0;
-        for b = (a+1):n,
+        for b = (a+1):n
           d = pEditDistanceHL(F(a).Sequence,G(b).Sequence,location);
           D2(a,b) = d(1);
           D3(a,b) = d(1);
@@ -43,7 +48,7 @@ if strcmp(class(F),'struct') && strcmp(class(G),'struct'),
           D3(b,a) = d(1);
         end
       else
-        for b = 1:n,
+        for b = 1:n
           d = pEditDistanceHL(F(a).Sequence,G(b).Sequence,location);
           D1(a,b) = d(1);
           D2(a,b) = d(1);
@@ -52,25 +57,25 @@ if strcmp(class(F),'struct') && strcmp(class(G),'struct'),
       end
     end
   end
-  if strcmp(loopType,'IL'),
-    for a = 1:m,
-      if self > 0,
-        for b = a:n,
+  if strcmp(loopType,'IL')
+    for a = 1:m
+      if self > 0
+        for b = a:n
           d = pEditDistanceIL(F(a).Sequence,G(b).Sequence,location);
           D2(a,b) = d(2);
           D3(a,b) = d(3);
-          D2(b,a) = d(2);
+          D2(b,a) = d(2);  % self edit distances, symmetric matrix
           D3(b,a) = d(3);
         end
       else
-        for b = 1:n,
+        for b = 1:n
           d = pEditDistanceIL(F(a).Sequence,G(b).Sequence,location);
           D2(a,b) = d(2);
           D3(a,b) = d(3);
         end
       end
     end
-    if sum(sum(D2)) < sum(sum(D3)),
+    if sum(sum(D2)) < sum(sum(D3))
       D1 = D2;
     else
       D1 = D3;
diff --git a/matlab/pEditDistanceAll.m b/matlab/pEditDistanceAll.m
new file mode 100644
index 0000000..675fa20
--- /dev/null
+++ b/matlab/pEditDistanceAll.m
@@ -0,0 +1,81 @@
+% pEditDistanceAll calculates the pairwise edit distances between the sequences in F and G,
+% which are assumed to be of type loopType.
+% It returns a length(F) x length(G) matrix of pairwise edit distances.
+% location can be 'full' or 'core'
+% It does not do any rotations.
+% It returns one distance matrix.
+
+function [D] = pEditDistanceAll(F,G,location)
+
+    if isempty(G)
+        G = F;
+        self = 1;
+    else
+        self = 0;
+    end
+
+    if nargin < 3 || strcmp(location,'full')
+        full = 1;
+    else
+        full = 0;
+    end
+
+    m = length(F);
+    n = length(G);
+
+    D = Inf * ones(m,n);
+
+    if full == 1
+        % loop over G first because that usually has more sequences
+        for b = 1:n
+            % split G sequence according to * character
+            G_parts = strsplit(G(b).Sequence,'*');
+            for a = 1:m
+                % split F sequence according to * character
+                F_parts = strsplit(F(a).Sequence,'*');
+                d = 0;
+                for k = 1:length(G_parts)
+                    d = d + EditDist(F_parts{k},G_parts{k});
+                end
+                D(a,b) = d;
+
+                % if d < 4
+                %     fprintf('F sequence %20s G sequence %20s full distance %4d\n',F(a).Sequence,G(b).Sequence,d);
+                % end
+            end
+        end
+    else
+        % loop over G first because that usually has more sequences
+        for b = 1:n
+            % split G sequence according to * character
+            G_parts = strsplit(G(b).Sequence,'*');
+            for k = 1:length(G_parts)
+                gp = G_parts{k};
+                % remove flanking bases
+                G_parts{k} = gp(2:(end-1));
+            end
+            for a = 1:m
+                % split F sequence according to * character
+                F_parts = strsplit(F(a).Sequence,'*');
+                d = 0;
+                for k = 1:length(G_parts)
+                    fp = F_parts{k};
+                    % remove flanking bases
+                    F_parts{k} = fp(2:(end-1));
+                    d = d + EditDist(F_parts{k},G_parts{k});
+                end
+                D(a,b) = d;
+
+                % if d < 4
+                %     fs = F_parts{1};
+                %     gs = G_parts{1};
+                %     for k = 2:length(G_parts)
+                %         fs = [fs '*' F_parts{k}];
+                %         gs = [gs '*' G_parts{k}];
+                %     end
+                %     fprintf('F sequence %20s becomes %16s G sequence %20s becomes %16s core distance %4d\n',F(a).Sequence,fs,G(b).Sequence,gs,d);
+                % end
+            end
+        end
+    end
+end
\ No newline at end of file
diff --git a/matlab/pEditDistanceHL.m b/matlab/pEditDistanceHL.m
index 3a7a2c0..3f5025a 100644
--- a/matlab/pEditDistanceHL.m
+++ b/matlab/pEditDistanceHL.m
@@ -1,3 +1,5 @@
+% deprecated
+
 % pEditDistanceIL(a,b) treats a and b as a hairpin loop sequence.  It returns full or interior/core edit distance, as requested.
 
 function [d] = pEditDistanceHL(a,b,location)
diff --git a/matlab/pEditDistanceIL.m b/matlab/pEditDistanceIL.m
index 9abeb0f..e8f0b04 100644
--- a/matlab/pEditDistanceIL.m
+++ b/matlab/pEditDistanceIL.m
@@ -1,4 +1,7 @@
-% pEditDistanceIL(a,b) treats a and b as internal loop sequences, ungapped, with * to separate the strands.  It returns several measures of edit distance.
+% deprecated
+
+% pEditDistanceIL(a,b) treats a and b as internal loop sequences, ungapped,
+% with * to separate the strands.  It returns several measures of edit distance.
 % location == full
 % d(1) = overall edit distance, minimum over both rotations
 % d(2) = overall edit distance, original rotation
@@ -12,16 +15,16 @@ function [d] = pEditDistanceIL(a,b,location)
 
 d = zeros(1,3);                           % initial value
 
-if nargin < 3,
+if nargin < 3
   location = 'full';
 end
 
 i = strfind(a,'*');
 j = strfind(b,'*');
 
-if length(i) ~= 1 || length(j) ~= 1,
+if length(i) ~= 1 || length(j) ~= 1
   d = Inf * ones(1,3);
-elseif strcmpi(location,'full'),
+elseif strcmpi(location,'full')
   p = a(1:(i-1));                             % first sequence, first strand
   q = a((i+1):end);                           % first sequence, second strand
   r = b(1:(j-1));                             % second sequence, first strand
@@ -41,7 +44,7 @@ else
   d(1) = min(d(2),d(3));                      % minimum core distance
 end
 
-if 0 > 1,
+if 0 > 1
   w = p([1 end]);                             % first, first, flank
   x = q([1 end]);                             % first, second, flank
   y = r([1 end]);                             % second, first, flank
diff --git a/matlab/pExtractSequenceCounts.m b/matlab/pExtractSequenceCounts.m
index 37c3cc6..e5a61f8 100644
--- a/matlab/pExtractSequenceCounts.m
+++ b/matlab/pExtractSequenceCounts.m
@@ -1,94 +1,140 @@
 function [cWWCounts, initialCounts, transitionCounts, coreCounts, initialTransitionCounts] = pExtractSequenceCounts(Text)
-cWWCounts = zeros(6,1);           %CG,GC,AU,UA,GU,UG
-initialCounts = zeros(4,1);       %A,C,G,U
-coreCounts = zeros(4,1);          %A,C,G,U
-transitionCounts = zeros(4,4);    %(A,C,G,U)^2
-initialTransitionCounts = zeros(4,4);    %(A,C,G,U)^2
-numSeq = floor(length(Text)/2);
-for i = 1:numSeq,
-    sequence = Text{2*i};
-    seqLength = length(sequence);
-    clear breakPoint;
-    breakPoint = strfind(sequence, '*');
-    cWW1 = strcat(sequence(1),sequence(seqLength));
-    switch cWW1,
-        case {'CG','cg','Cg','cG'}
-            cWWCounts(1) = cWWCounts(1) + 1;
-        case {'GC','gc','Gc','gC'}
-            cWWCounts(2) = cWWCounts(2) + 1;
-        case {'AU','au','Au','aU'}
-            cWWCounts(3) = cWWCounts(3) + 1;
-        case {'UA','ua','Ua','uA'}
-            cWWCounts(4) = cWWCounts(4) + 1;
-        case {'GU','gu','Gu','gU'}
-            cWWCounts(5) = cWWCounts(5) + 1;
-        case {'UG','ug','Ug','uG'}
-            cWWCounts(6) = cWWCounts(6) + 1;
-    end
-    if ~isempty(breakPoint),
-        cWW2 = strcat(sequence(breakPoint-1),sequence(breakPoint+1));
-        switch cWW2,
-            case {'CG','cg','Cg','cG'}
+
+    % Text is a cell array alternating between header and sequence
+
+    cWWCounts = zeros(6,1);           %CG,GC,AU,UA,GU,UG
+    initialCounts = zeros(4,1);       %A,C,G,U
+    coreCounts = zeros(4,1);          %A,C,G,U
+    transitionCounts = zeros(4,4);    %(A,C,G,U)^2
+    initialTransitionCounts = zeros(4,4);    %(A,C,G,U)^2
+    numSeq = floor(length(Text)/2);
+    for i = 1:numSeq
+        sequence = Text{2*i};
+        seqLength = length(sequence);
+        breakPoint = strfind(sequence, '*');  % locations of * characters
+
+        % outer cWW pair, which is present in every loop
+        cWW1 = strcat(sequence(1),sequence(seqLength));
+        switch upper(cWW1)
+            case 'CG'
                 cWWCounts(1) = cWWCounts(1) + 1;
-            case {'GC','gc','Gc','gC'}
+            case 'GC'
                 cWWCounts(2) = cWWCounts(2) + 1;
-            case {'AU','au','Au','aU'}
+            case 'AU'
                 cWWCounts(3) = cWWCounts(3) + 1;
-            case {'UA','ua','Ua','uA'}
+            case 'UA'
                 cWWCounts(4) = cWWCounts(4) + 1;
-            case {'GU','gu','Gu','gU'}
+            case 'GU'
                 cWWCounts(5) = cWWCounts(5) + 1;
-            case {'UG','ug','Ug','uG'}
+            case 'UG'
                 cWWCounts(6) = cWWCounts(6) + 1;
         end
-    else
-        breakPoint = seqLength;
-    end
-    if breakPoint > 3,
-        index0 = nuc2num(sequence(1));
-        index = nuc2num(sequence(2));
-        initialTransitionCounts(index0,index) = initialTransitionCounts(index0,index) +1;
-        initialCounts(index) = initialCounts(index) + 1;
-        coreCounts(index) = coreCounts(index) + 1;
-    end
-    if seqLength - breakPoint > 3,
-        index0 = nuc2num(sequence(breakPoint+1));
-        index = nuc2num(sequence(breakPoint+2));
-        initialTransitionCounts(index0,index) = initialTransitionCounts(index0,index) +1;
-        initialCounts(index) = initialCounts(index) + 1;
-        coreCounts(index) = coreCounts(index) + 1;
-    end
-    if breakPoint > 4,
-        index1 = nuc2num(sequence(2));
-        for j = 3:breakPoint-2
-            index2 = nuc2num(sequence(j));
-            coreCounts(index2) = coreCounts(index2) + 1;
-            transitionCounts(index1,index2) = transitionCounts(index1,index2) + 1;
-            index1 = index2;
+
+        for bp = breakPoint
+            % count cWW pairs across the * characters for IL, J3, etc.
+            cWW2 = strcat(sequence(bp-1),sequence(bp+1));
+            switch upper(cWW2)
+                case 'CG'
+                    cWWCounts(1) = cWWCounts(1) + 1;
+                case 'GC'
+                    cWWCounts(2) = cWWCounts(2) + 1;
+                case 'AU'
+                    cWWCounts(3) = cWWCounts(3) + 1;
+                case 'UA'
+                    cWWCounts(4) = cWWCounts(4) + 1;
+                case 'GU'
+                    cWWCounts(5) = cWWCounts(5) + 1;
+                case 'UG'
+                    cWWCounts(6) = cWWCounts(6) + 1;
+            end
         end
-    end
-    if seqLength - breakPoint > 4,
-        index1 = nuc2num(sequence(breakPoint+2));
-        for j = breakPoint+3:seqLength-2
-            index2 = nuc2num(sequence(j));
-            coreCounts(index2) = coreCounts(index2) + 1;
-            transitionCounts(index1,index2) = transitionCounts(index1,index2) + 1;
-            index1 = index2;
+
+        starts = [1 breakPoint+1];   % starting point of every strand
+        ends = [breakPoint-1 seqLength];   % ending points of every strand
+
+        % loop over strands
+        for j = 1:length(starts)
+            seq = sequence(starts(j):ends(j));
+
+            if length(seq) > 3
+                % process start of seq
+                index0 = nuc2num(seq(1));
+                index = nuc2num(seq(2));
+                initialTransitionCounts(index0,index) = initialTransitionCounts(index0,index) + 1;
+                initialCounts(index) = initialCounts(index) + 1;
+                coreCounts(index) = coreCounts(index) + 1;
+            end
+
+            if length(seq) > 4
+                % process transitions within interior of seq
+                index1 = nuc2num(seq(2));
+                for k = 3:length(seq)-1
+                    index2 = nuc2num(seq(k));
+                    coreCounts(index2) = coreCounts(index2) + 1;
+                    transitionCounts(index1,index2) = transitionCounts(index1,index2) + 1;
+                    index1 = index2;
+                end
+            end
+        end
+
+        if 0 > 1
+            % earlier code that handled HL and IL
+            % special cases depending on how long the strands are ...
+            % previously breakpoint was just a single number, * location for IL, end of strand for HL
+            % looks like we need to just process each strand separately using this code
+            % did the second strand of IL ever get processed?
+            if breakPoint > 3
+                % start of first strand if it is long enough
+                index0 = nuc2num(sequence(1));
+                index = nuc2num(sequence(2));
+                initialTransitionCounts(index0,index) = initialTransitionCounts(index0,index) +1;
+                initialCounts(index) = initialCounts(index) + 1;
+                coreCounts(index) = coreCounts(index) + 1;
+            end
+            if seqLength - breakPoint > 3
+                % start of second strand if it is long enough
+                index0 = nuc2num(sequence(breakPoint+1));
+                index = nuc2num(sequence(breakPoint+2));
+                initialTransitionCounts(index0,index) = initialTransitionCounts(index0,index) +1;
+                initialCounts(index) = initialCounts(index) + 1;
+                coreCounts(index) = coreCounts(index) + 1;
+            end
+            if breakPoint > 4
+                % transitions in core of first strand if it is long enough
+                index1 = nuc2num(sequence(2));
+                for j = 3:breakPoint-2
+                    index2 = nuc2num(sequence(j));
+                    coreCounts(index2) = coreCounts(index2) + 1;
+                    transitionCounts(index1,index2) = transitionCounts(index1,index2) + 1;
+                    index1 = index2;
+                end
+            end
+            if seqLength - breakPoint > 4
+                % transitions in core of second strand if it is long enough
+                index1 = nuc2num(sequence(breakPoint+2));
+                for j = breakPoint+3:seqLength-2
+                    index2 = nuc2num(sequence(j));
+                    coreCounts(index2) = coreCounts(index2) + 1;
+                    transitionCounts(index1,index2) = transitionCounts(index1,index2) + 1;
+                    index1 = index2;
+                end
+            end
         end
     end
 end
-end
 
 function index = nuc2num(nuc)
-index = -1;
-switch nuc,
-    case {'A','a'}
-        index = 1;
-    case {'C','c'}
-        index = 2;
-    case {'G','g'}
-        index = 3;
-    case {'U','u'}
-        index = 4;
-end
+    index = -1;
+    switch upper(nuc)
+        case 'A'
+            index = 1;
+        case 'C'
+            index = 2;
+        case 'G'
+            index = 3;
+        case 'U'
+            index = 4;
+        otherwise
+            fprintf('pExtractSequenceCounts: Unknown nucleotide %s\n',nuc);
+    end
 end
\ No newline at end of file
diff --git a/matlab/pGenerateRandomMotifSequences.m b/matlab/pGenerateRandomMotifSequences.m
index 21bae66..b186f4c 100644
--- a/matlab/pGenerateRandomMotifSequences.m
+++ b/matlab/pGenerateRandomMotifSequences.m
@@ -1,8 +1,8 @@
 % pGenerateRandomMotifSequences generates random sequences to score against models
 
-function [void] = pGenerateRandomMotifSequences(OutputBase,Release,Mode)
+function [numfiles] = pGenerateRandomMotifSequences(OutputBase,Release,Mode)
 
-if nargin < 3,
+if nargin < 3
   Mode = 3;                           % no constraints on base combinations
 end
 
@@ -10,20 +10,17 @@ numrepeats = 50;                      % number of repetitions of each combinatio
 
 loopType = Release(1:2);
 
-switch loopType,
+numfiles = 20;
+switch loopType
 case 'HL'
   numfiles = 20;
 case 'IL'
   numfiles = 20;
 end
 
-switch loopType,
-case 'JL'
-  Rotations = 3;                      % three rotations, for 3-way junctions
-case 'IL'
-  Rotations = 2;                      % two rotations are computed
-case 'HL'
-  Rotations = 1;                      % only one "rotation"
+if loopType(1) == 'J'
+  numrepeats = 30;
+  numfiles = 15;
 end
 
 Release = strrep(Release,'\',filesep);
@@ -39,7 +36,7 @@ GroupData = pGetModelData(OutputPath,loopType);
 
 clear SeqNames
 
-for m = 1:length(GroupData),
+for m = 1:length(GroupData)
   SeqNames{m} = [GroupData(m).MotifID '.fasta'];
 end
 
@@ -50,13 +47,13 @@ TransitionFile = [OutputPath filesep 'transitions.mat'];
 clear seqlengths
 clear nummodelsbylengths
 
-switch loopType,
+switch loopType
 case 'HL'
-	for s = 1:length(FASTA),
+	for s = 1:length(FASTA)
 		seqlengths(s,1) = length(FASTA(s).Sequence);
 	end
   [uniqueseqlengths,i,j] = unique(seqlengths,'rows');
-	for k = 1:length(i),
+	for k = 1:length(i)
 		a = uniqueseqlengths(k,1);
 		nummodelsbylengths(a,1) = length(unique(OwnMotif(find(j==k))));
 	end
@@ -71,29 +68,46 @@ case 'HL'
 
 	T = [seqlengths OwnMotif];
 	T = sortrows(T,[1 2]);
-case 'IL'
-	for s = 1:length(FASTA),
-		i = strfind(FASTA(s).Sequence,'*');
-		j = length(FASTA(s).Sequence) - i;
-		seqlengths(s,1) = min(i-1,j);
-		seqlengths(s,2) = max(i-1,j);
+
+otherwise
+  % IL, J3, J4, etc.
+  for s = 1:length(FASTA)
+		i = strfind(['*' FASTA(s).Sequence '*'],'*');
+    lengths = diff(i) - 1;
+    % put shortest length first by permuting cyclically
+    [y,i] = min(lengths);
+    i = i(1);
+    seqlengths(s,:) = lengths([i:end 1:(i-1)]);
+    % seqlengths(s,1) = min(i-1,j);
+		% seqlengths(s,2) = max(i-1,j);
 	end
   [uniqueseqlengths,i,j] = unique(seqlengths,'rows');
 
-	for k = 1:length(i),
-		a = uniqueseqlengths(k,1);
-		b = uniqueseqlengths(k,2);
-		nummodelsbylengths(a,b) = length(unique(OwnMotif(find(j==k))));
-	end
+  % not used
+	% for k = 1:length(i)
+	% 	a = uniqueseqlengths(k,1);
+	% 	b = uniqueseqlengths(k,2);
+	% 	nummodelsbylengths(a,b) = length(unique(OwnMotif(find(j==k))));
+	% end
 
+  % round out the selection of sequences somewhat
   newlengths = [];
-
-  for k = 1:length(uniqueseqlengths(:,1)),
-    if uniqueseqlengths(k,1) < uniqueseqlengths(k,2),
-      newlengths(end+1,:) = uniqueseqlengths(k,:) + [1 0];
+  if strcmp(loopType,'IL')
+    for k = 1:length(uniqueseqlengths(:,1))
+      if uniqueseqlengths(k,1) < uniqueseqlengths(k,2)
+        newlengths(end+1,:) = uniqueseqlengths(k,:) + [1 0];
+      end
+      newlengths(end+1,:) = uniqueseqlengths(k,:) + [0 1];
+      newlengths(end+1,:) = uniqueseqlengths(k,:) + [1 1];
+    end
+  else
+    for k = 1:length(uniqueseqlengths(:,1))
+      for m = 1:length(uniqueseqlengths(k,:))
+        t = uniqueseqlengths(k,:);
+        t(m) = t(m) + 1;
+        newlengths(end+1,:) = t;
+      end
     end
-    newlengths(end+1,:) = uniqueseqlengths(k,:) + [0 1];
-    newlengths(end+1,:) = uniqueseqlengths(k,:) + [1 1];
   end
 
   [uniqueseqlengths,i,j] = unique([uniqueseqlengths; newlengths],'rows');
@@ -104,19 +118,19 @@ end
 
 % j maps from all sequences to rows of the uniqueseqlengths vector
 
-fprintf('Unique sequence lengths:\n');
-uniqueseqlengths
+fprintf('pGenerateRandomMotifSequences: Unique sequence lengths:\n');
+disp(uniqueseqlengths)
 
-fprintf('Size of unique seq lengths:\n');
+fprintf('pGenerateRandomMotifSequences: Size of unique seq lengths:\n');
 size(uniqueseqlengths)
 
 seqlengths = [];
 
-for r = 1:length(uniqueseqlengths(:,1)),
+for r = 1:length(uniqueseqlengths(:,1))
   seqlengths = [seqlengths; ones(numrepeats,1)*uniqueseqlengths(r,:)];
 end
 
-for v = 1:numfiles,
+for v = 1:numfiles
 	Sequences = pMakeRandomSequencesWeighted(seqlengths,loopType,length(seqlengths(:,1)),TransitionFile,Mode);
   switch Mode
   case 1
@@ -127,10 +141,8 @@ for v = 1:numfiles,
     FN = [ModelPath filesep loopType '_RandomMotifSequences_' num2str(v) '.fasta'];
   end
 	fid = fopen(FN,'w');
-	for s = 1:length(Sequences),
+	for s = 1:length(Sequences)
 		fprintf(fid,'%s\n',Sequences{s});
 	end
 	fclose(fid);
 end
-
-
diff --git a/matlab/pGetModelData.m b/matlab/pGetModelData.m
index 5dc90f8..18fc41e 100644
--- a/matlab/pGetModelData.m
+++ b/matlab/pGetModelData.m
@@ -2,11 +2,16 @@
 
 function [GroupData, MotifEquivalence] = pGetModelData(OutputPath,loopType)
 
-load([OutputPath filesep loopType '_GroupData.mat'],'GroupData');
+filename = [OutputPath filesep loopType '_GroupData.mat'];
+fprintf('pGetModelData: loading %s\n',filename);
+
+load(filename,'GroupData');
+fprintf('Loaded GroupData from %s\n',filename);
 
 try
-  load([OutputPath filesep loopType '_GroupData_with_full_cutoffs.mat'],'GroupData');
-  fprintf('Loaded GroupData with model-specific cutoffs\n');
+  filename = [OutputPath filesep loopType '_GroupData_with_full_cutoffs.mat'];
+  load(filename,'GroupData');
+  fprintf('Loaded GroupData with model-specific cutoffs from %s\n',filename);
 end
 
 keep = ones(1,length(GroupData));
@@ -21,13 +26,18 @@ MotifEquivalence = zeros(length(GroupData),length(GroupData));
 MotifNotEquiv    = zeros(length(GroupData),length(GroupData));
 FN = [OutputPath filesep 'lib' filesep 'equivalent_motifs.txt'];
 
-switch loopType,
+switch loopType
 case 'IL'
   Rotations = 1;
 case 'HL'
   Rotations = 0;
 end
 
+if loopType(1) == 'J'
+  Rotations = str2num(replace(loopType,'J',''));
+end
+
+
 for m = 1:length(GroupData),
   MotifNames{m,1} = GroupData(m).MotifID;
   SequenceLengths = [];
@@ -108,22 +118,22 @@ for m = 1:NumModels,
 
   a = fgetl(fid);
   a = regexprep(a,'[a-z,A-Z]','');
-  GroupData(m).NumBasepairs = str2num(a);  
+  GroupData(m).NumBasepairs = str2num(a);
   a = fgetl(fid);
   a = regexprep(a,'[a-z,A-Z]','');
-  GroupData(m).NumStacks = str2num(a);  
+  GroupData(m).NumStacks = str2num(a);
   a = fgetl(fid);
   a = regexprep(a,' base-phosphate','');
-  GroupData(m).NumBPh = str2num(a);  
+  GroupData(m).NumBPh = str2num(a);
   a = fgetl(fid);
   a = regexprep(a,' base-ribose','');
-  GroupData(m).NumBR = str2num(a);  
+  GroupData(m).NumBR = str2num(a);
   a = fgetl(fid);
   a = regexprep(a,'[a-z,A-Z]','');
-  GroupData(m).NumInstances = str2num(a);  
+  GroupData(m).NumInstances = str2num(a);
   a = fgetl(fid);
   a = regexprep(a,'[a-z,A-Z]','');
-  GroupData(m).Truncate = str2num(a);  
+  GroupData(m).Truncate = str2num(a);
 
   fclose(fid);
 
@@ -139,7 +149,7 @@ for m = 1:NumModels,
   end
   fclose(fid);
 
-  if  GroupData(m).NumBPh > 0 || GroupData(m).NumBR > 0,  
+  if  GroupData(m).NumBPh > 0 || GroupData(m).NumBR > 0,
     Structured(m) = 1;
     GroupData(m).Structured = 1;
   elseif GroupData(m).NumBasepairs > 2 && strcmp(loopType,'IL'),
diff --git a/matlab/pIndividualGroupCutoffScore.m b/matlab/pIndividualGroupCutoffScore.m
new file mode 100644
index 0000000..9e3e2f9
--- /dev/null
+++ b/matlab/pIndividualGroupCutoffScore.m
@@ -0,0 +1,39 @@
+% pIndividualGroupDiagnostic goes through each sequence,
+% looks up the correct group and its cutoff score,
+% sees if the sequence meets the cutoff score of its own group,
+% and counts the number of other groups with a better score
+
+function [NumBetterScore] = pIndividualGroupCutoffScore(GroupData,OnlyStructured,OwnMotif,Score,FASTA)
+
+if OnlyStructured == 1
+  str = find((cat(1,GroupData.Structured) == 1));  % structured internal loops
+else
+  str = 1:length(GroupData);
+end
+
+NumBetterScore = zeros(1,length(OwnMotif));
+
+NumDontMatchOwnGroup = 0;
+
+for n = 1:length(OwnMotif)                  % loop through sequences
+  g = OwnMotif(n);                          % group that this sequence belongs to
+
+  if Score(n,g,1) <= 0
+    fprintf('Sequence %4d in group %s has cutoff score %10.4f; %s\n', n, GroupData(g).MotifID, Score(n,g,1), FASTA(n).Sequence);
+    NumDontMatchOwnGroup = NumDontMatchOwnGroup + 1;
+  end
+
+  if OnlyStructured == 0 || GroupData(g).Structured > 0
+    m = max(Score(n,:,:),[],3);             % maximum over all rotations of score against each group
+    GroupsWithBetterCutoff = find((m(str) > Score(n,g,1)) .* (m(str) > 0) );
+    NumBetterScore(n) = length(GroupsWithBetterCutoff);
+    if NumBetterScore(n) > 0
+      for k = GroupsWithBetterCutoff        % loop through pointers to groups with better score
+        fprintf('Sequence %4d in group %s with cutoff score %10.4f does better against group %s cutoff score %10.4f; %s\n', n, GroupData(g).MotifID, Score(n,g,1), GroupData(str(k)).MotifID, m(str(k)), FASTA(n).Sequence);
+      end
+    end
+  else
+    NumBetterScore(n) = -1;                 % not structured
+  end
+end
+
diff --git a/matlab/pIndividualGroupDiagnostic.m b/matlab/pIndividualGroupDiagnostic.m
index 900da92..69b2a26 100644
--- a/matlab/pIndividualGroupDiagnostic.m
+++ b/matlab/pIndividualGroupDiagnostic.m
@@ -1,18 +1,26 @@
-% pIndividualGroupDiagnostic goes through each sequence, looks up the correct group and its score, and counts the number of other groups with a better score
+% pIndividualGroupDiagnostic goes through each sequence,
+% looks up the correct group and its score,
+% and counts the number of other groups with a better score
 
 function [NumBetterScore] = pIndividualGroupDiagnostic(GroupData,OnlyStructured,OwnMotif,Score)
 
-if OnlyStructured == 1,
+if OnlyStructured == 1
   str = find((cat(1,GroupData.Structured) == 1));  % structured internal loops
 else
   str = 1:length(GroupData);
 end
 
-for n = 1:length(OwnMotif),                     % loop through sequences
-  g = OwnMotif(n);
-  if OnlyStructured == 0 || GroupData(g).Structured > 0,
-    m = max(Score(n,:,:),[],3);                 % maximum over rotations, if any
+for n = 1:length(OwnMotif)                  % loop through sequences
+  g = OwnMotif(n);                          % group that this sequence belongs to
+  if OnlyStructured == 0 || GroupData(g).Structured > 0
+    m = max(Score(n,:,:),[],3);             % maximum over all rotations of score against each group
     NumBetterScore(n) = length(find(m(str) > Score(n,g,1)));
+    if NumBetterScore(n) > 0
+
+      for k = find(m(str) > Score(n,g,1))    % loop through groups with better score
+        fprintf('Sequence %d in group %s with score %10.6f does better against group %s score %10.6f\n', n, GroupData(g).MotifID, Score(n,g,1), GroupData(str(k)).MotifID, m(str(k)));
+      end
+    end
   else
     NumBetterScore(n) = -1;                 % not structured
   end
diff --git a/matlab/pIndividualGroupSequenceRundown.m b/matlab/pIndividualGroupSequenceRundown.m
index d661869..e10f486 100644
--- a/matlab/pIndividualGroupSequenceRundown.m
+++ b/matlab/pIndividualGroupSequenceRundown.m
@@ -1,4 +1,5 @@
-% pIndividualGroupSequenceRundown analyzes the alignment of individual sequences to probabilistic models and reports on the models that the sequence fits best
+% pIndividualGroupSequenceRundown analyzes the alignment of individual sequences to
+% probabilistic models and reports on the models that the sequence fits best
 
 % Copy Text into a spreadsheet, then sort by columns B, S, and U to get a nice ordering
 
@@ -13,6 +14,7 @@ Confusion = zeros(length(GroupData),length(GroupData)+1);   % to count mis-class
 Correctness.Criterion = Criterion;
 Correctness.NumSeqs   = length(FASTA);
 Correctness.TotalMultiplicity = sum(cat(1,FASTA.Multiplicity));
+Correctness.AcceptedSequences = 0;
 Correctness.AcceptedByMultiplicity = 0;
 Correctness.AcceptedByMultiplicityExclInteriorMatch = 0;
 Correctness.AcceptedByMultiplicityExclFullMatch = 0;
@@ -29,27 +31,29 @@ Correctness.MotifID = GroupData(OwnMotif(1)).MotifID;
 Correctness.NumBasepairs = GroupData(OwnMotif(1)).NumBasepairs;
 Correctness.NumBPh = GroupData(OwnMotif(1)).NumBPh;
 Correctness.MostCommonSequence = FASTA(1).Sequence;
+Correctness.NumInstances = GroupData(OwnMotif(1)).NumInstances;
 
-if nargin < 17,
+if nargin < 17
   Criterion = 3;
 end
 
-Score = 10000*(FullEditDistance == 0);  % full sequence matches always win
+Score = 10000*(FullEditDistance == 0);  % full sequence match overwhelms any other score
 
-switch Criterion,
-case 1,                                  % alignment score
+switch Criterion
+case 1                                  % alignment score
   Score = Score + MLPS;
-case 2,                                  % edit distance, ties broken by alignment score
+  Score = MLPS;                         % no credit for exact sequence matches
+case 2                                  % edit distance, ties broken by alignment score
   Score = Score - CoreEditDistance + MLPS/1000;
-case 3,                                  % plain edit distance, choose randomly
+case 3                                  % plain edit distance, choose randomly
   Score = Score - CoreEditDistance;
-case 4,                                  % average edit distance to known instances
+case 4                                  % average edit distance to known instances
   Score = Score + MLPS - CoreEditDistance;
-case 5,                                  % total probability
-  Score = Score + CutoffScore;             % temporarily not really total probabilty
-case 6,                                  % percentile score
+case 5
+  Score = Score + CutoffScore;          % cutoff score
+case 6                                  % percentile score
   Score = Score + Percentile + MLPS/1000000;    % use MLPS to break ties but not affect the decision more than that
-case 7,                                  % just check to see if the cutoff is met, don't really score by Score
+case 7                                  % just check to see if the cutoff is met, don't really score by Score
   Score = Score + MLPS;
 end
 
@@ -65,19 +69,19 @@ ROC(2,2) = 0;                              % avoid plotting problems
 
 NumBetterModelsToShow = 5;
 
-if Verbose == 1,
-  if OnlyStructured == 1,
+if Verbose == 1
+  if OnlyStructured == 1
     fprintf('Structured individual-group diagnostic\n');
   else
     fprintf('Individual-group diagnostic, all groups\n');
   end
-  fprintf('Listing groups by interaction signature\n');
+    fprintf('Listing groups by interaction signature\n');
 end
 
 %fprintf('Listing all sequences in all groups for which at least one sequence scores better against another model or has percentile worse than 0.2 against its own model\n');
 
-if OnlyStructured == 1,
-  str = find(cat(1,GroupData.Structured) == 1);  % structured internal loops
+if OnlyStructured == 1
+  str = find(cat(1,GroupData.Structured) == 1);  % structured loops
 else
   str = 1:length(GroupData);
 end
@@ -100,18 +104,18 @@ for gg = 1:length(grouporder),                 % run through sequence groups
 
   s = find(SeqGroup == g);                     % sequences in this group
 
-  if length(s) > 0,
+  if length(s) > 0
     mn = OwnMotif(s(1));                                % correct model number
 
     alignmentnumrows = 0;
     alignmentzeroedit = 0;
 
-    for k = 1:length(s),
+    for k = 1:length(s)
       n = s(k);
-      if OnlyStructured == 0 || GroupData(n).Structured > 0,
+      if OnlyStructured == 0 || GroupData(mn).Structured > 0
         alignmentnumrows = alignmentnumrows + FASTA(n).Multiplicity;
-        
-        if OwnCoreEditDistance(n) == 0,
+
+        if OwnCoreEditDistance(n) == 0
           alignmentzeroedit = alignmentzeroedit + FASTA(n).Multiplicity;
         end
       end
@@ -121,7 +125,7 @@ for gg = 1:length(grouporder),                 % run through sequence groups
 
     em = find(MotifEquivalence(mn,:) > 0);     % this model and all equivalent to it
 
-    if Verbose == 1,
+    if Verbose == 1
       fprintf('Group %3d is from %s which you can see at %s\n', g, GroupData(mn).MotifID, ['http://rna.bgsu.edu/rna3dhub/motif/view/' GroupData(mn).MotifID]);
 
       if GroupData(mn).Structured == 1,
@@ -143,12 +147,12 @@ for gg = 1:length(grouporder),                 % run through sequence groups
 
     % ------------------------------- order sequence matches approximately best to worst
 
-    if length(s) > 1,
+    if length(s) > 1
       clear OrderMatrix
-      for k = 1:length(s),
+      for k = 1:length(s)
         n = s(k);                                         % sequence number
         [m,r] = max(Score(n,:,:),[],3);                   % maximum over rotations
-        bettermodel = str(find(m(str) >= Score(n,mn,1))); % model numbers of better models
+        bettermodel = str(find(m(str) > Score(n,mn,1)));  % model numbers of strictly better models
         bettermodel = setdiff(bettermodel,mn);            % take out own model
 
         OrderMatrix(k,1) = length(bettermodel);
@@ -162,10 +166,10 @@ for gg = 1:length(grouporder),                 % run through sequence groups
 
     bestmodels = [];                                      % keep track for evaluation of voting as a classification technique
 
-    for k = 1:min(length(s),Params.NumSequencesToShow),   % loop through sequences
+    for k = 1:min(length(s),Params.NumSequencesToShow)    % loop through sequences
       n = s(k);                                           % sequence number
 
-      if UseMultiplicity > 0,
+      if UseMultiplicity > 0
         Counter = FASTA(n).Multiplicity;                  % use multiplicity of this variant
       else
         Counter = 1;                                      % simply count sequences
@@ -180,17 +184,18 @@ for gg = 1:length(grouporder),                 % run through sequence groups
 
       LocalScore = Score(n,:,:);
 
-      SL = length(strrep(FASTA(n).Sequence,'*',''));
+      % give a boost to exact sequence matches here
+      % SL = length(strrep(FASTA(n).Sequence,'*',''));
 
-      if SL >= CoreDistSL,
-        LocalScore = LocalScore + 1000*(CoreEditDistance(n,:,:) == 0);  % core sequence matches
-      end
+      % if SL >= CoreDistSL
+      %   LocalScore = LocalScore + 1000*(CoreEditDistance(n,:,:) == 0);  % core sequence matches
+      % end
 
       [m,r] = max(LocalScore,[],3);                       % maximum score over rotations
 
       OwnCutoffMet = max(CutoffMet(n,em,1));              % 1 if any cutoffs are met
 
-      if OwnCutoffMet > CutoffMet(n,mn,1) && Verbose == 1,
+      if OwnCutoffMet > CutoffMet(n,mn,1) && Verbose == 1
         fprintf('Equivalent motif meets cutoff but not original one\n');
       end
 
@@ -207,14 +212,14 @@ for gg = 1:length(grouporder),                 % run through sequence groups
       bettermodel = [];                         % keep track of better models
       equalmodel = [];
 
-      for w = 1:length(str),                    % loop through desired models
+      for w = 1:length(str)                     % loop through desired models
         cmn = str(w);                           % current model number
-        if cmn ~= mn,
-          if CutoffMet(n,cmn,r(cmn)) > 0,
-            if m(cmn) > OwnScore,                 % better score
+        if cmn ~= mn
+          if CutoffMet(n,cmn,r(cmn)) > 0        % only counting other models if the sequence meets their cutoff, which makes sense
+            if m(cmn) > OwnScore                % better score
               bettermodel = [bettermodel cmn];
             end
-            if m(cmn) == OwnScore && MotifEquivalence(mn,cmn) <= 0, % different model scores the same
+            if m(cmn) == OwnScore && MotifEquivalence(mn,cmn) <= 0  % different model scores the same
               equalmodel = [equalmodel cmn];
             end
           end
@@ -224,14 +229,14 @@ for gg = 1:length(grouporder),                 % run through sequence groups
       numbetter = length(bettermodel);
       numequal  = length(equalmodel);
 
-      if numbetter > 0,
+      if numbetter > 0
         [y,i] = sort(-m(bettermodel));                    % sort best to worst
         bettermodel = bettermodel(i);                     % re-order
       end
-      
-      if SizeOfGuessSet == 1,
-        if OwnCutoffMet > 0 && numbetter == 0,
-          if numequal > 0,
+
+      if SizeOfGuessSet == 1
+        if OwnCutoffMet > 0 && numbetter == 0
+          if numequal > 0
             Confusion(mn,mn) = Confusion(mn,mn) + 1/(1+numequal);  % tie
             Confusion(mn,equalmodel) = Confusion(mn,numequal) + 1/(1+numequal);
           else
@@ -247,7 +252,8 @@ for gg = 1:length(grouporder),                 % run through sequence groups
 
       score = 0;
 
-      if OwnCutoffMet > 0,
+      if OwnCutoffMet > 0
+        Correctness.AcceptedSequences = Correctness.AcceptedSequences + 1;
         Correctness.AcceptedByMultiplicity = Correctness.AcceptedByMultiplicity + FASTA(n).Multiplicity;
         if OwnCoreEditDistance(n) > 0,
           Correctness.AcceptedByMultiplicityExclInteriorMatch = Correctness.AcceptedByMultiplicityExclInteriorMatch + FASTA(n).Multiplicity;
@@ -285,7 +291,7 @@ for gg = 1:length(grouporder),                 % run through sequence groups
 
       maxscore = max(GroupData(mn).OwnScore);
 
-      if Verbose == 1,
+      if Verbose == 1
         fprintf('Better: %3d Equal: %3d ',numbetter,numequal);
         fprintf('Score %4.2f', score);
         fprintf(' %20s', FASTA(n).Sequence);
@@ -308,10 +314,13 @@ for gg = 1:length(grouporder),                 % run through sequence groups
         li = strfind(FASTA(n).Header,loopType);
         sp = strfind(FASTA(n).Header,' ');
 
-        Text{seqnum} = [Text{seqnum} FASTA(n).Header(li(2):(li(2)+9)) char(9)];
+        FASTA(n).Header
+
+        % trying to find a loop id? zzz  but it's not in the header
+        Text{seqnum} = [Text{seqnum} FASTA(n).Header(li(1):(li(1)+9)) char(9)];
         Text{seqnum} = [Text{seqnum} FASTA(n).Sequence char(9)];
 
-        Text{seqnum} = [Text{seqnum} 'http://rna.bgsu.edu/rna3dhub/motif/view/' GroupData(mn).MotifID char(9)];
+        Text{seqnum} = [Text{seqnum} 'https://rna.bgsu.edu/rna3dhub/motif/view/' GroupData(mn).MotifID char(9)];
         Text{seqnum} = [Text{seqnum} GroupData(mn).Signature{1} char(9)];
         Text{seqnum} = [Text{seqnum} sprintf('%0.2f', MLPS(n,mn,1)) char(9)];
         Text{seqnum} = [Text{seqnum} sprintf('%0.2f', 100*Percentile(n,mn,r(mn))) char(9)];
@@ -319,7 +328,7 @@ for gg = 1:length(grouporder),                 % run through sequence groups
 
         Text{seqnum} = [Text{seqnum} num2str(numbetter) char(9)];
 
-        if numbetter > 0,
+        if numbetter > 0
           fprintf(' scores better against %3d groups: ', numbetter);
           for b = 1:min(NumBetterModelsToShow,numbetter),
             bmn = bettermodel(b);
@@ -362,7 +371,7 @@ for gg = 1:length(grouporder),                 % run through sequence groups
       end
     end
 
-    if Verbose == 1 && length(bestmodels) > 0,
+    if 0 > 1 && Verbose == 1 && length(bestmodels) > 0,
       [b,t,i] = zUniqueRows(bestmodels');
       fprintf('\n');
       for k = 1:length(b),
@@ -373,11 +382,14 @@ for gg = 1:length(grouporder),                 % run through sequence groups
           end
         else
           fprintf('There was no match for                          %4d sequences (%4.1f%%)', t(k), 100*t(k)/sum(t));
-        end  
+        end
         fprintf('\n');
       end
       fprintf('\n');
     end
+
+
+
   end
 end
 
@@ -392,3 +404,5 @@ Correctness.PercentageCorrectExclInteriorMatch = Correctness.CorrectByMultiplici
 Correctness.PercentageAcceptedMultiplicity = Correctness.AcceptedByMultiplicity / Correctness.TotalMultiplicity;
 Correctness.PercentageAcceptedMultiplicityExclFullMatch = Correctness.AcceptedByMultiplicityExclFullMatch / Correctness.TotalMultiplicityExclFullMatch;
 Correctness.PercentageAcceptedMultiplicityExclInteriorMatch = Correctness.AcceptedByMultiplicityExclInteriorMatch / Correctness.TotalMultiplicityExclInteriorMatch;
+Correctness.OfAcceptedPercentageCorrectlyMatched = Correctness.CorrectSequences / Correctness.AcceptedSequences;
+Correctness.OfAcceptedPercentageCorrectlyMatchedMultiplicity = Correctness.CorrectByMultiplicity / Correctness.AcceptedByMultiplicity;
diff --git a/matlab/pJAR3DDiagnostics.m b/matlab/pJAR3DDiagnostics.m
index 5ef71dc..7c0fb9f 100644
--- a/matlab/pJAR3DDiagnostics.m
+++ b/matlab/pJAR3DDiagnostics.m
@@ -7,7 +7,7 @@
 
 function [void] = pJAR3DDiagnostics(OutputBase,Release,SequenceSource,DiagnosticMode)
 
-fprintf('Running JAR3D diagnostics on release %s\n',Release);
+fprintf('pJAR3DDiagnostics: Running JAR3D diagnostics on release %s\n',Release);
 
 if nargin < 4,
   DiagnosticMode = 1;
@@ -43,14 +43,9 @@ DiagnosticTestName = '';
 
 % ---------------------------------------- set directories
 
-Release = strrep(Release,'\',filesep);
-Release = strrep(Release,'/',filesep);
 OutputPath = [OutputBase filesep Release];
 
-SequenceSource = strrep(SequenceSource,'\',filesep);
-SequenceSource = strrep(SequenceSource,'/',filesep);
-
-if strcmp(Release,SequenceSource),
+if strcmp(Release,SequenceSource)
   UsingSequencesFromMotifGroups = 1;
   SequencePath = [OutputBase filesep SequenceSource filesep 'lib'];
 else
@@ -76,13 +71,14 @@ end
 
 loopType = Release(1:2);
 
-switch loopType,
-case 'JL'
-  Rotations = 3;                      % three rotations, for 3-way junctions
-case 'IL'
-  Rotations = 2;                      % two rotations are computed
-case 'HL'
-  Rotations = 1;                      % only one "rotation"
+switch loopType
+  case 'HL'
+    Rotations = 1;                      % only one "rotation"
+  case 'IL'
+    Rotations = 2;                      % two rotations are computed
+  otherwise
+    loopType
+    Rotations = str2num(strrep(loopType,'J',''));   % three rotations, for 3-way junctions
 end
 
 % ----------------------------------- set paths, make directories if needed
@@ -118,25 +114,16 @@ end
 
 % ----------------------------------------
 
-fs = 14;                                 % font size for figures
-tfs = 13;
+fs = 11;                                 % font size for figures
+tfs = 11;
 
 % ---------------------------------------- Read data from models
 
 [GroupData,MotifEquivalence] = pGetModelData(OutputPath,loopType);
 
-% ---------------------------------------------------------------------
-
-clear OwnPercentile
-clear SeqLength
-clear LeaveOneOut
-clear NumBetterScore
-clear OwnMLP
-clear OwnTotalProb
+% ------------------------------ Align 3D sequences against its own model and write out correspondences
 
-% ---------------------------------- Align 3D sequences against model and write out correspondences
-
-for g = 1:length(GroupData),
+for g = 1:length(GroupData)
   MotifName = GroupData(g).MotifID;
   FastaFile = [SequencePath filesep MotifName '.fasta'];
   DiagnosticFile = [DiagnosticPath filesep MotifName '_diagnostics.txt'];
@@ -153,17 +140,10 @@ for g = 1:length(GroupData),
   end
   fclose(fid);
 
+  % javaclasspath to see where Matlab looks for Java classes
+  % in my case,       Documents\GitHub\JAR3D\target\classes\edu\bgsu\rna\jar3d
+  % source code is in Documents\GitHub\JAR3D\src\main\java\edu\bgsu\rna\jar3d
   corresp = edu.bgsu.rna.jar3d.JAR3DMatlab.ModelCorrespondences(FastaFile,ModelPath,MotifName,0);
-  % ----------- The following lines prevent the program from being stopped
-  % ----------- by a crazy Matlab bug.  It is intermittent, but after a call
-  % ----------- to JAR3D, it is hell bent on saying
-  % ----------- "Dot name reference on non-scalar structure"
-  try
-    x = Temp.A + 1;
-    Temp.A
-  catch ME
-    Temp.B = 9876;
-  end
 
   corresp = char(corresp);
   correspcell = zStringSplit(corresp,char(10));
@@ -196,19 +176,19 @@ if UsingSequencesFromMotifGroups == 1,     % internal diagnostic
   end
   [FASTA, OwnMotif] = pConcatenateFASTASequences(SequencePath, SeqNames);
   SeqGroup = OwnMotif;                      % same concept here
-  for n = 1:length(FASTA),
+  for n = 1:length(FASTA)
     FASTA(n).Multiplicity = 1;
   end
 else
 %  SequencePath = [pwd filesep 'lib' filesep SequenceSource];
   DiagnosticBase = [pwd filesep Release filesep 'externaldiagnostic' filesep SequenceSource DiagnosticTestName];
   DiagnosticPath = [pwd filesep Release filesep 'externaldiagnostic' filesep SequenceSource DiagnosticTestName];
-  if ~(exist(DiagnosticPath) == 7),
+  if ~(exist(DiagnosticPath) == 7)
     mkdir(DiagnosticPath);
   end
 
 %  [FASTA, OwnMotif, SeqGroup, SeqNames] = pReadMSASequences(SequencePath,MotifNames);
-	fprintf('pJAR3DDiagnostics:  This option is no longer available\n');
+	fprintf('pJAR3DDiagnostics:  externaldiagnostic option is no longer available\n');
 
 end
 
@@ -247,73 +227,83 @@ fprintf('Overall maximum intragroup core edit distance is %2d\n', max1);
 NumSequences = length(FASTA);
 NumSeqGroups = max(SeqGroup);
 
-% --------------------- Add UU pairs to FASTA for diagnostic purposes
-
-if any(DiagnosticMode == [2 3 4]),
+if any(DiagnosticMode == [2 3 4])
+  % --------------------- Add UU pairs to FASTA for diagnostic purposes
   FASTA = pAddPairstoFASTAforDiagnostic(FASTA,NumSequences,DiagnosticMode);
 end
 
 % --------------------- Write sequences to one file for each rotation
 
-[AllSequencesFile] = pWriteSequencesWithRotations(ModelPath,FASTA,loopType,Rotations);
+% [AllSequencesFile] = pWriteSequencesWithRotations(ModelPath,FASTA,loopType,Rotations);
+[AllSequencesFile,rotatedFASTA] = pWriteSequencesWithRotations(DiagnosticPath,FASTA,loopType,Rotations,'internal_diagnostic');
 
-% ------------------------- Load parsing and edit distance data if necessary
+% ------------------------- Load parsing and edit distance data if available
 
 DataFile = [DiagnosticPath filesep 'ParsingData.mat'];
 
-if exist(DataFile,'file'),
+if exist(DataFile,'file')
 	load(DataFile)
 	fprintf('Loaded data file %s\n', DataFile);
 else
-  % ----------------------- Calculate edit distance between FASTA and 3D instances
+  % ----------------------- Calculate interior edit distance between FASTA and 3D instances
   clear CoreEditDistance
   clear AvgCoreEditDistance
 
-  fprintf('Finding core edit distance of %4d sequences against %4d models\n', NumSequences, length(GroupData));
-  for m = 1:length(GroupData),
-    ModelFASTA = zReadFASTA([ModelPath filesep GroupData(m).MotifID '.fasta']); % read sequences from *models*
-
-    [D1,D2,D3] = pEditDistance(FASTA,ModelFASTA,loopType,'core');
-    if strcmp(Release,SequenceSource),                % internal diagnostic
-%     i = find(OwnMotif == m);                        % seqs from current motif
-%     D2(i,:) = zMakeZeroInf(D2(i,:));                % ignore exact matches
-%     D3(i,:) = zMakeZeroInf(D3(i,:));                % ignore exact matches
-    end
-    CoreEditDistance(:,m,1) = min(D2,[],2);     % best match of core seq
-    AvgCoreEditDistance(:,m,1) = mean(D2,2);     % best match of core seq
-    if strcmp(loopType,'IL'),
-      CoreEditDistance(:,m,2) = min(D3,[],2);     % best match of core rev'd
-      AvgCoreEditDistance(:,m,2) = mean(D3,2);     % best match of core rev'd
-    end
-
-    if mod(m,50) == 0,
-      fprintf('Checked core edit distance for %4d models so far\n', m);
-    end
-  end
-
-  % ----------------------- Calculate edit distance between FASTA and 3D instances
+%   fprintf('Finding interior edit distance of %4d sequences against %4d models\n', NumSequences, length(GroupData));
+%   for m = 1:length(GroupData),
+%     ModelFASTA = zReadFASTA([ModelPath filesep GroupData(m).MotifID '.fasta']); % read sequences from *models*
+
+%     [D1,D2,D3] = pEditDistance(FASTA,ModelFASTA,loopType,'core');
+%     if strcmp(Release,SequenceSource),                % internal diagnostic
+% %     i = find(OwnMotif == m);                        % seqs from current motif
+% %     D2(i,:) = zMakeZeroInf(D2(i,:));                % ignore exact matches
+% %     D3(i,:) = zMakeZeroInf(D3(i,:));                % ignore exact matches
+%     end
+%     CoreEditDistance(:,m,1) = min(D2,[],2);     % best match of core seq
+%     AvgCoreEditDistance(:,m,1) = mean(D2,2);     % best match of core seq
+%     if strcmp(loopType,'IL')
+%       CoreEditDistance(:,m,2) = min(D3,[],2);     % best match of core rev'd
+%       AvgCoreEditDistance(:,m,2) = mean(D3,2);     % best match of core rev'd
+%     end
+
+%     if mod(m,40) == 0
+%       fprintf('Checked core edit distance for %4d models so far\n', m);
+%     end
+%   end
+
+  % ----------------------- Calculate full edit distance between FASTA and 3D instances
   clear FullEditDistance
   clear AvgFullEditDistance
 
-  fprintf('Finding full edit distance of %4d sequences against %4d models\n', length(FASTA), length(GroupData));
-  for m = 1:length(GroupData),
+  fprintf('Finding full and core edit distance of %4d sequences against %4d models\n', length(FASTA), length(GroupData));
+  for m = 1:length(GroupData)
     ModelFASTA = zReadFASTA([ModelPath filesep GroupData(m).MotifID '.fasta']);
 
-    [D1,D2,D3] = pEditDistance(FASTA,ModelFASTA,loopType,'full');
-    if strcmp(Release,SequenceSource),           % internal diagnostic
-%      i = find(OwnMotif == m);                        % seqs from current motif
-%      D2(i,:) = zMakeZeroInf(D2(i,:));                % ignore exact matches
-%      D3(i,:) = zMakeZeroInf(D3(i,:));                % ignore exact matches
-    end
-    FullEditDistance(:,m,1) = min(D2,[],2);     % best match of Full seq
-    AvgFullEditDistance(:,m,1) = mean(D2,2);     % best match of Full seq
-    if strcmp(loopType,'IL'),
-      FullEditDistance(:,m,2) = min(D3,[],2);     % best match of Full rev'd
-      AvgFullEditDistance(:,m,2) = mean(D3,2);     % best match of Full rev'd
+    for rotation = 1:length(rotatedFASTA)
+      D = pEditDistanceAll(rotatedFASTA{rotation},ModelFASTA,'core');
+      CoreEditDistance(:,m,rotation) = min(D,[],2);     % min over sequences in this motif group
+      AvgCoreEditDistance(:,m,rotation) = mean(D,2);     % best match of core seq
+
+      D = pEditDistanceAll(rotatedFASTA{rotation},ModelFASTA,'full');
+      FullEditDistance(:,m,rotation) = min(D,[],2);     % min over sequences in this motif group
+      AvgFullEditDistance(:,m,rotation) = mean(D,2);     % best match of core seq
     end
 
-    if mod(m,50) == 0,
-      fprintf('Checked full edit distance for %4d models so far\n', m);
+%     [D1,D2,D3] = pEditDistance(FASTA,ModelFASTA,loopType,'full');
+%     if strcmp(Release,SequenceSource),           % internal diagnostic
+% %      i = find(OwnMotif == m);                        % seqs from current motif
+% %      D2(i,:) = zMakeZeroInf(D2(i,:));                % ignore exact matches
+% %      D3(i,:) = zMakeZeroInf(D3(i,:));                % ignore exact matches
+%     end
+%     FullEditDistance(:,m,1) = min(D2,[],2);     % best match of Full seq
+%     AvgFullEditDistance(:,m,1) = mean(D2,2);     % best match of Full seq
+%     if strcmp(loopType,'IL'),
+%       FullEditDistance(:,m,2) = min(D3,[],2);     % best match of Full rev'd
+%       AvgFullEditDistance(:,m,2) = mean(D3,2);     % best match of Full rev'd
+%     end
+
+    if mod(m,40) == 0
+      fprintf('Checked edit distances for %4d models so far\n', m);
     end
   end
 
@@ -326,30 +316,31 @@ else
 	% MLPS(a,m,r) is the score of sequence a against model m using rotation r
 	% Percentile(a,m,r) is the percentile of sequence a against model m using r
 
-	Temp.A = 12;
-	Temp.B = 27;
-
-	fprintf('Parsing %4d sequences against %4d models\n', NumSequences, length(GroupData));
-	for m = 1:length(GroupData),
-	  quantileFile = [ModelPath filesep GroupData(m).MotifID '_distribution.txt'];
-	  for r = 1:Rotations,
-	    MN = [ModelPath filesep GroupData(m).MotifID '_model.txt'];
-	    S = edu.bgsu.rna.jar3d.JAR3DMatlab.MotifParseSingle(pwd,AllSequencesFile{r},MN);
-%	    T = edu.bgsu.rna.jar3d.JAR3DMatlab.MotifTotalProbSingle(pwd,AllSequencesFile{r},MN);
+	% Temp.A = 12;
+	% Temp.B = 27;
 
-      MixedScore = -(GroupData(m).DeficitCoeff * (max(GroupData(m).OwnScore) - S) + GroupData(m).CoreEditCoeff * CoreEditDistance(:,m,r));
+  MLPS = zeros(NumSequences,length(GroupData),Rotations);
 
-%	    Q = edu.bgsu.rna.jar3d.JAR3DMatlab.getQuantilesFromFile(MixedScore,quantileFile);
+	fprintf('Parsing %4d sequences against %4d models\n', NumSequences, length(GroupData));
+	for m = 1:length(GroupData)
+	  % quantileFile = [ModelPath filesep GroupData(m).MotifID '_distribution.txt'];
+	  for r = 1:Rotations
+      TotalProb(:,m,r) = zeros(1,NumSequences);     % total probability score for each sequence
+      Percentile(:,m,r) = zeros(1,NumSequences);    % percentile of this score
 
+      MN = [ModelPath filesep GroupData(m).MotifID '_model.txt'];
+	    S = edu.bgsu.rna.jar3d.JAR3DMatlab.MotifParseSingle(pwd,AllSequencesFile{r},MN);
 	    MLPS(:,m,r) = S;          % max log probability score for each sequence
-%	    TotalProb(:,m,r) = T;     % total probability score for each sequence
-%	    Percentile(:,m,r) = Q;    % percentile of this score
-      TotalProb(:,m,r) = zeros(size(S));     % total probability score for each sequence
-      Percentile(:,m,r) = zeros(size(S));    % percentile of this score
+
+      %	    T = edu.bgsu.rna.jar3d.JAR3DMatlab.MotifTotalProbSingle(pwd,AllSequencesFile{r},MN);
+      % MixedScore = -(GroupData(m).DeficitCoeff * (max(GroupData(m).OwnScore) - S) + GroupData(m).CoreEditCoeff * CoreEditDistance(:,m,r));
+      %	    TotalProb(:,m,r) = T;     % total probability score for each sequence
+      %	    Q = edu.bgsu.rna.jar3d.JAR3DMatlab.getQuantilesFromFile(MixedScore,quantileFile);
+      %	    Percentile(:,m,r) = Q;    % percentile of this score
 	  end
 
-	  if mod(m,50) == 0,
-	    fprintf('Parsed against %4d models so far\n', m);
+	  if mod(m,40) == 0
+	    fprintf('Parsed sequences from motif groups against %4d models so far\n', m);
 	  end
 	end
 
@@ -357,11 +348,11 @@ else
 	% ----------- by a crazy Matlab bug.  It is intermittent, but after a call
 	% ----------- to JAR3D, it is hell bent on saying
 	% ----------- "Dot name reference on non-scalar structure"
-	try
-	  Temp.A
-	catch ME
-	  Temp.B = 27;
-	end
+	% try
+	%   Temp.A
+	% catch ME
+	%   Temp.B = 27;
+	% end
 
   save(DataFile,'FASTA','MLPS','TotalProb','Percentile','CoreEditDistance','FullEditDistance','AvgCoreEditDistance','AvgFullEditDistance');
 
@@ -373,26 +364,47 @@ CutoffMet   = zeros(size(MLPS));
 CutoffScore = zeros(size(MLPS));
 Par = Params;
 Par.CutoffType = 3;
-for mm = 1:length(GroupData),
-  for r = 1:Rotations,
+
+size(MLPS)
+size(CoreEditDistance)
+size(Percentile)
+
+for mm = 1:length(GroupData)
+  for r = 1:Rotations
     Features = [MLPS(:,mm,r) CoreEditDistance(:,mm,r) Percentile(:,mm,r)];
-    [CutoffMet(:,mm,r) CutoffScore(:,mm,r)] = pModelSpecificCutoff(GroupData(mm),Features,Par);
+    [CutoffMet(:,mm,r), CutoffScore(:,mm,r)] = pModelSpecificCutoff(GroupData(mm),Features,Par);
   end
 end
 
 % --------------------- Determine sequence length, excess length, percentile
 
-clear GroupSize
+% clear GroupSize
+GroupSize = zeros(1,max(SeqGroup));
 
-for g = 1:max(SeqGroup),
+for g = 1:max(SeqGroup)
   j = find(SeqGroup == g);
   GroupSize(g) = length(j);           % number of sequences in this group
 end
 
-clear ExcessSeqLength
-clear SeqLength
-
-for s = 1:NumSequences,
+% clear ExcessSeqLength
+% clear SeqLength
+% clear OwnPercentile
+% clear SeqLength
+% clear LeaveOneOut
+% clear NumBetterScore
+% clear OwnMLP
+% clear OwnTotalProb
+
+SeqLength = zeros(1,NumSequences);
+ExcessSeqLength = zeros(1,NumSequences);
+OwnPercentile = zeros(1,NumSequences);
+OwnMLP = zeros(1,NumSequences);
+OwnTotalProb = zeros(1,NumSequences);
+OwnEditDistance = zeros(1,NumSequences);
+OwnCutoffScore = zeros(1,NumSequences);
+OwnDeficit = zeros(1,NumSequences);
+
+for s = 1:NumSequences
   SeqLength(s) = length(FASTA(s).Sequence)-Rotations+1; % HL, R=1, IL, R=2, etc.
 
   g = OwnMotif(s);
@@ -403,7 +415,7 @@ for s = 1:NumSequences,
   OwnCutoffScore(s) = CutoffScore(s,g,1);
 end
 
-for s = 1:NumSequences,
+for s = 1:NumSequences
   j = find(OwnMotif == OwnMotif(s));     % sequences from the same group
   ExcessSeqLength(s) = SeqLength(s) - mode(SeqLength(j));
   OwnDeficit(s) = max(OwnMLP(j)) - OwnMLP(s);
@@ -485,15 +497,17 @@ cc = cc(OwnMotif);
 pHistogramNumBetterScoreIndividual(NBS,cc,T,fs);
 ylabel('Colored by core basepairs per nucleotide','fontsize',fs)
 
-% --------------------------------------- Individual sequence details
-% This can be run after the individual-group or structured individual-group diagnostic
+% --------------------------------------- Individual sequence rundown
 
 LogFile = [DiagnosticPath filesep 'log ' date '.txt'];
 delete(LogFile);
 clc
 diary(LogFile);
 
-Text = pIndividualGroupSequenceRundown(Params,OnlyStructured,OwnMotif,GroupData,MLPS,FASTA,ModelPath,SeqGroup,OwnEditDistance,CoreEditDistance,Percentile,3,Verbose,CutoffScore,FullEditDistance,AvgCoreEditDistance,CutoffMet,MotifEquivalence);
+Criterion = 3;  % core edit distance only
+Criterion = 5;  % cutoff score
+Criterion = 1;  % MLPS
+Text = pIndividualGroupSequenceRundown(Params,OnlyStructured,OwnMotif,GroupData,MLPS,FASTA,ModelPath,SeqGroup,OwnEditDistance,CoreEditDistance,Percentile,Criterion,Verbose,CutoffScore,FullEditDistance,AvgCoreEditDistance,CutoffMet,MotifEquivalence);
 
 % write Text to text file
 
@@ -504,6 +518,23 @@ for i = 1:length(Text),
 end
 fclose(fid);
 
+% ------------------------------- individual to group using cutoff score
+
+OnlyStructured = 0;
+
+NBCS = pIndividualGroupCutoffScore(GroupData,OnlyStructured,OwnMotif,CutoffScore,FASTA);
+
+figure(1)
+T = ['Individual-group cutoff score, ' num2str(NumSequences) ' sequences against ' num2str(length(GroupData)) ' models'];
+
+pHistogramNumBetterScoreIndividual(NBCS,abs(ExcessSeqLength),T,fs);
+ylabel('Colored by difference in sequence length','fontsize',fs);
+
+print(gcf,'-dpng',[DiagnosticPath filesep 'Individual_Group_Cutoff_Score' DM{DiagnosticMode} '.png']);
+
+% ---------------------------------------------------------------------
+
+
 diary off
 
 % ------------------------------- Use multiple sequences from each group
diff --git a/matlab/pJAR3DFalsePositiveStudy.m b/matlab/pJAR3DFalsePositiveStudy.m
index d4cb947..dcd61ac 100644
--- a/matlab/pJAR3DFalsePositiveStudy.m
+++ b/matlab/pJAR3DFalsePositiveStudy.m
@@ -3,14 +3,14 @@
 
 % This program accumulates a large amount of data that is useful for exploring the behavior of randomly-generated sequences
 
-function [void] = pJAR3DFalsePositiveStudy(OutputBase,Release,Mode,RandomSequenceMode)
+function [void] = pJAR3DFalsePositiveStudy(OutputBase,Release,Mode,RandomSequenceMode,numfiles)
 
-if nargin < 4,
-  RandomSequenceMode = 1;
+if nargin < 4
+  RandomSequenceMode = 3;
 end
 
 switch Mode
-case 1                            % parse and calculate edit distance, which is slow
+case 1                                    % parse and calculate edit distance, which is slow
   CoreDistSL = 0;                         % minimum sequence length to allow core edit distance matching
 
   Params.Verbose = 0;
@@ -34,7 +34,7 @@ case 1                            % parse and calculate edit distance, which is
   Params.CutoffType = 2;                 % use generic cutoffs
   Depth = Inf;                           % accumulate *all* sequences that meet cutoffs, not just the best ones!
 
-case 2                            % accumulate false positive data
+case 2                                   % accumulate false positive data
   CoreDistSL = 0;                         % minimum sequence length to allow core edit distance matching
 
   Params.Verbose = 0;
@@ -88,6 +88,11 @@ Release = strrep(Release,'\',filesep);
 OutputPath = [OutputBase filesep Release];
 DiagnosticPath = [OutputBase filesep Release filesep 'diagnostic'];
 
+% create path if it does not already exist
+if ~(exist(DiagnosticPath) == 7)
+  mkdir(DiagnosticPath);
+end
+
 MatchColor(1,:) = 0.6*ones(1,3);
 MatchColor(2,:) = 0.3*ones(1,3);
 MatchColor(3,:) = 0.0*ones(1,3);
@@ -98,15 +103,6 @@ clear SD
 SDCounter = 0;
 FPCounter = 0;
 
-Match = zeros(200,2,2);
-FullMatch = zeros(200,2);
-FullEditOne = zeros(200,2);
-CoreEditOne = zeros(200,2);
-CoreEditZero = zeros(200,2);
-CoreMatch = zeros(200,2);
-GoodMatch = zeros(200,2);
-TotalSequences = zeros(200,2);
-
 FPModelCounter = zeros(500,1);
 SequenceCounter = 0;
 
@@ -126,60 +122,53 @@ Temp.B = 9876;                         % only used for error catching
 
 fs = 14;                                 % font size for figures
 tfs = 13;                                % font size for text
-MaxSeqLength = 30;                       % maximum total length to send to JAR3D
+MaxSeqLength = 30;                       % maximum total length to send to JAR3D; maybe not used
 
-if Mode > 2,
+if Mode > 2
   figure(1)
   clf
   figure(2)
   clf
 end
 
-switch loopType,
-case 'HL'
-  numfiles = 20;
-case 'IL'
-  numfiles = 20;
-end
-
 % --------------------------------- Determine number of rotations
 
-switch loopType,
-case 'JL'
-  Rotations = 3;                      % three rotations, for 3-way junctions
-case 'IL'
-  Rotations = 2;                      % two rotations are computed
-case 'HL'
-  Rotations = 1;                      % only one "rotation"
+switch loopType
+  case 'HL'
+    Rotations = 1;                      % only one "rotation"
+  case 'IL'
+    Rotations = 2;                      % two rotations are computed
+  otherwise
+    Rotations = str2num(strrep(loopType,'J',''));  % J3, J4, etc.
 end
 
-ModelPath = [pwd filesep Release filesep 'lib'];
+ModelPath = [OutputBase filesep Release filesep 'lib'];
 InteractionPath = ModelPath;
 
 % ---------------------------------------- Read data from models
 
 GroupData = pGetModelData(OutputPath,loopType);
 
-if Mode == 2,
-  for g = 1:length(GroupData),
+if Mode == 2
+  for g = 1:length(GroupData)
     GroupData(g).DeficitEditData = [];     % remove any existing data to make room for new
   end
 end
 
-if ~isfield(GroupData,'MinScore') && Params.CutoffType == 3,
+if ~isfield(GroupData,'MinScore') && Params.CutoffType == 3
   Params.CutoffType = 2;
   fprintf('Using generic cutoffs because model-specific cutoffs are not yet defined\n');
 end
 
-for i = 1:length(GroupData),
+for i = 1:length(GroupData)
   GroupMaxScore(1,i) = max(GroupData(i).OwnScore);
 end
 
 Depth = min(Depth,length(GroupData));
 
-% ---------------------------------------- Tally sequence data
+% ------------------------------- Tally sequence data from 3D ... seems to not be used
 
-for m = 1:length(GroupData),
+for m = 1:length(GroupData)
   SeqNames{m} = [GroupData(m).MotifID '.fasta'];
 end
 
@@ -188,72 +177,75 @@ end
 clear seqlengths
 clear nummodelsbylengths
 
-switch loopType,
-case 'HL'
-  for s = 1:length(FASTA),
-    seqlengths(s,1) = length(FASTA(s).Sequence);
-  end
-  [uniqueseqlengths,i,j] = unique(seqlengths,'rows');
-
-  maxlengths = max(seqlengths);
-  nummodelsbylengths(maxlengths(1)+3,1) = 0;    % make enough space
-
-  for k = 1:length(i),
-    a = uniqueseqlengths(k,1);
-    nummodelsbylengths(a,1) = length(unique(OwnMotif(find(j==k))));
-  end
-
-  newlengths = [];
-
-  for k = 1:length(uniqueseqlengths(:,1)),
-    newlengths(end+1,:) = uniqueseqlengths(k,:) + 1;
-  end
-
-  [uniqueseqlengths,i,j] = unique([uniqueseqlengths; newlengths],'rows');
-
-  T = [seqlengths OwnMotif];
-  T = sortrows(T,[1 2]);
-case 'IL'
-  for s = 1:length(FASTA),
-    i = strfind(FASTA(s).Sequence,'*');
-    j = length(FASTA(s).Sequence) - i;
-    seqlengths(s,1) = min(i-1,j);
-    seqlengths(s,2) = max(i-1,j);
-  end
-  [uniqueseqlengths,i,j] = unique(seqlengths,'rows');
-
-  maxlengths = max(seqlengths);
-  nummodelsbylengths(maxlengths(1)+3,maxlengths(2)+3) = 0;    % make enough space
-
-  for k = 1:length(i),
-    a = uniqueseqlengths(k,1);
-    b = uniqueseqlengths(k,2);
-    nummodelsbylengths(a,b) = length(unique(OwnMotif(find(j==k))));
-  end
-
-  newlengths = [];
-
-  for k = 1:length(uniqueseqlengths(:,1)),
-    if uniqueseqlengths(k,1) < uniqueseqlengths(k,2),
-      newlengths(end+1,:) = uniqueseqlengths(k,:) + [1 0];
-    end
-    newlengths(end+1,:) = uniqueseqlengths(k,:) + [0 1];
-    newlengths(end+1,:) = uniqueseqlengths(k,:) + [1 1];
-  end
-
-  [uniqueseqlengths,i,j] = unique([uniqueseqlengths; newlengths],'rows');
-
-  T = [seqlengths OwnMotif sum(seqlengths,2)];
-  T = sortrows(T,[1 2 3]);
-
-% sort by total length???
-%  T = sortrows(T,[4 1 2 3]);
-%  T = T(:,1:3);
-end
-
-for seqfilenumber = 1:numfiles,                           % loop through files of random sequences
-
-  SVN = [loopType '_FalsePositiveRateTest_' num2str(seqfilenumber) '.fasta'];   % randomly-generated sequences
+% switch loopType
+% case 'HL'
+%   for s = 1:length(FASTA)
+%     seqlengths(s,1) = length(FASTA(s).Sequence);
+%   end
+%   [uniqueseqlengths,i,j] = unique(seqlengths,'rows');
+
+%   maxlengths = max(seqlengths);
+%   nummodelsbylengths(maxlengths(1)+3,1) = 0;    % make enough space
+
+%   for k = 1:length(i)
+%     a = uniqueseqlengths(k,1);
+%     nummodelsbylengths(a,1) = length(unique(OwnMotif(find(j==k))));
+%   end
+
+%   newlengths = [];
+
+%   for k = 1:length(uniqueseqlengths(:,1))
+%     newlengths(end+1,:) = uniqueseqlengths(k,:) + 1;
+%   end
+
+%   [uniqueseqlengths,i,j] = unique([uniqueseqlengths; newlengths],'rows');
+
+%   T = [seqlengths OwnMotif];
+%   T = sortrows(T,[1 2]);
+% case 'IL'
+%   for s = 1:length(FASTA)
+%     i = strfind(FASTA(s).Sequence,'*');
+%     j = length(FASTA(s).Sequence) - i;
+%     seqlengths(s,1) = min(i-1,j);
+%     seqlengths(s,2) = max(i-1,j);
+%   end
+%   [uniqueseqlengths,i,j] = unique(seqlengths,'rows');
+
+%   maxlengths = max(seqlengths);
+%   nummodelsbylengths(maxlengths(1)+3,maxlengths(2)+3) = 0;    % make enough space
+
+%   for k = 1:length(i)
+%     a = uniqueseqlengths(k,1);
+%     b = uniqueseqlengths(k,2);
+%     nummodelsbylengths(a,b) = length(unique(OwnMotif(find(j==k))));
+%   end
+
+%   newlengths = [];
+
+%   for k = 1:length(uniqueseqlengths(:,1))
+%     if uniqueseqlengths(k,1) < uniqueseqlengths(k,2)
+%       newlengths(end+1,:) = uniqueseqlengths(k,:) + [1 0];
+%     end
+%     newlengths(end+1,:) = uniqueseqlengths(k,:) + [0 1];
+%     newlengths(end+1,:) = uniqueseqlengths(k,:) + [1 1];
+%   end
+
+%   [uniqueseqlengths,i,j] = unique([uniqueseqlengths; newlengths],'rows');
+
+%   T = [seqlengths OwnMotif sum(seqlengths,2)];
+%   T = sortrows(T,[1 2 3]);
+
+% % sort by total length???
+% %  T = sortrows(T,[4 1 2 3]);
+% %  T = T(:,1:3);
+% otherwise
+%   fprintf('pJAR3DFalsePositiveStudy: loopType %s not recognized\n', loopType);
+%   pause
+% end
+
+for seqfilenumber = 1:numfiles                           % loop through files of random sequences
+
+  % SVN = [loopType '_FalsePositiveRateTest_' num2str(seqfilenumber) '.fasta'];   % randomly-generated sequences
   SVN = [loopType '_RandomMotifSequences_' num2str(seqfilenumber) '.fasta'];   % randomly-generated sequences
 
   switch RandomSequenceMode
@@ -275,13 +267,13 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
   clear OwnTotalProb
   clear SeqNames
 
-  % --------------------------------- Read FASTA file
+  % --------------------------------- Read FASTA file of generated sequences
 
   CF = strrep(SVN,'.fasta','');
   TCF = strrep(CF,'_','\_');
   CF = strrep(CF,' ','_');
 
-  if Params.Verbose > 0,
+  if Params.Verbose > 0
 	  LogFile = [DiagnosticPath filesep CF '_log ' strrep(datestr(now),':','_') '.txt'];
 	  diary(LogFile);
 	end
@@ -290,11 +282,11 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
   StatusFile = [DiagnosticPath filesep CF '_being_analyzed.txt'];
   Skip = 0;
 
-  if exist(DataFile,'file'),
+  if exist(DataFile,'file')
     load(DataFile);
-    fprintf('Loaded data file %s\n',DataFile);
+    fprintf('Loaded false positive study data file %s\n',DataFile);
     FirstTime = 0;
-  elseif exist(StatusFile,'file') && Mode == 1,   % parsing random sequences, which is slow
+  elseif exist(StatusFile,'file') && Mode == 1   % another process is apparently working on this file
     Skip = 1;
   else
     FirstTime = 1;
@@ -305,87 +297,114 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
     fprintf('Read random sequence variant file %s\n', SVN);
   end
 
+  % --------------------- Write sequences to one file for each rotation
+
+  for n = 1:length(FASTA)
+    FASTA(n).MotifGroup = 'Randomly-generated';
+    FASTA(n).Locus = '';
+    FASTA(n).Multiplicity = 1;
+  end
+
   NumSequences = length(FASTA);
 
-  if Skip == 0 && (CalculateEditDistance > 0 || FirstTime > 0) && length(FASTA) > 0,
+  [AllSequencesFile,rotatedFASTA] = pWriteSequencesWithRotations(DiagnosticPath,FASTA,loopType,Rotations,CF);
 
-    for n = 1:length(FASTA),
-      FASTA(n).MotifGroup = 'Randomly-generated';
-      FASTA(n).Locus = '';
-      FASTA(n).Multiplicity = 1;
-    end
+  if Skip == 0 && (CalculateEditDistance > 0 || FirstTime > 0) && length(FASTA) > 0
 
-    SeqGroup = ones(NumSequences,1) * 0;
-    OwnMotif = ones(NumSequences,1) * 0;
+    % SeqGroup = ones(NumSequences,1) * 0;
+    % OwnMotif = ones(NumSequences,1) * 0;
 
     % ----------------------- Calculate edit distance between FASTA and 3D instances
-    clear CoreEditDistance
-    clear FullEditDistance
+    CoreEditDistance = Inf * ones(length(FASTA),length(GroupData),length(rotatedFASTA));
+    FullEditDistance = Inf * ones(length(FASTA),length(GroupData),length(rotatedFASTA));
+
+    disp(['pJAR3DFalsePositiveStudy Timestamp ' datestr(now)])
+    tic;
+    fprintf('Finding core edit distance of %4d sequences against %4d models over %4d rotations\n', NumSequences, length(GroupData), length(rotatedFASTA));
 
-    fprintf('Finding core edit distance of %4d sequences against %4d models\n', NumSequences, length(GroupData));
-    for m = 1:length(GroupData),
+    for m = 1:length(GroupData)
+      % get all sequences in this motif group
       ModelFASTA = zReadFASTA([ModelPath filesep GroupData(m).MotifID '.fasta']);
 
-      [D1,D2,D3] = pEditDistance(FASTA,ModelFASTA,loopType,'core');
+      for rotation = 1:length(rotatedFASTA)
+        D = pEditDistanceAll(rotatedFASTA{rotation},ModelFASTA,'core');
+        CoreEditDistance(:,m,rotation) = min(D,[],2);     % min over sequences in this motif group
 
-      CoreEditDistance(:,m,1) = min(D2,[],2);     % best match of core seq
-      if strcmp(loopType,'IL'),
-        CoreEditDistance(:,m,2) = min(D3,[],2);     % best match of core rev'd
+        D = pEditDistanceAll(rotatedFASTA{rotation},ModelFASTA,'full');
+        FullEditDistance(:,m,rotation) = min(D,[],2);     % min over sequences in this motif group
       end
-
-      if mod(m,50) == 0,
-        fprintf('Checked edit distance for %4d models so far\n', m);
+      if mod(m,40) == 0
+        fprintf('pJAR3DFalsePositiveStudy: Checked edit distances for %4d models so far, total time estimate %8.4f minutes\n', m, length(GroupData)*toc/(60*m));
       end
     end
 
-    if FindFullEditDistance > 0,
-      fprintf('\nFinding full edit distance of %4d sequences against %4d models\n', NumSequences, length(GroupData));
-      for m = 1:length(GroupData),
-        ModelFASTA = zReadFASTA([ModelPath filesep GroupData(m).MotifID '.fasta']);
-
-        [D1,D2,D3] = pEditDistance(FASTA,ModelFASTA,loopType,'full');
-
-        FullEditDistance(:,m,1) = min(D2,[],2);     % best match of full seq
-        if strcmp(loopType,'IL'),
-          FullEditDistance(:,m,2) = min(D3,[],2);     % best match of full rev'd
-        end
-
-        if mod(m,50) == 0,
-          fprintf('Checked edit distance for %4d models so far\n', m);
-        end
-      end
-    else
-      FullEditDistance = 99 * ones(size(CoreEditDistance));
-    end
+    % if strcmp(loopType,'HL') || strcmp(loopType,'IL')
+    %   for m = 1:length(GroupData)
+    %     ModelFASTA = zReadFASTA([ModelPath filesep GroupData(m).MotifID '.fasta']);
+
+    %     % D1 is best over all rotations, D2 for original, D3 for first rotation
+    %     [D1,D2,D3] = pEditDistance(FASTA,ModelFASTA,loopType,'core');
+
+    %     CoreEditDistance(:,m,1) = min(D2,[],2);     % best match of core seq
+    %     if strcmp(loopType,'IL')
+    %       CoreEditDistance(:,m,2) = min(D3,[],2);     % best match of core rev'd
+    %     end
+
+    %     if mod(m,100) == 0
+    %       fprintf('pJAR3DFalsePositiveStudy: Checked interior edit distance for %4d models so far, total time estimate %8.4f minutes\n', m, length(GroupData)*toc/(60*m));
+
+    %     end
+    %   end
+
+    %   if FindFullEditDistance > 0
+    %     tic;
+    %     fprintf('\nFinding full edit distance of %4d sequences against %4d models\n', NumSequences, length(GroupData));
+    %     for m = 1:length(GroupData)
+    %       ModelFASTA = zReadFASTA([ModelPath filesep GroupData(m).MotifID '.fasta']);
+
+    %       [D1,D2,D3] = pEditDistance(FASTA,ModelFASTA,loopType,'full');
+
+    %       FullEditDistance(:,m,1) = min(D2,[],2);     % best match of full seq
+    %       if strcmp(loopType,'IL')
+    %         FullEditDistance(:,m,2) = min(D3,[],2);     % best match of full rev'd
+    %       end
+
+    %       if mod(m,100) == 0
+    %         fprintf('pJAR3DFalsePositiveStudy: Checked full edit distance for %4d models so far, total time estimate %8.4f minutes\n', m, length(GroupData)*toc/(60*m));
+    %       end
+    %     end
+    %   else
+    %     FullEditDistance = 99 * ones(size(CoreEditDistance));
+    %   end
+    % end
   end
 
-	if Skip == 0 && (CalculateAlignments > 0 || FirstTime > 0) && length(FASTA) > 0,
+	if Skip == 0 && (CalculateAlignments > 0 || FirstTime > 0) && length(FASTA) > 0
     % OwnMotif maps from sequence to MotifName index
     % SeqGroup maps from sequence to 1:L, where L is the number of sequence groups
     %   Each different sequence group gets a different number
     % SeqNames maps from 1:L to a text string for the sequence group
 
-    % --------------------- Write sequences to one file for each rotation
-
-    [AllSequencesFile] = pWriteSequencesWithRotations(DiagnosticPath,FASTA,loopType,Rotations,CF);
+    disp(['pJAR3DFalsePositiveStudy Timestamp ' datestr(now)])
 
     % ----------------------- Parse all sequences against all models, all rotations
 
-    clear MLPS
-    clear TotalProb
-    clear Percentile
+    MLPS       = Inf * ones(length(FASTA),length(GroupData),length(rotatedFASTA));
+
+    % pre-allocating more just caused Matlab to freeze up, don't know why
+    % TotalProb  = zeros(length(FASTA),length(GroupData),length(rotatedFASTA));
+    % Percentile = zeros(length(FASTA),length(GroupData),length(rotatedFASTA));
 
     % MLPS(a,m,r) is the score of sequence a against model m using rotation r
     % Percentile(a,m,r) is the percentile of sequence a against model m using r
 
-    Temp.A = 12;
-    Temp.B = 27;
-
-    fprintf('Parsing %4d sequences against %4d models\n', NumSequences, length(GroupData));
-    for m = 1:length(GroupData),
-      quantileFile = [ModelPath filesep GroupData(m).MotifID '_distribution.txt'];
-      for r = 1:Rotations,
+    tic;
+    fprintf('Parsing %d sequences from file %s against %d models over %d rotations\n', NumSequences, SVN, length(GroupData), length(rotatedFASTA));
+    for m = 1:length(GroupData)
+      for r = 1:Rotations
+        % quantileFile = [ModelPath filesep GroupData(m).MotifID '_distribution.txt'];
         MN = [ModelPath filesep GroupData(m).MotifID '_model.txt'];
+
         S = edu.bgsu.rna.jar3d.JAR3DMatlab.MotifParseSingle(pwd,AllSequencesFile{r},MN);
         MLPS(:,m,r) = S;          % max log probability score for each sequence
 %          T = edu.bgsu.rna.jar3d.JAR3DMatlab.MotifTotalProbSingle(pwd,AllSequencesFile{r},MN);
@@ -393,56 +412,48 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
 %          Q = edu.bgsu.rna.jar3d.JAR3DMatlab.getQuantilesFromFile(MixedScore,quantileFile);
 %          TotalProb(:,m,r) = T;     % total probability score for each sequence
 %          Percentile(:,m,r) = Q;    % percentile of this score
-        TotalProb(:,m,r) = zeros(size(S));     % total probability score for each sequence
-        Percentile(:,m,r) = zeros(size(S));    % percentile of this score
+        % TotalProb(:,m,r) = zeros(size(S));     % total probability score for each sequence
+        % Percentile(:,m,r) = zeros(size(S));    % percentile of this score
       end
-
-      if mod(m,50) == 0,
-        fprintf('Parsed against %4d models so far\n', m);
+      if mod(m,50) == 0
+        fprintf('Parsed against %4d models so far, total time estimate %8.4f minutes\n', m, length(GroupData)*toc/(60*m));
       end
     end
-
-    % ----------- The following lines prevent the program from being stopped
-    % ----------- by a crazy Matlab bug.  It is intermittent, but after a call
-    % ----------- to JAR3D, it is hell bent on saying
-    % ----------- "Dot name reference on non-scalar structure"
-    try
-      Temp.A
-    catch ME
-      Temp.B = 27;
-    end
   end
 
   Marker = 2;
-  if Skip == 0 && (FirstTime > 0 || CalculateAlignments > 0 || CalculateEditDistance > 0) && length(FASTA) > 0,
-    save(DataFile,'FASTA','Marker','MLPS','TotalProb','Percentile','CoreEditDistance','FullEditDistance');
+  if Skip == 0 && (FirstTime > 0 || CalculateAlignments > 0 || CalculateEditDistance > 0) && length(FASTA) > 0
+    % save(DataFile,'FASTA','Marker','MLPS','TotalProb','Percentile','CoreEditDistance','FullEditDistance');
+    save(DataFile,'FASTA','Marker','MLPS','CoreEditDistance','FullEditDistance');
 
-    if exist(StatusFile) > 0,
+    if exist(StatusFile) > 0
       delete(StatusFile);
     end
-
   end
 
   NumSequences = length(FASTA);
 
-  if length(FASTA) > 0,
-    if Skip == 0 && Mode > 1,
+  if length(FASTA) > 0
+    if Skip == 0 && Mode > 1
+
+      disp(['pJAR3DFalsePositiveStudy Timestamp ' datestr(now)])
+      fprintf('Evaluating how sequences fit models\n');
 
       % --------------------- Evaluate whether each sequence meets the cutoff for each model
 
       CutoffMet = zeros(size(MLPS));
       CutoffScore = zeros(size(MLPS));
-      for mm = 1:length(GroupData),
-        for r = 1:Rotations,
+      for mm = 1:length(GroupData)
+        for r = 1:Rotations
           Features = [MLPS(:,mm,r) CoreEditDistance(:,mm,r)];
-          [CutoffMet(:,mm,r) CutoffScore(:,mm,r)] = pModelSpecificCutoff(GroupData(mm),Features,Params);
+          [CutoffMet(:,mm,r), CutoffScore(:,mm,r)] = pModelSpecificCutoff(GroupData(mm),Features,Params);
         end
       end
     end
 
-    if Skip == 0 && Mode == 2 && AccumulateRandomSequenceData > 0,
+    if Skip == 0 && Mode == 2 && AccumulateRandomSequenceData > 0
       MaxScore = zeros(size(MLPS));
-      for g = 1:length(GroupData),
+      for g = 1:length(GroupData)
         MaxScore(:,g,:) = max(GroupData(g).OwnScore);
       end
 
@@ -450,24 +461,23 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
 
       MixedScore = Deficit + 3*CoreEditDistance;
 
-      for g = 1:length(GroupData),
+      for g = 1:length(GroupData)
         [y,br] = min(MixedScore(:,g,:),[],3);      % find the rotation which minimizes the mixed score; this is the best rotation
-        for r = 1:Rotations,
+        for r = 1:Rotations
           i = find((br == r) .* (Deficit(:,g,r) <= Params.DeficitCutoff) .* (CoreEditDistance(:,g,r) <= Params.CoreEditCutoff));
           GroupData(g).DeficitEditData = [GroupData(g).DeficitEditData; [Deficit(i,g,r) CoreEditDistance(i,g,r)]];
         end
       end
     end
 
-
-    if Skip == 0 && Mode > 2,
+    if Skip == 0 && Mode > 2
       % --------------------- Evaluate whether each sequence meets the cutoff for each model
 
       GenericCutoffMet = zeros(size(MLPS));
       PP = Params;
       PP.CutoffType = 2;                              % generic cutoff, for comparison
-      for mm = 1:length(GroupData),
-        for r = 1:Rotations,
+      for mm = 1:length(GroupData)
+        for r = 1:Rotations
           Features = [MLPS(:,mm,r) CoreEditDistance(:,mm,r)];
           GenericCutoffMet(:,mm,r) = pModelSpecificCutoff(GroupData(mm),Features,PP);
         end
@@ -478,23 +488,35 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
       clear SeqLength
       clear StrandLengths
 
-      for s = 1:NumSequences,
+      SeqLength = zeros(NumSequences,1);
+      StrandLengths = zeros(NumSequences,Rotations+1);
+
+      for s = 1:NumSequences
         SeqLength(s) = length(FASTA(s).Sequence)-Rotations+1; % HL, R=1, IL, R=2, etc.
-        switch loopType,
-        case 'IL',
-          j = strfind(FASTA(s).Sequence,'*');
-          StrandLengths(s,:) = [length(FASTA(s).Sequence)-1 j-1 length(FASTA(s).Sequence)-j];
-        case 'HL',
-          StrandLengths(s,:) = [length(FASTA(s).Sequence) length(FASTA(s).Sequence) 1];
+
+        % StrandLengths is the total sequence length followed by individual strand lengths
+        s_parts = strsplit(FASTA(s).Sequence,'*');
+
+        StrandLengths(s,1) = SeqLength(s);
+        for k = 1:length(s_parts)
+          StrandLengths(s,k+1) = length(s_parts{k});
         end
+
+        % switch loopType
+        % case 'IL'
+        %   j = strfind(FASTA(s).Sequence,'*');
+        %   StrandLengths(s,:) = [length(FASTA(s).Sequence)-1 j-1 length(FASTA(s).Sequence)-j];
+        % case 'HL'
+        %   StrandLengths(s,:) = [length(FASTA(s).Sequence) length(FASTA(s).Sequence) 1];
+        % end
       end
 
       [y,i] = sort(SeqLength);
       SeqLength = SeqLength(i);
       FASTA = FASTA(i);
       MLPS = MLPS(i,:,:);
-      TotalProb = TotalProb(i,:,:);
-      Percentile = Percentile(i,:,:);
+      % TotalProb = TotalProb(i,:,:);
+      % Percentile = Percentile(i,:,:);
       CoreEditDistance = CoreEditDistance(i,:,:);
       FullEditDistance = FullEditDistance(i,:,:);
       CutoffMet = CutoffMet(i,:,:);
@@ -504,26 +526,48 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
       StrandLengths = StrandLengths(i,:);
 
       MaxScore = zeros(size(MLPS));
-      for g = 1:length(GroupData),
+      for g = 1:length(GroupData)
       	MaxScore(:,g,:) = max(GroupData(g).OwnScore);
       end
 
       Deficit = max(0,MaxScore - MLPS);          % some might be negative; better score than own model, a strange occurrence
 
       % ---------------------------------------- plot percentile versus deficit
-      % take the 10 best percentile scores and plot with their deficit,
+      % take the 10 best percentile scores and plot with their deficit
       % and also the 10 best deficit scores and plot with their percentile.
 
-      if PlotPercentileVersusDeficit > 0,
+      if PlotPercentileVersusDeficit > 0
 
         AllPercentiles = [];
         AllDeficits = [];
         AllCoreEdits = [];
         AllSeqLengths = [];
 
-        for s = 1:length(SeqLength),
-        	switch loopType,
-    			case 'IL'
+        for s = 1:length(SeqLength)
+        	switch loopType
+            case 'HL'
+             [y,i] = sort(Percentile(s,:,1),2,'descend');                % maximum over rotations, record which rotation
+             NewPercentiles = [Percentile(s,i(1:Depth),1)];
+             NewDeficits    = [Deficit(s,i(1:Depth),1)];
+             NewEdits       = [CoreEditDistance(s,i(1:Depth),1)];
+             [y,i] = sort(NewPercentiles,2,'descend');
+
+             AllPercentiles = [AllPercentiles NewPercentiles(i(1:Depth))];
+             AllDeficits    = [AllDeficits NewDeficits(i(1:Depth))];
+             AllCoreEdits   = [AllCoreEdits NewEdits(i(1:Depth))];
+             AllSeqLengths  = [AllSeqLengths ones(1,Depth)*SeqLength(s)];
+
+             [y,i] = sort(Deficit(s,:,1),2,'ascend');                % maximum over rotations, record which rotation
+             NewPercentiles = [Percentile(s,i(1:Depth),1)];
+             NewDeficits    = [Deficit(s,i(1:Depth),1)];
+             NewEdits       = [CoreEditDistance(s,i(1:Depth),1)];
+             [y,i] = sort(NewDeficits,2,'ascend');
+
+             AllPercentiles = [AllPercentiles NewPercentiles(i(1:Depth))];
+             AllDeficits    = [AllDeficits NewDeficits(i(1:Depth))];
+             AllCoreEdits   = [AllCoreEdits NewEdits(i(1:Depth))];
+             AllSeqLengths  = [AllSeqLengths ones(1,Depth)*SeqLength(s)];
+           case 'IL'
     			 	[y,i] = sort(Percentile(s,:,1),2,'descend');                % maximum over rotations, record which rotation
     	    	[z,j] = sort(Percentile(s,:,2),2,'descend');                % maximum over rotations, record which rotation
     			 	[y,i] = sort(MLPS(s,:,1),2,'descend');                % maximum over rotations, record which rotation
@@ -546,8 +590,8 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
 
             k = find((Percentile(s,:,1) > 0.5) + (Percentile(s,:,2) > 0.5) + (Deficit(s,:,1) < 50) + (Deficit(s,:,2) < 50) + (CoreEditDistance(s,:,1) <= 10) + (CoreEditDistance(s,:,2) <= 10));
 
-            if AccumulateSequenceData > 0,
-    		    	for d = 1:length(k),
+            if AccumulateSequenceData > 0
+    		    	for d = 1:length(k)
     		        SD.Percentile   = NewPercentiles(k(d));
     		        SD.Deficit      = NewDeficits(k(d));
     		        SD.CoreEdit     = NewEdits(k(d));
@@ -562,7 +606,7 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
     	%	        SD.LoopID       = '';
     		        SD.MotifID      = GroupData(ModelNumbers(k(1))).MotifID;
 
-    		        if mod(SDCounter,1000) == 0,
+    		        if mod(SDCounter,1000) == 0
     		          SequenceData(SDCounter + 1000) = SD;
     		        end
 
@@ -571,7 +615,7 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
     		      end
     		    end
 
-    	    	if 0 > 1,
+    	    	if 0 > 1
     		    	[y,i] = sort(Deficit(s,:,1),2,'ascend');                % maximum over rotations, record which rotation
     		    	[z,j] = sort(Deficit(s,:,2),2,'ascend');                % maximum over rotations, record which rotation
     		    	NewPercentiles = [Percentile(s,i(1:Depth),1) Percentile(s,j(1:Depth),2)];
@@ -584,33 +628,13 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
     		    	AllCoreEdits   = [AllCoreEdits NewEdits(i(1:Depth))];
     		    	AllSeqLengths  = [AllSeqLengths ones(1,Depth)*SeqLength(s)];
     		    end
-    	    case 'HL'
-    			 	[y,i] = sort(Percentile(s,:,1),2,'descend');                % maximum over rotations, record which rotation
-    	    	NewPercentiles = [Percentile(s,i(1:Depth),1)];
-    	    	NewDeficits    = [Deficit(s,i(1:Depth),1)];
-    	    	NewEdits       = [CoreEditDistance(s,i(1:Depth),1)];
-    	    	[y,i] = sort(NewPercentiles,2,'descend');
-
-    	    	AllPercentiles = [AllPercentiles NewPercentiles(i(1:Depth))];
-    	    	AllDeficits    = [AllDeficits NewDeficits(i(1:Depth))];
-    	    	AllCoreEdits   = [AllCoreEdits NewEdits(i(1:Depth))];
-    	    	AllSeqLengths  = [AllSeqLengths ones(1,Depth)*SeqLength(s)];
-
-    	    	[y,i] = sort(Deficit(s,:,1),2,'ascend');                % maximum over rotations, record which rotation
-    	    	NewPercentiles = [Percentile(s,i(1:Depth),1)];
-    	    	NewDeficits    = [Deficit(s,i(1:Depth),1)];
-    	    	NewEdits       = [CoreEditDistance(s,i(1:Depth),1)];
-    	    	[y,i] = sort(NewDeficits,2,'ascend');
-
-    	    	AllPercentiles = [AllPercentiles NewPercentiles(i(1:Depth))];
-    	    	AllDeficits    = [AllDeficits NewDeficits(i(1:Depth))];
-    	    	AllCoreEdits   = [AllCoreEdits NewEdits(i(1:Depth))];
-    	    	AllSeqLengths  = [AllSeqLengths ones(1,Depth)*SeqLength(s)];
+          otherwise
+            fprintf('pJAR3DFalsePositiveStudy: loopType %s not recognized\n', loopType);
     	    end
         end
 
-        if 0 > 1,
-    	    for j = unique(SeqLength),
+        if 0 > 1
+    	    for j = unique(SeqLength)
     		    k = find(AllSeqLengths == j);
     	%	    k = find((AllSeqLengths == j) .* (AllCoreEdits >= 2));
 
@@ -622,17 +646,17 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
     				xlabel('Alignment score deficit; colored by core edit distance, max 6');
     				ylabel('Percentile against models');
     				title(['Best ' num2str(Depth) ' scores for each random ' loopType ' sequence of length ' num2str(j)]);
-    				if seqfilenumber == 2,
+    				if seqfilenumber == 2
     					colorbar('eastoutside')
     				end
     			end
     		end
       end
 
-  		if 0 > 1,
+  		if 0 > 1
   		 	figure(10);
   		 	clf
-  	    for g = 1:length(GroupData),
+  	    for g = 1:length(GroupData)
   				scatter(Deficit(:,g,1),100*Percentile(:,g,1),4,min(FullEditDistance(:,g,1),1),'filled');
   				hold on
   				scatter(Deficit(:,g,2),100*Percentile(:,g,2),4,min(FullEditDistance(:,g,2),1),'filled');
@@ -645,23 +669,38 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
 
   		% --------------------------------------- sequence by sequence analysis
 
-  		if SequenceBySequence > 0,
+  		if SequenceBySequence > 0
   	    [b,i,j] = unique(StrandLengths,'rows');
-  	    [y,k] = sortrows(b,[1 2]);
-  	    [y,k] = sortrows(b,[2 3]);                        % sort by shorter strand length, then longer
+  	    % [y,k] = sortrows(b,[1 2]);
+  	    % [y,k] = sortrows(b,[2 3]);                        % sort by shorter strand length, then longer
         [s,t] = size(b);
         [y,k] = sortrows([b sum(b,2)],[t+1 1]);           % sort by decreasing total length
 
-  	    for w = 1:length(k),
-  	      LengthToPosition(y(w,2),y(w,3)) = w;
+        LengthsToPosition = containers.Map();       % code each set of strand lengths by a number
+        Match = zeros(length(k),2,2);
+        FullMatch = zeros(length(k),2);
+        FullEditOne = zeros(length(k),2);
+        CoreEditOne = zeros(length(k),2);
+        CoreEditZero = zeros(length(k),2);
+        CoreMatch = zeros(length(k),2);
+        GoodMatch = zeros(length(k),2);
+        TotalSequences = zeros(length(k),2);
+
+  	    for w = 1:length(k)
+          LengthsToPosition(mat2str(y(w,1:(Rotations+1)))) = w;
+          % fprintf('%s\n',mat2str(y(w,1:(Rotations+1))));
   	    end
   	    LengthPairs = y;
 
-  	    for n = 1:length(FASTA),
+  	    for n = 1:length(FASTA)
   	      SL = SeqLength(n);                                             % plain sequence length
-  	      sl = LengthToPosition(StrandLengths(n,2),StrandLengths(n,3));  % map strand lengths to position
+          % fprintf('%s\n',mat2str(StrandLengths(n,:)));
+  	      sl = LengthsToPosition(mat2str(StrandLengths(n,:)));  % map strand lengths to position
 
-  	      TotalSequences(sl,1) = TotalSequences(sl,1) + 1;    % count total number of sequences with this length
+          % StrandLengths(n,:)
+          % fprintf('sequence %s position %d\n', FASTA(n).Sequence,sl);
+
+  	      TotalSequences(sl,1) = TotalSequences(sl,1) + 1;    % count total number of sequences with these lengths
 
   	      [m,r] = min(CoreEditDistance(n,:,:),[],3);          % minimum over rotations and record which rotation
   	      [MinEditCore,mm] = min(m);                          % minimum over models and record which model
@@ -669,21 +708,33 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
 
   	      edindex = MinEditCore + 1;                          % to store the minimum edit distance
 
+          if edindex > size(TotalSequences,1)
+            % awkward but works
+            Match(edindex,2) = 0;
+            FullMatch(edindex,2) = 0;
+            FullEditOne(edindex,2) = 0;
+            CoreEditOne(edindex,2) = 0;
+            CoreEditZero(edindex,2) = 0;
+            CoreMatch(edindex,2) = 0;
+            GoodMatch(edindex,2) = 0;
+            TotalSequences(edindex,2) = 0;
+          end
+
   	      TotalSequences(edindex,2) = TotalSequences(edindex,2) + 1;    % count total number of sequences
 
-  	      if MinEditCore == 0,                                % exact core sequence match
+  	      if MinEditCore == 0                                 % exact core sequence match
   	        CoreMatch(sl,1) = CoreMatch(sl,1) + 1;
   	        CoreMatch(edindex,2) = CoreMatch(edindex,2) + 1;
   	        cmmm = mm;
   	        cmr = r;
   	      end
 
-          if MinEditCore == 0,                                % close to Core sequence match
+          if MinEditCore == 0                                 % close to Core sequence match
             CoreEditZero(sl,1) = CoreEditZero(sl,1) + 1;
             CoreEditZero(edindex,2) = CoreEditZero(edindex,2) + 1;
           end
 
-  	      if MinEditCore <= 1,                                % close to Core sequence match
+  	      if MinEditCore <= 1                                 % close to Core sequence match
   	        CoreEditOne(sl,1) = CoreEditOne(sl,1) + 1;
   	        CoreEditOne(edindex,2) = CoreEditOne(edindex,2) + 1;
   	      end
@@ -692,14 +743,14 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
   	      [MinEditFull,mm] = min(m);                          % minimum over models and record which model
   	      r = r(mm);                                          % optimal rotation at optimal model
 
-  	      if MinEditFull == 0,                                % exact full sequence match
+  	      if MinEditFull == 0                                 % exact full sequence match
   	        FullMatch(sl,1) = FullMatch(sl,1) + 1;
   	        FullMatch(edindex,2) = FullMatch(edindex,2) + 1;
   	        fmmm = mm;
   	        fmr = r;
   	      end
 
-  	      if MinEditFull <= 1,                                % close to full sequence match
+  	      if MinEditFull <= 1                                 % close to full sequence match
   	        FullEditOne(sl,1) = FullEditOne(sl,1) + 1;
   	        FullEditOne(edindex,2) = FullEditOne(edindex,2) + 1;
   	      end
@@ -709,15 +760,15 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
           mm = [];
           rm = [];
 
-          if MinEditFull == 0,
+          if MinEditFull == 0
           	mm = fmmm;
           	rm = fmr;
-          elseif MinEditCore == 0 && SL >= CoreDistSL,
+          elseif MinEditCore == 0 && SL >= CoreDistSL
           	mm = cmmm;
           	rm = cmr;
           end
 
-          if max(max(GenericCutoffMet(n,:,:))) > 0,
+          if max(max(GenericCutoffMet(n,:,:))) > 0
             Match(sl,1,2)      = Match(sl,1,2) + 1;                        % generic match
             Match(edindex,2,2) = Match(edindex,2,2) + 1;
           end
@@ -732,13 +783,13 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
           	cmn = ii(jj);                                                  % current model number
             [cut,r] = max(CutoffMet(n,cmn,:));                             % find rotation that meets the cutoff
 
-            if cut > 0,
+            if cut > 0
               mm = [mm cmn];
               [cut,r] = max(CutoffScore(n,cmn,:));                         % find rotation that maximizes the score
               rm = [rm r];
             end
 
-            if cut > MinimumCutoffScore,
+            if cut > MinimumCutoffScore
               gmm = [gmm cmn];
               [cut,r] = max(CutoffScore(n,cmn,:));                         % find rotation that maximizes the score
               grm = [grm r];
@@ -747,27 +798,27 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
             jj = jj + 1;
           end
 
-          if length(gmm) > 0,
+          if length(gmm) > 0
             GoodMatch(sl,1) = GoodMatch(sl,1) + 1;
             GoodMatch(edindex,2) = GoodMatch(edindex,2) + 1;
           end
 
-          if length(mm) > 0,
+          if length(mm) > 0
             Match(sl,1,1) = Match(sl,1,1) + 1;                    % match with current parameters
             Match(edindex,2,1) = Match(edindex,2,1) + 1;
 
             allmm = mm;
             allrm = rm;
 
-            for kk = 1:length(allmm),
+            for kk = 1:length(allmm)
             	mm = allmm(kk);
             	rm = allrm(kk);
 
-  		        if CoreEditDistance(n,mm,rm) > 0,
+  		        if CoreEditDistance(n,mm,rm) > 0
   			        FPModelCounter(mm) = FPModelCounter(mm) + 1;
   			      end
 
-  		        if AccumulateFPData > 0,
+  		        if AccumulateFPData > 0
   			        SD.Percentile   = Percentile(n,mm,rm);
   			        SD.Deficit      = max(GroupData(mm).OwnScore)-MLPS(n,mm,rm);
   			        SD.CoreEdit     = CoreEditDistance(n,mm,rm);
@@ -782,7 +833,7 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
   			        SD.Sequence     = FASTA(n).Sequence;
   			        SD.MotifID      = GroupData(mm).MotifID;
 
-  			        if mod(FPCounter,1000) == 0,
+  			        if mod(FPCounter,1000) == 0
   			          SD(FPCounter + 1000) = SD;
   			        end
 
@@ -794,7 +845,7 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
             mm = allmm(1);
             rm = allrm(1);
 
-            if Params.Verbose > 0,
+            if Params.Verbose > 0
   		        fprintf('%s', FASTA(n).Sequence);
               fprintf(' %d ', CutoffMet(n,mm,rm));
   	          fprintf(' Matches %2d; best is ',length(allmm));
@@ -802,7 +853,7 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
               fprintf(' %20s,',GroupData(mm).OwnSequence{1});
   	          fprintf('score %10.2f, ', MLPS(n,mm,rm));
   	          fprintf('deficit %5.2f, ', max(GroupData(mm).OwnScore)-MLPS(n,mm,rm));
-  	          fprintf('prct %6.2f%%, ', 100*Percentile(n,mm,rm));
+  	          % fprintf('prct %6.2f%%, ', 100*Percentile(n,mm,rm));
               fprintf('CutoffScore %6.2f, ', CutoffScore(n,mm,rm));
   	          fprintf('ed %2d,%2d ', FullEditDistance(n,mm,rm), CoreEditDistance(n,mm,rm));
   	          fprintf('%-40s', GroupData(mm).Signature{1});
@@ -810,17 +861,17 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
   	        end
 
           else
-          	if Params.Verbose > 0,
+          	if Params.Verbose > 0
   %		          fprintf(' Has no good match                                              ');
   	        end
           end
 
-  	      if Params.Verbose > 0,
+  	      if Params.Verbose > 0
   %		      fprintf('\n');
   		    end
   	    end
 
-  	    for v = 1:2,
+  	    for v = 1:2
   	      figure(v)
   	      clf
   	      FullMatchperc    = 100 * FullMatch(:,v) ./ TotalSequences(:,v);
@@ -832,7 +883,7 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
           Matchperc        = 100 * Match(:,v,1) ./ TotalSequences(:,v);
           GenericMatchperc = 100 * Match(:,v,2) ./ TotalSequences(:,v);
 
-  	      switch v,
+  	      switch v
   	      case 1
   	        range = 1:length(LengthPairs(:,1));
   	        index = 1:length(LengthPairs(:,1));
@@ -876,17 +927,17 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
 
   	      ylabel('Percentage','fontsize',tfs)
 
-  	      switch v,
+  	      switch v
   	      case 1
             title(['Acceptance rate of sequences in ' loopType '\_Rand by strand length'],'fontsize',tfs)
-  	        for w = 1:max(range),
-              switch loopType,
-              case 'HL'
-    	          text(w,-1,[sprintf('%d (%d)',nummodelsbylengths(LengthPairs(w,2)), LengthPairs(w,2))],'rotation',90,'horizontalalignment','right','FontName','FixedWidth','fontsize',6);
-              case 'IL'
-                text(w,-1,[num2str(nummodelsbylengths(LengthPairs(w,2),LengthPairs(w,3))) '(' num2str(LengthPairs(w,2)) ',' sprintf('%2d',LengthPairs(w,3)) ')'],'rotation',90,'horizontalalignment','right','FontName','FixedWidth','fontsize',6);
-              end
-  	        end
+  	        % for w = 1:max(range)
+            %   switch loopType
+            %   case 'HL'
+    	      %     text(w,-1,[sprintf('%d (%d)',nummodelsbylengths(LengthPairs(w,2)), LengthPairs(w,2))],'rotation',90,'horizontalalignment','right','FontName','FixedWidth','fontsize',6);
+            %   case 'IL'
+            %     text(w,-1,[num2str(nummodelsbylengths(LengthPairs(w,2),LengthPairs(w,3))) '(' num2str(LengthPairs(w,2)) ',' sprintf('%2d',LengthPairs(w,3)) ')'],'rotation',90,'horizontalalignment','right','FontName','FixedWidth','fontsize',6);
+            %   end
+  	        % end
   	        axis([0 max(range) 0 100.5])
   	        set(gca,'xtick',[])
   	%        xlabel('Sequence lengths')
@@ -894,7 +945,7 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
   	        print(gcf,'-dpdf',[DiagnosticPath filesep CF '_RandomSequenceMatchRate_sequence_length.pdf']);
   	      case 2
             title(['Acceptance rate of sequences in ' loopType '\_Rand by interior edit distance'],'fontsize',tfs)
-  	        for w = index,
+  	        for w = index
   	          text(range(w),10,num2str(TotalSequences(w,2)),'rotation',90,'horizontalalignment','right');
   	        end
   	        axis([0 25 0 100.1])
@@ -903,31 +954,46 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
   	        print(gcf,'-dpdf',[DiagnosticPath filesep CF '_RandomSequenceMatchRate_edit_distance.pdf']);
   	      end
 
-          switch loopType
-          case 'IL'
-            for a = 1:length(LengthToPosition(:,1)),
-              for b = a:length(LengthToPosition(1,:)),
-                sl = LengthToPosition(a,b);
-                if sl > 0 && v == 1,
-                  fprintf('%d\t%d\t%8.4f\t%8.4f\t%8.4f\t%d\n',a,b,Matchperc(sl),GoodMatchperc(sl),CoreEditZeroperc(sl),nummodelsbylengths(a,b));
-                  CEZRate(a,b) = CoreEditZeroperc(sl);
-                  GMRate(a,b) = GoodMatchperc(sl);
-                  MRate(a,b) = Matchperc(sl);
-                end
-              end
-            end
-          case 'HL'
-            for a = 1:length(LengthToPosition(:,1)),
-              sl = LengthToPosition(a,1);
-              if sl > 0 && v == 1,
-                fprintf('%d\t%8.4f\t%8.4f\t%8.4f\t%d\n',a,Matchperc(sl),GoodMatchperc(sl),CoreEditZeroperc(sl),nummodelsbylengths(a,1));
-              end
+          % loop over strand lengths
+          k = keys(LengthsToPosition);
+          fprintf('[total_length strand_lengths] Matchperc GoodMatchperc CoreEditZeroperc');
+          for i = 1:length(k)
+            sl = LengthsToPosition(k{i});
+            if sl > 0 && v == 1
+              fprintf('%s\t%8.4f\t%8.4f\t%8.4f\n',k{i},Matchperc(sl),GoodMatchperc(sl),CoreEditZeroperc(sl));
+              % fprintf('%d\t%8.4f\t%8.4f\t%8.4f\t%d\n',a,Matchperc(sl),GoodMatchperc(sl),CoreEditZeroperc(sl),nummodelsbylengths(a,1));
             end
           end
 
+          % switch loopType
+          % case 'IL'
+          %   for a = 1:length(LengthsToPosition(:,1))
+          %     for b = a:length(LengthsToPosition(1,:))
+          %       sl = LengthsToPosition(a,b);
+          %       if sl > 0 && v == 1
+          %         fprintf('%d\t%d\t%8.4f\t%8.4f\t%8.4f\n',a,b,Matchperc(sl),GoodMatchperc(sl),CoreEditZeroperc(sl));
+          %         % fprintf('%d\t%d\t%8.4f\t%8.4f\t%8.4f\t%d\n',a,b,Matchperc(sl),GoodMatchperc(sl),CoreEditZeroperc(sl),nummodelsbylengths(a,b));
+          %         CEZRate(a,b) = CoreEditZeroperc(sl);
+          %         GMRate(a,b) = GoodMatchperc(sl);
+          %         MRate(a,b) = Matchperc(sl);
+          %       end
+          %     end
+          %   end
+          % case 'HL'
+          %   % loop over strand lengths
+          %   k = keys(LengthsToPosition);
+          %   for i = 1:length(k)
+          %     sl = LengthsToPosition(k{i});
+          %     if sl > 0 && v == 1
+          %       fprintf('%s\t%8.4f\t%8.4f\t%8.4f\n',k{i},Matchperc(sl),GoodMatchperc(sl),CoreEditZeroperc(sl));
+          %       % fprintf('%d\t%8.4f\t%8.4f\t%8.4f\t%d\n',a,Matchperc(sl),GoodMatchperc(sl),CoreEditZeroperc(sl),nummodelsbylengths(a,1));
+          %     end
+          %   end
+          % end
+
           % grayscale heat map for IL
 
-          if strcmp(loopType,'IL'),
+          if 0>1 && strcmp(loopType,'IL')
             figure(v+2)
             clf
 
@@ -935,7 +1001,7 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
             map = colormap;
             map = 1-map;
 
-            if v == 1,
+            if v == 1
               subplot(2,2,1)
               pcolor(CEZRate);
               shading flat
@@ -956,7 +1022,7 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
               title('Percentage accepted by at least one motif group')
               subplot(2,2,4)
               [s,t] = size(MRate);
-              pcolor(nummodelsbylengths(1:s,1:t));
+              % pcolor(nummodelsbylengths(1:s,1:t));
               shading flat
               colormap(map);
               colorbar('eastoutside')
@@ -971,7 +1037,7 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
 	  end
 	end
 
-  if AccumulateFPData > 0,
+  if AccumulateFPData > 0
     FPData = FPData(1:FPCounter);
   % [DiagnosticPath filesep loopType '_Random_Sequence_Data.mat'],'SequenceData');
     save([OutputPath filesep loopType '_Random_Sequence_Data_FP_Only.mat'],'FPData');
@@ -980,10 +1046,10 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
 
 %  FPModelIDs = cat(1,FPData.MotifID);
 
-  if Mode > 2,
+  if Mode > 2
     FPModelCounter = FPModelCounter(1:length(GroupData));
     [y,i] = sort(FPModelCounter,1,'ascend');
-    for k = 1:length(i),
+    for k = 1:length(i)
       GD = GroupData(i(k));
       if isfield(GroupData,'TruePositiveRate')
     		fprintf('Model %-11s matched a sequence %3d times, TP %6.2f%%, TN %6.2f%%, %3d instances, signature %s, sequence %s\n', GD.MotifID,FPModelCounter(i(k)),100*GD.TruePositiveRate,100*GD.TrueNegativeRate,GD.NumInstances,GD.Signature{1},GD.OwnSequence{1});
@@ -1006,14 +1072,14 @@ for seqfilenumber = 1:numfiles,                           % loop through files o
   end
 end
 
-if Mode == 2 && AccumulateRandomSequenceData > 0,
+if Mode == 2 && AccumulateRandomSequenceData > 0
   save([OutputPath filesep loopType '_GroupData.mat'],'GroupData');
   fprintf('Saved group data\n');
   GroupData
 end
 
-if 0 > 1,
-	for j = unique(SeqLength),
+if 0 > 1
+	for j = unique(SeqLength)
 		figure(j);
 		print(gcf,'-dpng',[DiagnosticPath filesep loopType '_Percentile_Deficit_Top_' num2str(Depth) '_Scores_' num2str(j) '_NT.png']);
 		print(gcf,'-dpdf',[DiagnosticPath filesep loopType '_Percentile_Deficit_Top_' num2str(Depth) '_Scores_' num2str(j) '_NT.pdf']);
diff --git a/matlab/pJAR3DMaster.m b/matlab/pJAR3DMaster.m
index ab1af14..d4d57dc 100644
--- a/matlab/pJAR3DMaster.m
+++ b/matlab/pJAR3DMaster.m
@@ -2,43 +2,84 @@
 
 % -------------------------------------------------------------------- % choices for the user
 
-Input = ['HL_3.50_2021-10-13_17'];
-Release = ['HL' filesep '3.50'];
+% this is how inputs needed to be when the motif atlas was generated by Matlab
+Input = 'HL_3.48_2021-08-18_16';  % where the data comes from
+Release = ['HL' filesep '3.48'];    % where the output files go
 
-Input = ['IL_3.50_2021-10-13_14'];
-Release = ['IL' filesep '3.50'];
+Input = 'IL_3.48_2021-08-18_12';   % took about 6.5 hours to run
+Release = ['IL' filesep '3.48'];
 
-MotifLibraryLocation = 'C:\Users\zirbel\Documents\JAR3D\Motifs\';      % where to read results of clustering
-OutputBase = 'C:\Users\zirbel\Documents\JAR3D\';                       % where to write JAR3D models
+% this is how input needs to be when the motif atlas was generated by Python
+loop_type = 'J4';
+loop_type = 'HL';
+loop_type = 'IL';
+loop_type = 'J3';
+
+version = '3.48';
+version = '3.98';
+
+Input = [loop_type '_' version];
+Release = [loop_type filesep version];
+
+
+MotifLibraryLocation = 'C:\Users\zirbel\Documents\JAR3D\Motifs\';      % where to find the motif atlas release
+OutputBase = 'C:\Users\zirbel\Documents\JAR3D';                        % where to write JAR3D models
 MatlabCodepath = 'C:\Users\zirbel\Documents\GitHub\JAR3D\Matlab';      % location of Matlab code
 JAR3Dpath = 'C:\Users\zirbel\Documents\GitHub\JAR3D\target\classes';   % location of class files for Java programs; needed for scoring sequences
 Pythonpath = 'C:\Users\zirbel\Documents\GitHub\JAR3D\python';          % location of python programs in the JAR3D release
 
-% -------------------------------------------------------------------- % run JAR3D on the selected motif group
+% ------------- New code in 2025 to download the motif atlas release and create the necessary .mat files
+
+if ~exist([MotifLibraryLocation Input],'dir')
+	mkdir([MotifLibraryLocation Input])
+end
+MotifLibraryPath = [MotifLibraryLocation Input filesep 'mat'];
+if ~exist(MotifLibraryPath,'dir')
+	mkdir(MotifLibraryPath)
+end
+
+Filenames = dir(MotifLibraryPath);
+if length(Filenames) < 5
+	convert_motif_groups_to_matlab(MotifLibraryLocation,Input,loop_type,version,MotifLibraryPath)
+end
+
+% -------------------------------------------------------------------- % do not change the code below
+% run JAR3D on the selected motif group
 
 addpath(MatlabCodepath)
 javaaddpath(JAR3Dpath)
 
-MotifLibraryPath = [MotifLibraryLocation Input filesep 'mat'];
+if ~exist([OutputBase filesep Release],'dir')
+	mkdir([OutputBase filesep Release])
+end
+diary([OutputBase filesep Release filesep 'JAR3D log' strrep(char(datetime),':','-') '.txt'])
+disp(['Timestamp ' datestr(now)])
 
-diary([OutputBase Release filesep 'JAR3D log' strrep(char(datetime),':','-') '.txt'])
+% download the release from the RNA Motif Atlas website
+% add code here once we know whether .csv or .json or another format works best
+% https://rna.bgsu.edu/rna3dhub/motifs/release/hl/current/csv
+% https://rna.bgsu.edu/rna3dhub/motifs/release/hl/current/json
 
 pMakeSCFGModels(MotifLibraryPath,OutputBase,Release,1)
 
-pGenerateRandomMotifSequences(OutputBase,Release,3)    % document this
-pJAR3DFalsePositiveStudy(OutputBase,Release,3)  % 3 means to use model-specific cutoffs
-pSetModelSpecificCutoffs(OutputBase,Release,0)
+numfiles = pGenerateRandomMotifSequences(OutputBase,Release,1);
+numfiles = pGenerateRandomMotifSequences(OutputBase,Release,2);
+numfiles = pGenerateRandomMotifSequences(OutputBase,Release,3);
+
+pJAR3DFalsePositiveStudy(OutputBase,Release,1,3,numfiles)  % 1 means to read FASTA files and parse and calculate edit distance; slow
 
-pGenerateRandomMotifSequences(OutputBase,Release,1)    % document this
-pJAR3DFalsePositiveStudy(OutputBase,Release,1)  % 1 means to read FASTA files and parse and calculate edit distance; slow
+pJAR3DFalsePositiveStudy(OutputBase,Release,2,3,numfiles)  % 2 means to accumulate false positive data, which takes some RAM
+pSetModelSpecificCutoffs(OutputBase,Release,0)  % Use results from FalsePositiveStudy Mode 2
 
-pGenerateRandomMotifSequences(OutputBase,Release,2)    % document this
-pJAR3DFalsePositiveStudy(OutputBase,Release,2)  % 2 means to accumulate false positive data, which takes some RAM
+pJAR3DFalsePositiveStudy(OutputBase,Release,3,3,numfiles)  % 3 means to use model-specific cutoffs
 
 pJAR3DDiagnostics(OutputBase,Release,Release,1)
 
+% use Python to produce GroupToModelDiagnostic.html for each sequence against its group
 try
-	system(['python ' Pythonpath filesep 'GroupToModelDiagnostic.py ' OutputBase Release]);
+	system(['python ' Pythonpath filesep 'GroupToModelDiagnostic.py ' OutputBase filesep Release]);
 catch
 	fprintf('Not able to run the diagnostic in which sequences from 3D structures are aligned to their JAR3D models\n');
 end
+
+disp(['Timestamp ' datestr(now)])
diff --git a/matlab/pMakeMotifModelFromSSF.m b/matlab/pMakeMotifModelFromSSF.m
index 1680949..c82ebb5 100644
--- a/matlab/pMakeMotifModelFromSSF.m
+++ b/matlab/pMakeMotifModelFromSSF.m
@@ -10,247 +10,223 @@
 
 function [Node,Search] = pMakeMotifModelFromSSF(Search,Param,Prior,loopType,UseIndex)
 
-Normalize = 1;
-if length(Param) > 7
-    Normalize = Param(8);
-end
-
-if nargin < 2,
-    Param   = 0;
-    Verbose = 0;
-else
-    Verbose = Param(1);
-end
-
-if nargin <3,
-    Prior = [10000 10000 10000 10000 0];    % Extremely strong prior, makes for flat letter distribution
-end
-
-if nargin <4,
-    loopType = 'IL';              % Assume internal loops if type not specified
-end
-
-if nargin <5,
-    [seqNum,] = size(Search.Candidates);    % Use all instances
-    UseIndex = 1:seqNum;
-end
-
-while length(Prior) < 5,
-    Prior = [Prior 0];
-end
+  Normalize = 1;
+  if length(Param) > 7
+      Normalize = Param(8);
+  end
 
-% ----------------------------------- Load Search from filename, if applicable
+  if nargin < 2
+      Param   = 0;
+      Verbose = 0;
+  else
+      Verbose = Param(1);
+  end
 
-if strcmp(class(Search),'char'),
-  load(['MotifLibrary' filesep Search],'Search','-mat');
-end
+  if nargin < 3
+      Prior = [10000 10000 10000 10000 0];    % Strong prior on ACGU*, makes for flat letter distribution
+  end
 
-% ----------------------------------- Gather basic information about the search
+  if nargin < 4
+      loopType = 'IL';              % Assume internal loops if type not specified
+  end
 
-[L,N] = size(Search.Candidates);        % L = num instances; N = num NT
-N = N - 1;                              % number of nucleotides
+  if nargin < 5
+      [seqNum,] = size(Search.Candidates);    % Use all instances
+      UseIndex = 1:seqNum;
+  end
 
-f = Search.Candidates(:,N+1);           % file numbers of motifs
+  while length(Prior) < 5
+      Prior = [Prior 0];
+  end
 
-File = Search.File(f(1));                      % file of query motif
-NTNumber = double(Search.Candidates(1,1));     % index of first NT
-LastNTNumber = double(Search.Candidates(1,N)); % index of last NT
+  % ----------------------------------- Load Search from filename, if applicable
+  if strcmp(class(Search),'char')
+    load(['MotifLibrary' filesep Search],'Search','-mat');
+  end
 
-% ----- Display interactions in the first instance
+  % ----------------------------------- Gather basic information about the search
 
-if Verbose > 0,
-  i = Search.Candidates(1,1:N);            % indices of query motif, sometimes
-  fprintf('Interactions in the first instance:\n');
-  zShowInteractionTable(File,full(i));
-end
+  [L,N] = size(Search.Candidates);        % L = num instances; N = num NT
+  N = N - 1;                              % number of nucleotides
 
-% ----- Identify where the flanking pair is, to split up the two strands
-% ----- This should be replaced with Anton's variable in Search that
-% ----- identifies them
-% --------------------------------------- Find locations of truncations
+  f = Search.Candidates(:,N+1);           % file numbers of motifs
 
-[Edge,BPh,BR,Search] = pConsensusInteractions(Search,Verbose); 
-                                        % find consensus interactions
+  File = Search.File(f(1));                      % file of first instance
+  % NTNumber = double(Search.Candidates(1,1));     % index of first NT
+  % LastNTNumber = double(Search.Candidates(1,N)); % index of last NT
 
-F.Edge = Edge;                          % consensus pairs and stacks
-F.BasePhosphate = BPh;
-F.BaseRibose = BR;
+  if Verbose > 0
+    % ----- Display interactions in the first instance
+    i = Search.Candidates(1,1:N);            % indices of query motif, sometimes
+    fprintf('pMakeMotifModelFromSSF: Interactions in the first instance:\n');
+    zShowInteractionTable(File,full(i));
+  end
 
-Search.Edge = Edge;                     % save these to pass them back
-Search.BPh  = BPh;
-Search.BR   = BR;
+  % find consensus interactions
+  [Edge,BPh,BR,Search] = pConsensusInteractions(Search,Verbose);
 
-if sum(sum(BPh .* (1-eye(size(BPh))))) > 0 && Verbose > 0,
-  [i,j,k] = find(BPh);
-  for a = 1:length(i),
-    if i(a) ~= j(a) && Verbose > 0,
-      fprintf('pMakeMotifModelFromSSF: Conserved base-phosphate: %d %d %s\n', i(a), j(a), zBasePhosphateText(k(a)));
-    end
+  % check to be sure there are cWW pairs in the right places
+  % can occur because python fr3d and Matlab have different cWW cutoffs
+  if fix(abs(Edge(1,N))) ~= 1
+    Edge(1,N) = 1;
+    Edge(N,1) = 1;
   end
-end
-
-if sum(sum(BR .* (1-eye(size(BR))))) > 0 && Verbose > 0,
-  [i,j,k] = find(BR);
-  for a = 1:length(i),
-    if i(a) ~= j(a) && Verbose > 0,
-      fprintf('pMakeMotifModelFromSSF: Conserved base-ribose: %d %d %s\n', i(a), j(a), zBaseRiboseText(k(a)));
+  for k = 1:length(Search.Truncate)
+    t = Search.Truncate(k);
+    if fix(abs(Edge(t-1,t))) ~= 1
+      Edge(t-1,t) = 1;
+      Edge(t,t-1) = 1;
     end
   end
-end
 
-Search.Truncate = zFindTruncationLocation(loopType,F.Edge);
-Truncate = Search.Truncate;
+  F.Edge = Edge;                          % use consensus pairs and stacks
+  F.BasePhosphate = BPh;
+  F.BaseRibose = BR;
 
-if Verbose > 0,
-  fprintf('pMakeMotifModelFromSSF: Truncate = %4d\n', Truncate);
-end
-
-% ---------------------------------------- Extract a motif signature
-
-if strcmp(loopType,'HL')
-    strands = 1;
-else
-    strands = 2;
-end
+  Search.Edge = Edge;                     % save these to pass them back
+  Search.BPh  = BPh;
+  Search.BR   = BR;
 
-    if strcmp(loopType,'IL'),
-      [Signature,AllSig,AllPhonetic] = zMotifSignature(F.Edge,strands,1,1,Param);
-    else
-      [Signature,AllSig,AllPhonetic] = zMotifSignature(F.Edge,strands,1,2,Param);
-    end
-    if Verbose > 0,
-      fprintf('pMakeMotifModelFromSSF:  Signature: %s, Phoneme: %s\n', Signature, AllPhonetic{1});
+  if sum(sum(BPh .* (1-eye(size(BPh))))) > 0 && Verbose > 0
+    [i,j,k] = find(BPh);
+    for a = 1:length(i),
+      if i(a) ~= j(a) && Verbose > 0,
+        fprintf('pMakeMotifModelFromSSF: Conserved base-phosphate: %d %d %s\n', i(a), j(a), zBasePhosphateText(k(a)));
+      end
     end
+  end
 
-    Phonetic = AllPhonetic{1};
-
-    if strcmp(loopType,'IL'),
-        RSignature = AllSig{2};
-        RPhonetic = AllPhonetic{2};
-        if Verbose > 0,
-          fprintf('pMakeMotifModelFromSSF:  RSignature: %s\n', RSignature);
-        end
-    else
-        RSignature = Signature;
-        RPhonetic = Phonetic;
+  if sum(sum(BR .* (1-eye(size(BR))))) > 0 && Verbose > 0
+    [i,j,k] = find(BR);
+    for a = 1:length(i),
+      if i(a) ~= j(a) && Verbose > 0
+        fprintf('pMakeMotifModelFromSSF: Conserved base-ribose: %d %d %s\n', i(a), j(a), zBaseRiboseText(k(a)));
+      end
     end
+  end
 
-if 0 > 1,
-    Signature = 'trouble';
-    RSignature = 'trouble';
-    Phonetic = 'trouble';
-    RPhonetic = 'trouble';
-
-    fprintf('pMakeMotifModelFromSSF: problem making the signature\n');
-    full(min(30,abs(F.Edge)))
-end
-
-% ---------------------------------------- Save parameters to pass back
+  Truncate = Search.Truncate;
 
-Search.Signature  = Signature;
-Search.RSignature = RSignature;           %
-Search.Phonetic   = Phonetic;
-Search.RPhonetic  = RPhonetic;           %
+  if Verbose > 0
+    fprintf('pMakeMotifModelFromSSF: Truncate = %4d\n', Truncate);
+  end
 
-% -------------------------------- Make the model for the consensus structure
+  % ---------------------------------------- Extract a motif signature
 
-F.NT = File.NT(Search.Candidates(1,1:N));   % use the first candidate as model
-F.Crossing = zeros(N,N);                    % small enough, pretend none
-F.Range    = zeros(N,N);
-F.NumNT    = length(F.NT);
+  if strcmp(loopType,'HL')
+      strands = 1;
+  elseif strcmp(loopType,'IL')
+      strands = 2;
+  else
+      strands = str2double(strrep(loopType,'J',''));
+  end
 
-if length(Truncate) > 0,                    % at least two strands
-    b = 1:N;
-    for t = 1:N,
-        b(t) = b(t) + 100*sum(t >= Truncate);
+  % signature is only for illustration in output
+  if isfield(Search,'Signature')
+    Signature = Search.Signature;
+    RSignature = '';
+    Phonetic = '';
+    RPhonetic = '';
+  elseif strcmp(loopType,'IL')
+    [Signature,AllSig,AllPhonetic] = zMotifSignature(F.Edge,strands,1,1,Param);
+    Phonetic = AllPhonetic{1};
+    RSignature = AllSig{2};
+    RPhonetic = AllPhonetic{2};
+    if Verbose > 0
+      fprintf('pMakeMotifModelFromSSF:  RSignature: %s\n', RSignature);
     end
-    binv = 1:max(b);                                  % invert the spreading
-    binv(b) = 1:N;
-else
-    b = 1:N;
-    binv = 1:N;
-end
-
-FF.Filename      = File.Filename;
-FF.Edge(b,b)     = F.Edge;                        % spread the strands out
-FF.NT(b)         = F.NT;
-FF.Crossing(b,b) = F.Crossing;
-FF.Range(b,b)    = F.Range;
-FF.BasePhosphate(b,b) = F.BasePhosphate;
-FF.BaseRibose(b,b) = F.BaseRibose;
-
-if Verbose > 0,
-  disp('pMakeMotifModelFromSSF:  Consensus interaction table with nucleotides from the first candidate:');
-  zShowInteractionTable(FF,b);
-end
-
-Node = pMakeNodes(FF,Param,1,b(N),Truncate);          % make the SCFG/MRF model
-
-for n = 1:length(Node),
-  Node(n).LeftIndex    = binv(Node(n).LeftIndex);
-  Node(n).RightIndex   = binv(Node(n).RightIndex);
-  Node(n).MiddleIndex  = binv(Node(n).MiddleIndex);
-  Node(n).InterIndices = binv(Node(n).InterIndices);
-end
-
-if Verbose > 0,
-  for n = 1:length(Node),
-    fprintf('%d %s\n', n, Node(n).type);
+  elseif strcmp(loopType,'HL')
+    [Signature,AllSig,AllPhonetic] = zMotifSignature(F.Edge,strands,1,2,Param);
+    Phonetic = AllPhonetic{1};
+    RSignature = Signature;
+    RPhonetic = Phonetic;
   end
-end
 
-% -------------------------------------- Insert initial node after cluster
-
-m = 1;
-for n = 1:length(Node),
-  NNode(m) = Node(n);
-  NNode(m).nextnode = m+1;
-  if strcmp(Node(n).type,'Cluster'),
-    if ~strcmp(Node(n+1).type,'Initial'),
-      if Verbose > 0,
-        fprintf('pMakeMotifModelFromSSF:  Adding an Initial node after Cluster\n');
-      end
-      m = m + 1;
-      NNode(m).type       = 'Initial';
-      NNode(m).nextnode   = m+1;
-      NNode(m).LeftIndex  = max(NNode(m-1).LeftIndex)+1;
-      NNode(m).RightIndex = min(NNode(m-1).RightIndex)-1;
-      NNode(m).leftLengthDist = [0.9999 0.0001];
-      NNode(m).rightLengthDist = [0.9999 0.0001];
-      if Normalize == 1, 
-        NNode(m).leftLetterDist = [1 1 1 1]/4;
-        NNode(m).rightLetterDist = [1 1 1 1]/4;
-      else
-        NNode(m).leftLetterDist = [1 1 1 1];
-        NNode(m).rightLetterDist = [1 1 1 1];
-      end
-      NNode(m).Comment    = ' // New Initial node after Cluster';
+  % ---------------------------------------- Save parameters to pass back
+  Search.Signature  = Signature;
+  Search.RSignature = RSignature;
+  Search.Phonetic   = Phonetic;
+  Search.RPhonetic  = RPhonetic;
+
+  % -------------------------------- Make the model for the consensus structure
+
+  F.Filename = File.Filename;
+  F.NT = File.NT(Search.Candidates(1,1:N));   % use the first candidate as model
+  F.Crossing = zeros(N,N);                    % small enough, pretend none
+  F.Range    = zeros(N,N);
+  F.NumNT    = length(F.NT);
+
+  % modify indices in the file to keep the strands very separate
+  % we need to stop doing this.  Hopefully the changes for J3 also work for IL
+  % if 0>1 && length(Truncate) == 1                    % IL, exactly one strand break
+  %     bTruncate = [];                            % truncation points in new indexing
+  %     b = 1:N;
+  %     for t = 1:N
+  %         b(t) = b(t) + 100*sum(t >= Truncate);
+  %         if any(Truncate == t)              % first nucleotide of a new strand
+  %             bTruncate = [bTruncate b(t)];
+  %         end
+  %     end
+  %     binv = 1:max(b);                                  % invert the spreading
+  %     binv(b) = 1:N;
+  % else
+  %     b = 1:N;
+  %     binv = 1:N;
+  %     bTruncate = Truncate;
+  % end
+
+  % FF.Filename      = File.Filename;
+  % FF.Edge(b,b)     = F.Edge;                        % spread the strands out
+  % FF.NT(b)         = F.NT;
+  % FF.Crossing(b,b) = F.Crossing;
+  % FF.Range(b,b)    = F.Range;
+  % FF.BasePhosphate(b,b) = F.BasePhosphate;
+  % FF.BaseRibose(b,b) = F.BaseRibose;
+
+  % if Verbose > 0
+  %   disp('pMakeMotifModelFromSSF:  Consensus interaction table with nucleotides from the first candidate:');
+  %   zShowInteractionTable(FF,b);
+  % end
+
+  %
+  Node = pMakeNodes(F,Param,1,N,Truncate);          % make the SCFG/MRF model
+
+  % now the indexing in Edge is different from the numbers in Truncate, confusing
+  % Node = pMakeNodes(FF,Param,1,b(N),bTruncate);          % make the SCFG/MRF model
+
+  % convert back to original indexing, oh dear
+  % for n = 1:length(Node)
+  %   Node(n).LeftIndex    = binv(Node(n).LeftIndex);
+  %   Node(n).RightIndex   = binv(Node(n).RightIndex);
+  %   Node(n).MiddleIndex  = binv(Node(n).MiddleIndex);
+  %   Node(n).InterIndices = binv(Node(n).InterIndices);
+  % end
+
+  if Verbose >= 0
+    for n = 1:length(Node)
+      fprintf('pMakeMotifModelFromSSF:  %d %s\n', n, Node(n).type);
     end
   end
-  m = m + 1;
-end
-
-Node = NNode;
 
-if Verbose > 0,
-  for n = 1:length(Node),
-    fprintf('%d %s\n', n, Node(n).type);
-  end
-end
+  % Much of the code below re-numbers nodes after all nodes have been created.
+  % That messes up Junction nodes, which point to their child nodes.
+  % That is important for later code that tracks which element of the SCFG/MRF
+  % goes with each column of the output.  Better to remove
+  % the code here that re-numbers nodes after all have been created.
 
-% ---------------------------- Turn conserved insertion(s) after Basepair into Initial Node
+  Verbose = 1;
 
-m = 1;
-for n = 1:length(Node),
-  NNode(m) = Node(n);                 % store this node
-  NNode(m).nextnode = m+1;
-  if strcmp(Node(n).type,'Basepair'),
-    if ~strcmp(Node(n+1).type,'Initial'),
-      J = min(Node(n+1).LeftIndex) - Node(n).LeftIndex;
-      K = Node(n).RightIndex - max(Node(n+1).RightIndex);
-      if J > 1 || K > 1,              % conserved NT here
-        if Verbose > 0,
-          fprintf('pMakeMotifModelFromSSF:  Adding an Initial node after a Basepair\n');
+  % ---------------------------------- Insert initial node after cluster that may need it
+  m = 1;
+  for n = 1:length(Node)
+    NNode(m) = Node(n);
+    if ~strcmp(Node(n).type,'Junction')
+      NNode(m).nextnode = m+1;
+    end
+    if strcmp(Node(n).type,'Cluster')
+      if ~strcmp(Node(n+1).type,'Initial')
+        if Verbose > 0
+          fprintf('pMakeMotifModelFromSSF:  Adding an Initial node after Cluster\n');
         end
         m = m + 1;
         NNode(m).type       = 'Initial';
@@ -259,183 +235,240 @@ for n = 1:length(Node),
         NNode(m).RightIndex = min(NNode(m-1).RightIndex)-1;
         NNode(m).leftLengthDist = [0.9999 0.0001];
         NNode(m).rightLengthDist = [0.9999 0.0001];
-        if Normalize == 1,
-            NNode(m).leftLetterDist = [1 1 1 1]/4;
-            NNode(m).rightLetterDist = [1 1 1 1]/4;
+        if Normalize == 1
+          NNode(m).leftLetterDist = [1 1 1 1]/4;
+          NNode(m).rightLetterDist = [1 1 1 1]/4;
         else
-            NNode(m).leftLetterDist = [1 1 1 1];
-            NNode(m).rightLetterDist = [1 1 1 1];
+          NNode(m).leftLetterDist = [1 1 1 1];
+          NNode(m).rightLetterDist = [1 1 1 1];
         end
-        NNode(m).Comment         = ' // New Initial node after Basepair node';
+        NNode(m).Comment    = ' // New Initial node after Cluster';
       end
     end
+    m = m + 1;
   end
-  m = m + 1;
-end
 
-Node = NNode;
+  Node = NNode;
 
-if Verbose > 0,
-  for n = 1:length(Node),
-    fprintf('%d %s\n', n, Node(n).type);
+  if Verbose > 1
+    for n = 1:length(Node)
+      fprintf('%d %s\n', n, Node(n).type);
+    end
   end
-end
 
-% ------------------------------ Turn initial nodes with conserved bases into alternating Fixed and Initial with nothing
-
-m = 1;
-for n = 1:length(Node),
-  NNode(m) = Node(n);                 % store this node, keep it
-  NNode(m).nextnode = m+1;
-  if strcmp(Node(n).type,'Initial'),
-    J = min(Node(n+1).LeftIndex) - Node(n).LeftIndex;
-    if J > 0,                         % conserved NT here
-      for j = 1:J,                    % loop through fixed positions
-        if Verbose > 0,
-          fprintf('pMakeMotifModelFromSSF:  Replacing Initial with Fixed on the left\n');
-        end
-        m = m + 1;
-        NNode(m).type       = 'Fixed';
-        NNode(m).nextnode   = m+1;
-        NNode(m).LeftIndex  = max(NNode(m-1).LeftIndex);
-        NNode(m).RightIndex = min(NNode(m-1).RightIndex);
-        NNode(m).LeftLetter = '';
-        NNode(m).RightLetter= '';
-        NNode(m).Delete     = 0.001;
-        NNode(m).leftLengthDist = [0 1];
-        NNode(m).rightLengthDist = [1];
-        if Normalize == 1,
-            NNode(m).leftLetterDist = [1 1 1 1]/4;
-            NNode(m).rightLetterDist = [1 1 1 1]/4;
-        else
-            NNode(m).leftLetterDist = [1 1 1 1];
-            NNode(m).rightLetterDist = [1 1 1 1];
-        end
-        NNode(m).Comment    = [' // Fixed node on left'];
-        if Verbose > 0,
-          fprintf('pMakeMotifModelFromSSF:  Adding an Initial node after Fixed\n');
-        end
-        m = m + 1;
-        NNode(m).type       = 'Initial';
-        NNode(m).nextnode   = m+1;
-        NNode(m).LeftIndex  = max(NNode(m-1).LeftIndex)+1;
-        NNode(m).RightIndex = min(NNode(m-1).RightIndex);
-        NNode(m).leftLengthDist = [0.9999 0.0001];
-        NNode(m).rightLengthDist = [0.9999 0.0001];
-        if Normalize == 1,
-            NNode(m).leftLetterDist = [1 1 1 1]/4;
-            NNode(m).rightLetterDist = [1 1 1 1]/4;
-        else
-            NNode(m).leftLetterDist = [1 1 1 1];
-            NNode(m).rightLetterDist = [1 1 1 1];
+  % ---------------------------- Turn conserved insertion(s) after Basepair into Initial Node
+  m = 1;
+  for n = 1:length(Node)
+    NNode(m) = Node(n);                 % store this node
+    if ~strcmp(Node(n).type,'Junction')
+      NNode(m).nextnode = m+1;
+    end
+    if strcmp(Node(n).type,'Basepair')
+      if ~strcmp(Node(n+1).type,'Initial')
+
+        J = min(Node(n+1).LeftIndex) - Node(n).LeftIndex;
+        K = Node(n).RightIndex - max(Node(n+1).RightIndex);
+        if J > 1 || K > 1              % conserved NT here
+          if Verbose > 0
+            fprintf('pMakeMotifModelFromSSF:  Adding an Initial node after a Basepair\n');
+          end
+          m = m + 1;
+          NNode(m).type       = 'Initial';
+          NNode(m).nextnode   = m+1;
+          NNode(m).LeftIndex  = max(NNode(m-1).LeftIndex)+1;
+          NNode(m).RightIndex = min(NNode(m-1).RightIndex)-1;
+          NNode(m).leftLengthDist = [0.9999 0.0001];
+          NNode(m).rightLengthDist = [0.9999 0.0001];
+          if Normalize == 1
+              NNode(m).leftLetterDist = [1 1 1 1]/4;
+              NNode(m).rightLetterDist = [1 1 1 1]/4;
+          else
+              NNode(m).leftLetterDist = [1 1 1 1];
+              NNode(m).rightLetterDist = [1 1 1 1];
+          end
+          NNode(m).Comment         = ' // New Initial node after Basepair node';
         end
-        NNode(m).Comment         = ' // New Initial node after Fixed node';
       end
     end
-    K = Node(n).RightIndex - max(Node(n+1).RightIndex);
-    if K > 0,
-      for j = 1:K,                 % loop through fixed positions
-        if Verbose > 0,
-          fprintf('pMakeMotifModelFromSSF:  Replacing Initial with Fixed on the right\n');
-        end
-        m = m + 1;
-        NNode(m).type       = 'Fixed';
-        NNode(m).nextnode   = m+1;
-        NNode(m).LeftIndex  = max(NNode(m-1).LeftIndex);
-        NNode(m).RightIndex = min(NNode(m-1).RightIndex);
-        NNode(m).LeftLetter = '';
-        NNode(m).RightLetter= '';
-        NNode(m).Delete     = 0.001;
-        NNode(m).leftLengthDist  = [1];
-        NNode(m).rightLengthDist = [0 1];
-        if Normalize == 1,
-            NNode(m).leftLetterDist  = [1 1 1 1]/4;
-            NNode(m).rightLetterDist = [1 1 1 1]/4;
-        else
-            NNode(m).leftLetterDist  = [1 1 1 1];
-            NNode(m).rightLetterDist = [1 1 1 1];
-        end
-        NNode(m).Comment    = [' // Fixed node on right'];
-        if Verbose > 0,
-          fprintf('pMakeMotifModelFromSSF:  Adding an Initial node after Fixed\n');
+    m = m + 1;
+  end
+
+  Node = NNode;
+
+  if Verbose > 0
+    for n = 1:length(Node)
+      fprintf('%d %s\n', n, Node(n).type);
+    end
+  end
+
+  % ------------------------------ Turn initial nodes with conserved bases into alternating Fixed and Initial with nothing
+
+  m = 1;
+  for n = 1:length(Node)
+    NNode(m) = Node(n);                 % store this node, keep it
+    if ~strcmp(Node(n).type,'Junction')
+      NNode(m).nextnode = m+1;
+    end
+    if strcmp(Node(n).type,'Initial')
+      J = min(Node(n+1).LeftIndex) - Node(n).LeftIndex;
+      if J > 0                         % conserved NT here
+        for j = 1:J                    % loop through fixed positions
+          if Verbose > 0
+            fprintf('pMakeMotifModelFromSSF:  Replacing Initial with Fixed on the left for %s\n',File.NT(Node(n).LeftIndex+j-1).ID);
+          end
+          m = m + 1;
+
+          % fprintf('pMakeMotifModelFromSSF: LeftIndex %d RightIndex %d\n', max(NNode(m-1).LeftIndex), min(NNode(m-1).RightIndex));
+          if max(NNode(m-1).LeftIndex) > min(NNode(m-1).RightIndex)
+              fprintf('pMakeMotifModelFromSSF: Error: LeftIndex > RightIndex\n');
+              NNode(m-1)
+          end
+
+          NNode(m).type       = 'Fixed';
+          NNode(m).nextnode   = m+1;
+          NNode(m).LeftIndex  = max(NNode(m-1).LeftIndex);
+          NNode(m).RightIndex = min(NNode(m-1).RightIndex);
+          NNode(m).LeftLetter = '';
+          NNode(m).RightLetter= '';
+          NNode(m).Delete     = 0.001;
+          NNode(m).leftLengthDist = [0 1];
+          NNode(m).rightLengthDist = [1];
+          if Normalize == 1
+              NNode(m).leftLetterDist = [1 1 1 1]/4;
+              NNode(m).rightLetterDist = [1 1 1 1]/4;
+          else
+              NNode(m).leftLetterDist = [1 1 1 1];
+              NNode(m).rightLetterDist = [1 1 1 1];
+          end
+          NNode(m).Comment    = ' // Fixed node on left';
+          if Verbose > 0
+            fprintf('pMakeMotifModelFromSSF:  Adding an Initial node after Fixed\n');
+          end
+          m = m + 1;
+          NNode(m).type       = 'Initial';
+          NNode(m).nextnode   = m+1;
+          NNode(m).LeftIndex  = max(NNode(m-1).LeftIndex)+1;
+          NNode(m).RightIndex = min(NNode(m-1).RightIndex);
+          NNode(m).leftLengthDist = [0.9999 0.0001];
+          NNode(m).rightLengthDist = [0.9999 0.0001];
+          if Normalize == 1
+              NNode(m).leftLetterDist = [1 1 1 1]/4;
+              NNode(m).rightLetterDist = [1 1 1 1]/4;
+          else
+              NNode(m).leftLetterDist = [1 1 1 1];
+              NNode(m).rightLetterDist = [1 1 1 1];
+          end
+          NNode(m).Comment         = ' // New Initial node after Fixed node';
         end
-        m = m + 1;
-        NNode(m).type       = 'Initial';
-        NNode(m).nextnode   = m+1;
-        NNode(m).LeftIndex  = max(NNode(m-1).LeftIndex);
-        NNode(m).RightIndex = min(NNode(m-1).RightIndex)-1;
-        NNode(m).leftLengthDist  = [0.9999 0.0001];
-        NNode(m).rightLengthDist = [0.9999 0.0001];
-        if Normalize == 1,
-            NNode(m).leftLetterDist  = [1 1 1 1]/4;
-            NNode(m).rightLetterDist = [1 1 1 1]/4;
-        else
-            NNode(m).leftLetterDist  = [1 1 1 1];
-            NNode(m).rightLetterDist = [1 1 1 1];    
+      end
+      K = Node(n).RightIndex - max(Node(n+1).RightIndex);
+      if K > 0
+        for j = 1:K                 % loop through fixed positions
+          if Verbose > 0
+            fprintf('pMakeMotifModelFromSSF:  Replacing Initial with Fixed on the right for %s\n',File.NT(Node(n).RightIndex-j+1).ID);
+          end
+          m = m + 1;
+          NNode(m).type       = 'Fixed';
+          NNode(m).nextnode   = m+1;
+          NNode(m).LeftIndex  = max(NNode(m-1).LeftIndex);
+          NNode(m).RightIndex = min(NNode(m-1).RightIndex);
+          NNode(m).LeftLetter = '';
+          NNode(m).RightLetter= '';
+          NNode(m).Delete     = 0.001;
+          NNode(m).leftLengthDist  = [1];
+          NNode(m).rightLengthDist = [0 1];
+          if Normalize == 1
+              NNode(m).leftLetterDist  = [1 1 1 1]/4;
+              NNode(m).rightLetterDist = [1 1 1 1]/4;
+          else
+              NNode(m).leftLetterDist  = [1 1 1 1];
+              NNode(m).rightLetterDist = [1 1 1 1];
+          end
+          NNode(m).Comment    = ' // Fixed node on right';
+          if Verbose > 0
+            fprintf('pMakeMotifModelFromSSF:  Adding an Initial node after Fixed\n');
+          end
+          m = m + 1;
+          NNode(m).type       = 'Initial';
+          NNode(m).nextnode   = m+1;
+          NNode(m).LeftIndex  = max(NNode(m-1).LeftIndex);
+          NNode(m).RightIndex = min(NNode(m-1).RightIndex)-1;
+          NNode(m).leftLengthDist  = [0.9999 0.0001];
+          NNode(m).rightLengthDist = [0.9999 0.0001];
+          if Normalize == 1
+              NNode(m).leftLetterDist  = [1 1 1 1]/4;
+              NNode(m).rightLetterDist = [1 1 1 1]/4;
+          else
+              NNode(m).leftLetterDist  = [1 1 1 1];
+              NNode(m).rightLetterDist = [1 1 1 1];
+          end
+          NNode(m).Comment         = ' // New Initial node after Fixed node';
         end
-        NNode(m).Comment         = ' // New Initial node after Fixed node';
       end
     end
+    m = m + 1;
   end
-  m = m + 1;
-end
 
-Node = NNode;
+  Node = NNode;
 
-if Verbose > 0,
-  for n = 1:length(Node),
-    fprintf('%d %s\n', n, Node(n).type);
+  if Verbose > 1
+    for n = 1:length(Node)
+      fprintf('%d %s\n', n, Node(n).type);
+    end
   end
-end
 
-if 0 > 1,
-  Text = pNodeToSCFGModelText(Node,5);
-  for r = 1:length(Text),
-    fprintf('%s\n', Text{r});
+  if 0 > 1
+    Text = pNodeToSCFGModelText(Node,5);
+    for r = 1:length(Text)
+      fprintf('%s\n', Text{r});
+    end
   end
-end
 
-% ---------------------------- Remove Initial Node after Basepair
+  % ---------------------------- Remove Initial Node after Basepair
 
-clear NNode
+  clear NNode
 
-Keep = 1:length(Node);
-for n = 1:(length(Node)-1),
-  if strcmp(Node(n).type,'Basepair') && strcmp(Node(n+1).type,'Initial'),
-    Keep(n+1) = 0;
-    if Verbose > 0,
-      fprintf('pMakeMotifModelFromSSF:  Removing Initial node after Basepair\n');
+  Keep = 1:length(Node);
+  for n = 1:(length(Node)-1)
+    if strcmp(Node(n).type,'Basepair') && strcmp(Node(n+1).type,'Initial')
+      Keep(n+1) = 0;
+      if Verbose > 0
+        fprintf('pMakeMotifModelFromSSF:  Removing Initial node after Basepair\n');
+      end
     end
   end
-end
 
   Node = Node(find(Keep));
-  for n = 1:(length(Node)-1),
-    Node(n).nextnode = n + 1;
+  for n = 1:(length(Node)-1)
+    if ~strcmp(Node(n).type,'Junction')
+      Node(n).nextnode = n + 1;
+    end
   end
 
-  if 0 > 1,
-    for n = 1:length(Node),
+  if Verbose > 0
+    fprintf('pMakeMotifModelFromSSF: complete list of nodes\n')
+    for n = 1:length(Node)
       fprintf('%d %s\n', n, Node(n).type);
     end
   end
 
-% ---------------------------- Show alignment of instances
-
-  Text = xAlignCandidates(Search.File,Search);
+  % update nextnode list of Junction nodes now that nodes are re-numbered
+  [Node, k] = pNextNodeJunction(Node,1);
 
-  if Verbose > 0,
+  if Verbose > 1
+    % this might not work
+    % ---------------------------- Show alignment of instances
+    Text = xAlignCandidates(Search.File,Search);
     disp('pMakeMotifModelFromSSF: alignment of instances from 3D');
-    for t = 1:length(Text),
+    for t = 1:length(Text)
       fprintf('%s\n', Text{t});
     end
   end
 
   % ------------------------------------ Modify pair and substitution probs
-
   [Node,Search] = pUpdateModelWithSSF(Node,Search,f,F,Param,Prior,loopType,File,UseIndex,Normalize);
 
-  if Verbose > 0,
+  if Verbose > 0
     fprintf('\n')
   end
 
diff --git a/matlab/pMakeNodes.m b/matlab/pMakeNodes.m
index df472ed..4de9363 100644
--- a/matlab/pMakeNodes.m
+++ b/matlab/pMakeNodes.m
@@ -1,24 +1,31 @@
-% pMakeNodes(File,NTNumber,LastNTNumber,Truncate,Interact,Node,n) makes a secondary structure node model based on the Edge interaction matrix in File, starting at NTNumber and ending at LastNTNumber.  It assigns various nodes consistent with this secondary structure.  Truncate indicates where to put * hairpins.  Interact, Node, and n are optional parameters specified when pMakeNodes is called by itself.
+% pMakeNodes(File,NTNumber,LastNTNumber,Truncate,Interact,Node,n) makes a secondary
+% structure node model based on the Edge interaction matrix in File, starting at
+% NTNumber and ending at LastNTNumber.  It assigns various nodes consistent with
+% this secondary structure.
+% Truncate indicates the first nucleotide of each new strand, for modeling
+% internal and junction loops.
+% Interact, Node, and n are optional parameters specified when pMakeNodes is called by itself,
+% for example, after a Junction is found.
 
 function [Node] = pMakeNodes(File,Param,NTNumber,LastNTNumber,Truncate,Data,Node,n)
 
-if nargin < 2,
+if nargin < 2
     Verbose = 1;
 end
 
-if nargin < 3,
+if nargin < 3
     NTNumber = 1;
 end
 
 Verbose         = Param(1);
-method          = 4;             % method for assigning pair subst probs
+% method          = 4;             % method for assigning pair subst probs
 Extension       = 1;             % whether to extend stems with no LR inter
-AdjustSubsForLR = 1;             % adjust ins, basepair subs probs for LR inter
-cdepth          = 10;            % how far to look ahead for a cluster
+% AdjustSubsForLR = 1;             % adjust ins, basepair subs probs for LR inter
+cdepth          = 20;            % how far to look ahead for a cluster; can be large for motif atlas
 usenear         = 0;             % use near pairs for basepair probabilities
-insertionconserved = 0;          % treat insertions as conserved bases?
-jcdepth         = 4;             % how far to look for a junction cluster
-Normalize = 1;
+% insertionconserved = 0;          % treat insertions as conserved bases?
+% jcdepth         = 4;             % how far to look for a junction cluster
+% Normalize = 1;
 
 % Parameters stored in Param:
 % Param(1) verbose
@@ -30,114 +37,96 @@ Normalize = 1;
 % Param(7) treat insertions as conserved bases
 % Param(8) normalize scores for insertions and basepairs
 
-if length(Param) > 6,
+if length(Param) > 6
     Normalize = Param(8);
 end
 
-if length(Param) > 6,
+if length(Param) > 6
     insertionconserved = Param(7);
 end
 
-if length(Param) > 5,
+if length(Param) > 5
     usenear = Param(6);
 end
 
-if length(Param) > 4,
+if length(Param) > 4
     cdepth = Param(5);
 end
 
-if length(Param) > 3,
+if length(Param) > 3
     AdjustSubsForLR = Param(4);
 end
 
-if length(Param) > 2,
+if length(Param) > 2
     Extension = Param(3);
 end
 
-if length(Param) > 1,
+if length(Param) > 1
     method  = Param(2);
 end
 
-if nargin < 5,
+if nargin < 5
     Truncate = [];
 end
 
-if nargin < 8,
+if nargin < 8
     n=0;                            % current node number
 end
 
+% temporary to show lots of information
+Verbose = 1;
+
+
 % -------------------------- if File is a text string (filename), load the file
 
-if strcmp(class(File),'char'),
+if strcmp(class(File),'char')
     Filename = File;
     File = zGetNTData(Filename,0);
 end
 
 % ----------------- if NTNumber is a cell array of numbers, look up the indices
 
-if strcmp(class(NTNumber),'char'),
+if strcmp(class(NTNumber),'char')
     NTNumber = {NTNumber};
 end
 
-if strcmp(class(NTNumber),'cell'),
+if strcmp(class(NTNumber),'cell')
     NTNumber = zIndexLookup(File,NTNumber);
 end
 
-% ----------------- if Truncate is a cell array of numbers, look up the indices
-
-if strcmp(class(Truncate),'char'),
-    Truncate = {Truncate};
-end
-
-if strcmp(class(Truncate),'cell'),
-    if isempty(Truncate),
-        Truncate = [];
-    else
-        Truncate = zIndexLookup(File,Truncate);
-    end
-end
-
 % ------------------------------------------ Set key variables
 
 N = length(File.NT);                       % number of nucleotides in File
-DelProb = 0.01;                            % nominal deletion probability
+DelProb = 0.01;                            % nominal deletion probability, used in other programs
 % for basepairs
 TertiaryFreeNode = 0;                      % first node in this stem making
-% no tertiary intearctions beyond it
+% no tertiary interactions beyond it
 
-if ~isfield(File,'BasePhosphate'),
+if ~isfield(File,'BasePhosphate')
     File.BasePhosphate = sparse(zeros(N,N));
 end
 
-if ~isfield(File,'BaseRibose'),
+if ~isfield(File,'BaseRibose')
     File.BaseRibose = sparse(zeros(N,N));
 end
 
-if nargin < 4,
+if nargin < 4
     LastNTNumber = N;
-elseif strcmp(class(LastNTNumber),'cell'),
+elseif strcmp(class(LastNTNumber),'cell')
     LastNTNumber = zIndexLookup(File,LastNTNumber);
-elseif strcmp(class(LastNTNumber),'char'),
+elseif strcmp(class(LastNTNumber),'char')
     LastNTNumber = zIndexLookup(File,{LastNTNumber});
 end
 
-
-
-%NTNumber
-%LastNTNumber
-%full(File.Edge(NTNumber:(NTNumber+10),(LastNTNumber-10):LastNTNumber))
-
-
-
 % ------------------------------------------ Store indices of interacting bases
 
-load PairExemplars
+load PairExemplars                              % used in other programs
 
-if nargin < 6,
+if nargin < 6
 
     E = abs(fix(File.Edge));                    % don't distinguish subcategories
     G = E .* (E < 16) .* (E ~= 0);              % consider basepairing only,
-    % including bifurcated, water-ins
+                                                % including bifurcated, water-ins
 
     CanonicalPairs = {'CG','GC','AU','UA','GU','UG'};
     CanonicalcWW = sparse(zeros(N,N));
@@ -148,25 +137,26 @@ if nargin < 6,
             CanonicalcWW(i(ii),j(ii)) = 1;
             CanonicalcWW(j(ii),i(ii)) = 1;
         end
-    end 
+    end
 
-    if usenear > 0,
-        G = G +  E .* (E > 100);                % near basepairs too
+    if usenear > 0
+        G = G +  E .* (E > 100) .* (E < 116);   % near basepairs too
     end
 
-    H = (G ~= 0) .* max(File.Crossing == 0, abs(G) == 1) ;
+    H = (G ~= 0) .* max(File.Crossing == 0, abs(G) == 1);
     % 1 for nested pairs, 0 otherwise
 
     J = abs(G .* (File.Crossing >  0));         % long-range basepairs only
 
-    GG = G .* (abs(fix(G)) ~= 9);               % eliminate cSH pairs for hairpins
     GG = G;
-    for i = 1:(length(GG(:,1))-1),
-        GG(i,i+1) = 0;                          % eliminate pairs btw adjacent
-        GG(i+1,i) = 0;
+    for i = 1:(length(GG(:,1))-1)
+        if pStrandBreaksBetween(i,i+1,Truncate) == 0
+            GG(i,i+1) = 0;                      % eliminate pairs btw adjacent
+            GG(i+1,i) = 0;
+        end
     end
 
-    for a = 1:N,                                % loop through nucleotides
+    for a = 1:N                                 % loop through nucleotides
         k = find(G(a,:));                       % find indices of interacting bases
         [y,L] = sort(E(a,k));                   % sort by edge interaction category
         Interact{a}.Categ = abs(File.Edge(a,k(L)));   % store categories
@@ -178,12 +168,12 @@ if nargin < 6,
     HasMotif     = zeros(1,length(File.NT));
     HasGUPacking = zeros(1,length(File.NT));   % highly-conserved motif
 
-    if isfield(File,'Nucl'),
-        for i = 1:length(File.NT),
-            if ~isempty(File.Nucl(i).Motif),
+    if isfield(File,'Nucl')
+        for i = 1:length(File.NT)
+            if ~isempty(File.Nucl(i).Motif)
                 HasMotif(i) = 1;
-                for m = 1:length(File.Nucl(i).Motif),
-                    if ~isempty(strfind(File.Nucl(i).Motif(m).Name,'GU_packing')),
+                for m = 1:length(File.Nucl(i).Motif)
+                    if ~isempty(strfind(File.Nucl(i).Motif(m).Name,'GU_packing'))
                         HasGUPacking(i) = 1;
                     end
                 end
@@ -218,9 +208,8 @@ AA = a;                                    % previous cWW base on left
 B  = LastNTNumber;                         % next base on right
 BB = a;                                    % previous cWW base on right
 
-
-if Verbose > 0,
-    fprintf('Loop %4s %4s\n', File.NT(a).Number, File.NT(B).Number);
+if Verbose > 0
+    fprintf('pMakeNodes starting loop:     a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
 end
 
 % Initial node creation -------------------------------------------------
@@ -231,114 +220,171 @@ pMakeNodesNewNode;                         % set up blank node with all fields
 Node(n).type      = 'Initial';             % node type
 Node(n).nextnode  = n+1;                   % index of next node in tree
 Node(n).LeftIndex = a;                     % index of first base on left
-Node(n).RightIndex= B;                     % index of first base on right
+Node(n).RightIndex= B;                     % index of last base on right
+Node(n).Comment = ' // Initial node';
 
-pMakeNodesProbeForInsertions;              % probe for insertions, each strand
+if G(a,B) == 0
+    pMakeNodesProbeForInsertions;              % probe for insertions, each strand
+                                               % moves a and B to next basepair
+end
 
 % ---------------------------------------------------------------------------
 
 EndLoop = 0;                               % flag for the end of the loop
 
-while (EndLoop == 0) && (a <= LastNTNumber), % while not the end of the loop,
+while (EndLoop == 0) && (a <= LastNTNumber) % while not the end of the loop,
+
+    % Strategy for junctions: push all the way to where there are no more basepairs to be modeled
+    % on the current stem, because maybe there will be ones to model on the next stem
 
-    % ---------------------------------- Check for junction
+    StartJunction = 0;
+    if pStrandBreaksBetween(a,B,Truncate) > 1
+        % there is a junction ahead, is now the time to start it?
 
-    % check to see if a is now in a new nested loop
+        % indices of last nucleotides on current left and right strands
+        aaa = pNextTruncation(a,Truncate,N);
+        BBB = pNextTruncation(B,Truncate,1);
 
-    r = a;                               % leftmost index of a cWW
-    rr= a;                               % start of current loop
+        % nucleotides on next strand(s) (NSL and NSR are the same for J3)
+        [NSL,NSR] = pNextStrands(a,B,Truncate,N);
 
-    while sum(H(r,(r+1):B)) == 0 && r < B, % if r does not make a nested pair,
-        r = r + 1;
+        if a == aaa
+            % reached the end of this strand
+            StartJunction = 1;
+        elseif sum(sum(H(a,NSL))) > sum(sum(H(a,BBB:B)))
+            % more interactions with NSL than right strand, stop
+            StartJunction = 1;
+        end
+
+        if B == BBB
+            % reached the end of this strand
+            StartJunction = 1;
+        elseif sum(sum(H(B,NSR))) > sum(sum(H(B,a:aaa)))
+            % more interactions with NSL than right strand, stop
+            StartJunction = 1;
+        end
     end
 
-    s = Interact{r}.Index(1);            % what it interacts with
-    t = s+1;                             % next after that
-    u = B;                               % end of current known loop
+    if StartJunction                         % determined by pMakeNodesProbeForInsertions
 
-    if (sum(sum(CanonicalcWW(t:u,t:u)==1)) > 0) && (sum(sum(CanonicalcWW(r:s,r:s)==1)) > 0),
-        % there are nested canonical cWW pairs between r and s and between t and u
-        % use cWW pairs to avoid pairs between i and i+1 making junctions
+        pMakeNodesJunction                   % make model for junction
 
-        if Verbose > 1,
-            fprintf('Found nested interactions between %s and %s and between %s and %s\n', File.NT(r).Number, File.NT(s).Number, File.NT(t).Number, File.NT(u).Number);
-        end
+        % fprintf('Inserted a junction, pausing before moving on to the next motif\n')
+        % pause
 
-        pMakeNodesJunction                   % make models for junctions
-        return                               % nothing left to do!
+        return                               % nothing left to do, junctions cover the rest
 
-    else                                   % not a junction
+    else                                     % not a junction
 
         % ---------------------------------- Identify basepair or cluster
 
-        aaa = min([length(File.NT) a+cdepth floor((a+B)/2)]);
-        BBB = max([1 B-cdepth ceil((a+B)/2)]);
-        LS = (a+1):aaa;                         % left strand
-        RS = BBB:(B-1);                         % right strand
+        [aaa,BBB] = pNextNucleotides(a,B,Truncate,N,cdepth);
+
+        LS = (a+1):aaa;                         % left strand after a
+        RS = BBB:(B-1);                         % right strand before B
+
+        if Verbose > 10
+            fprintf('pMakeNodes left strand can go up    as far as %s\n', File.NT(aaa).ID);
+            fprintf('pMakeNodes right strand can go back as far as %s\n', File.NT(BBB).ID);
+        end
 
-        if HasMotif(a),   % ---------------------- Insert motif model when needed
+        if HasMotif(a)   % ---------------------- Insert motif model when needed
 
             pMakeNodesMotif
 
-        elseif (H(a,B) > 0) && (B - a) > 1 && ((cdepth == 0) || ...
-                (sum(sum(G(a,[LS RS]))) == 0 && sum(sum(G([LS RS],B))) == 0)),
+        elseif (H(a,B) > 0) && pStrandBreaksBetween(a,B,Truncate) == 1 && ...
+            (a == pNextTruncation(a,Truncate,N)) && (B == pNextTruncation(B,Truncate,1))
+            % a and B pair, a is at the end of a strand, and B is at the start of the next strand
+
+            % fprintf('pMakeNodes making a basepair:  a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
+            pMakeNodesBasepair                       % add basepair with insertions
+            % fprintf('pMakeNodes after  a basepair:  a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
+
+        elseif (H(a,B) > 0) && ((B - a) > 1 || pStrandBreaksBetween(a,B,Truncate) > 0) && ...
+            ((cdepth == 0) || (sum(sum(G(a,[LS RS]))) == 0 && sum(sum(G([LS RS],B))) == 0))
             % a and B interact, but not also with other nearby bases
+
+            % fprintf('pMakeNodes making   basepair:  a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
             pMakeNodesBasepair                       % add basepair with insertions
+            % fprintf('pMakeNodes after    basepair:  a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
 
         else     % a and B also interact with nearby bases - use a cluster node
 
             % [a aaa BBB B]
             % zShowInteractionTable(File,unique([a:aaa BBB:B]));
 
-            if abs(B - a) > 7,                         % far enough from hairpin
-                pMakeNodesCluster;
+            if pStrandBreaksBetween(a,B,Truncate) > 0
+                fprintf('pMakeNodes making a cluster near strand break a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
+                pMakeNodesCluster;       % across a strand break; internal loop maybe with complicated interactions
             else
-                pMakeNodesHairpin;
-                EndLoop = 1;
-                if Verbose > 0,
-                    disp('Making a hairpin instead of inserting a cluster');
+                fprintf('pMakeNodes checking on making a cluster a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
+                pMakeNodesCluster;
+
+                if make_hairpin == 1
+                    % the cluster would cover all nucleotides in the current stem, so use a hairpin instead
+                    if Verbose > 0
+                        fprintf('pMakeNodes making a hairpin a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
+                    end
+                    pMakeNodesHairpin;
+                    EndLoop = 1;
                 end
             end
-            % pause
-
         end                                          % basepair or cluster
 
         % ------------------- check for tertiary interactions in this stem
 
         pMakeNodesCheckForExtensibility
+        if Verbose > 10
+            fprintf('pMakeNodes checked extensibi:  a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
+        end
 
         % ------------------- check for truncation and hairpin
-        
-        GG = G .* (abs(fix(G)) ~= 9);              % eliminate cSH pairs for hairpins
         GG = G;
-        for i = 1:(length(GG(:,1))-1),
-            GG(i,i+1) = 0;                           % eliminate pairs btw adjacent
-            GG(i+1,i) = 0;
+        for i = 1:(length(GG(:,1))-1)
+            if pStrandBreaksBetween(i,i+1,Truncate) == 0
+                GG(i,i+1) = 0;                   % eliminate pairs between adjacent, like cSH
+                GG(i+1,i) = 0;
+            end
         end
 
-        if (EndLoop == 0),
-            if ismember(a,Truncate) || ismember(a-1,Truncate) || isempty(File.NT(a).Base),
+        % -------- Have not added a hairpin but maybe we need to stop anyway
+        if (EndLoop == 0)
+            % removed ismember(a-1,Truncate) || but added a > B for after a cluster
+            if (a >= B && length(Truncate) > 0) || ismember(a,Truncate) || isempty(File.NT(a).Base)
+
+                % fprintf('pMakeNodes truncating with * HL:  a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
 
                 pMakeNodesTruncate                % add * hairpin
 
-            elseif (a == B) || ((sum(sum(abs(GG(a:B,a:B)))) == 0)),
-                % no nucleotides left, or
-                % no further basepairs except cSH
-                if (TertiaryFreeNode > 0) && isempty(Truncate) && Extension > 0,
-                    % extensible region, not a truncated model
-                    pMakeNodesExtraBasepairs;       % add extra basepairs if extensible
+            elseif (a >= B) || ((sum(sum(abs(GG(a:B,a:B)))) == 0))
+                % no nucleotides left, or no further basepairs except cSH
+                if (TertiaryFreeNode > 0) && isempty(Truncate) && Extension > 0
+                    % extensible region, not a truncated model, only applies to HL
+                    if Verbose > 0
+                        fprintf('pMakeNodes extra basepairs: a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
+                    end
+                        pMakeNodesExtraBasepairs;       % add extra basepairs if extensible
+                end
+
+                if Verbose > 0
+                    fprintf('pMakeNodes adding hairpin:     a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
                 end
 
                 pMakeNodesHairpin
+
+            elseif G(a,B) > 0
+                fprintf('No need to probe because of interaction between a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
             else
 
-                pMakeNodesProbeForInsertions       % add insertions if needed
+                fprintf('pMakeNodes probe for inserts:  a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
+                pMakeNodesProbeForInsertions   % add insertions to basepair node or new initial node if needed
+                fprintf('pMakeNodes probed for insert:  a=%s B=%s\n', File.NT(a).ID, File.NT(B).ID);
 
             end                                  % hairpin or insertions
-        elseif TertiaryFreeNode > 0 && isempty(Truncate) && Extension > 0,
-            pMakeNodesExtraBasepairs;       % add extra basepairs if extensible
-        end                                    % if EndLoop == 0
-    end                                      % junction and junction cluster
+        elseif TertiaryFreeNode > 0 && isempty(Truncate) && Extension > 0
+            pMakeNodesExtraBasepairs;     % add extra basepairs if extensible, only for HL
+        end                               % if EndLoop == 0
+    end                                   % if junction or not
 end                                       % while (EndLoop == 0) & (a <= N),
 
 % ---------------------------------- Poisson distribution for lengths -------
diff --git a/matlab/pMakeNodesBasepair.m b/matlab/pMakeNodesBasepair.m
index cb63276..9348d88 100644
--- a/matlab/pMakeNodesBasepair.m
+++ b/matlab/pMakeNodesBasepair.m
@@ -1,6 +1,6 @@
 % set up basepair
 
-n = n+1;  
+n = n+1;
 Node(n).type        = 'Basepair';        % node type
 Node(n).nextnode    = n+1;               % index of next node in tree
 Node(n).LeftLetter  = File.NT(a).Base;
@@ -13,7 +13,7 @@ Node(n).LeftIndex   = a;
 Node(n).RightIndex  = B;
 Node(n).leftLengthDist  = subPoisson(0.01);
 Node(n).rightLengthDist = subPoisson(0.01);
-if Normalize == 1,
+if Normalize == 1
   Node(n).leftLetterDist  = [0.25 0.25 0.25 0.25];
   Node(n).rightLetterDist = [0.25 0.25 0.25 0.25];
 else
diff --git a/matlab/pMakeNodesCheckForExtensibility.m b/matlab/pMakeNodesCheckForExtensibility.m
index cb5015e..7fe444f 100644
--- a/matlab/pMakeNodesCheckForExtensibility.m
+++ b/matlab/pMakeNodesCheckForExtensibility.m
@@ -1,4 +1,5 @@
-% pMakeNodesCheckForExtensibility checks the rest of the stem to see if there are long-range basepairs, BPh, or GU packing interactions
+% pMakeNodesCheckForExtensibility checks the rest of the stem to see if there
+% are long-range basepairs, BPh, or GU packing interactions
 
 Outside = [1:(a-1) (B+1):length(File.NT)];
 
@@ -9,8 +10,8 @@ if sum(sum(J(a:B,Outside))) == 0 && ... % no tertiary inter outside this stem
    (~strcmp(File.Filename,'2AW4') || (a > 69)),
 
   if TertiaryFreeNode == 0,              % only mark the first one
-    TertiaryFreeNode = n;                
-    if Verbose > 0,
+    TertiaryFreeNode = n;
+    if Verbose > 10
      fprintf('After node %3d, this stem is free of tertiary interactions\n',n);
     end
 
diff --git a/matlab/pMakeNodesCluster.m b/matlab/pMakeNodesCluster.m
index 896ba5b..2180d05 100644
--- a/matlab/pMakeNodesCluster.m
+++ b/matlab/pMakeNodesCluster.m
@@ -13,35 +13,31 @@
 % 2. Numbering along each strand, from 1 to N on each strand.  ss, tt, zs, zt, xs, yt, RightNotInter are on this scheme.
 % 3. Numbering the interacting bases in the cluster from 1 to M, regardless of strand.  rightnum, e, IBases are on this scheme.
 
-if exist('zxsx')
-  disp('Cluster *****************************************************');
+if pStrandBreaksBetween(a,B,Truncate) == 0
+  % hairpin
+  amax = min([length(File.NT) a+cdepth floor((a+B)/2)]);
+  bmin = max([1 B-cdepth ceil((a+B)/2) amax+1]);
+
+  fprintf('amax is %d bmin is %d\n',amax,bmin);
+  use_amax = 0;
+else
+  % IL or junction
+  amax = min(a+cdepth,pNextTruncation(a,Truncate,N)); % how far to look on left, at most
+  bmin = max(B-cdepth,pNextTruncation(B,Truncate,1)); % how far to look on right, at most
+  use_amax = 1;
 end
 
-%[a b B cdepth]
 b = B;                                 % current base on right
 
-amax = min(a+cdepth,floor((a+b)/2));   % how far to look on left
-bmin = max(b-cdepth,floor((a+b)/2)+1); % how far to look on right
-
-z = find((a < Truncate) .* (Truncate < amax));
-if ~isempty(z),
-  amax = Truncate(z)-1;                % don't look beyond truncation point
-end
-
-z = find((bmin < Truncate) .* (Truncate < b));
-if ~isempty(z),
-  bmin = Truncate(z)-1;                % don't look beyond truncation point
-end
-
 X = full(triu(G(a:amax,a:amax)));      % interactions on left strand
 Y = full(triu(G(bmin:b,bmin:b)));      % interactions on right strand
 Z = full(G(a:amax,bmin:b));            % interactions between left + right
-[s,t] = size(Z);                       % X is s x s, Y is t x t
+[s,t] = size(Z);                       % X is s by s, Y is t by t
 
 % ------------------------------------ determine extent of cluster interactions
 
 ssa = max(find(X(1,:)));               % depth from a on left
-ssb = max(find(Z(:,t)));               % nearest interaction to t 
+ssb = max(find(Z(:,t)));               % nearest interaction to t
 if isempty(ssa), ssa = 1; end
 if isempty(ssb), ssb = 1; end
 ss = max(ssa, ssb);
@@ -55,7 +51,7 @@ tt = min(tta, ttb);
 while sum(sum(Z(1:ss,1:(tt-1)))) > 0 || ...
       sum(sum(Z((ss+1):s,tt:t))) > 0 || ...
       sum(sum(X(1:ss,(ss+1):s))) > 0 || ...
-      sum(sum(Y(tt:t,1:(tt-1)))) > 0,
+      sum(sum(Y(tt:t,1:(tt-1)))) > 0
   ssa = max(find(sum(X(1:ss,:),1)));
   ssb = max(find(sum(Z(:,tt:t),2)));
   if isempty(ssa), ssa = 1; end
@@ -72,22 +68,40 @@ end
 aa = a - 1 + ss;                      % left extent of cluster
 bb = b - (t - tt);                    % right extent of cluster
 
+fprintf('pMakeNodesCluster: Cluster goes from %d to %d and then %d to %d\n', a,aa,bb,b);
+
+if aa + 1 == bb && use_amax == 0
+  fprintf('pMakeNodesCluster: Using a hairpin to finish this stem\n')
+  make_hairpin = 1;
+  return
+else
+  make_hairpin = 0;
+end
+
+% if use_amax == 0 && aa + 1 == bb
+%   % hairpin loop and the cluster seems to be the whole loop
+%   % allow them to overlap so we don't miss any nucleotides
+%   bb = aa + 1;
+% end
+
+fprintf('aa is %d bb is %d\n',aa,bb);
+
 % ------------------------------------- Set up basics of cluster node
 
 n=n+1;
-Node(n).Delete       = 0.001;            % deletion probability
-Node(n).type         = 'Cluster';        % node type
-Node(n).nextnode     = n+1;              % index of next node in tree
-Node(n).LeftIndex    = [a:aa];           % full range of indices
-Node(n).LeftLetter   = cat(2,File.NT(a:aa).Base);
-Node(n).RightLetter  = cat(2,File.NT(bb:b).Base);
-Node(n).RightIndex   = [bb:b];
-
-AllIndices = [a:aa bb:b];
+Node(n).Delete      = 0.001;            % deletion probability for now
+Node(n).type         = 'Cluster';      % node type
+Node(n).nextnode    = n+1;              % index of next node in tree
+Node(n).LeftIndex   = a:aa;             % full range of indices
+Node(n).LeftLetter  = cat(2,File.NT(a:aa).Base);
+Node(n).RightLetter = cat(2,File.NT(bb:b).Base);
+Node(n).RightIndex  = bb:b;
 
 Node(n).Comment = [' // Cluster node ' File.NT(Node(n).LeftIndex(1)).Base File.NT(Node(n).LeftIndex(1)).Number ':' File.NT(Node(n).LeftIndex(end)).Base, File.NT(Node(n).LeftIndex(end)).Number ' and ' File.NT(Node(n).RightIndex(1)).Base File.NT(Node(n).RightIndex(1)).Number ':' File.NT(Node(n).RightIndex(end)).Base File.NT(Node(n).RightIndex(end)).Number];
 
-if Verbose > 0,
+AllIndices = [a:aa bb:b];
+
+if Verbose > 0
   fprintf('%3d Cluster   %s:%s %s:%s\n', n, File.NT(a).Number, File.NT(aa).Number, File.NT(bb).Number, File.NT(b).Number);
 end
 
@@ -102,10 +116,21 @@ zt = find(sum(Z,1));       % bases on right interacting with left
 xs = find(sum(X+X',1));    % left with left
 yt = find(sum(Y+Y',1));    % right with right
 
-Node(n).LeftNotInter = setdiff(1:length(Node(n).LeftIndex),union(zs,xs));
+Node(n).LeftNotInter  = setdiff(1:length(Node(n).LeftIndex),union(zs,xs));
 Node(n).RightNotInter = setdiff(1:length(Node(n).RightIndex),union(zt,yt));
 
-if insertionconserved == 1,  % treat non-interacting bases as part of the cluster
+% Node(n).LeftNotInter
+% Node(n).LeftIndex
+% Z
+% zs
+% xs
+
+% Node(n).RightNotInter
+% Node(n).RightIndex
+% zt
+% yt
+
+if insertionconserved == 1   % treat non-interacting bases as part of the cluster
   zs = 1:ss;                 % all are thought of as interacting
   zt = 1:length(Y(1,:));
   xs = 1:ss;
@@ -114,7 +139,7 @@ end
 
 leftinter = union(zs,xs);            % list of interacting on left
 leftnum   = [];
-leftnum(leftinter) = 1:length(leftinter); 
+leftnum(leftinter) = 1:length(leftinter);
                           % sequential numbering of interacting bases
 
 rightinter = union(zt,yt);
@@ -126,12 +151,12 @@ rightnum(find(rightnum)) = rightnum(find(rightnum))+length(leftinter);  % shift
 % --------------- list insertion possibilities and corresponding probabilities
 
 zsxs = union(zs,xs);              % all interacting bases on the left
-if isempty(zsxs),                 % happens when no inter across
+if isempty(zsxs)                  % happens when no inter across
   zsxs = 1;
 end
 
 ztyt = union(zt,yt);              % all interacting bases on the right
-if isempty(ztyt),
+if isempty(ztyt)
   ztyt = 1;
 end
 
@@ -217,7 +242,7 @@ for k = 1:length(i),                 % loop through them
     end
 
     Node(n).SubsProb(:,:,K) = pIsoScore(File.Edge(i1,i2), ...
- File.NT(i1).Code, File.NT(i2).Code,method,ExemplarIDI,ExemplarFreq,Normalize);
+    File.NT(i1).Code, File.NT(i2).Code,method,ExemplarIDI,ExemplarFreq,Normalize);
 
     Node(1).Edge(i1,i2) = File.Edge(i1,i2);
     K  = K + 1;
@@ -225,7 +250,7 @@ end
 
 % ---- interactions between right and right
 [i,j] = find(Y);                      % interacting pairs
-for k = 1:length(i),                  % loop through them
+for k = 1:length(i)                   % loop through them
     Node(n).IBases(K,:) = [rightnum(i(k)) rightnum(j(k))];
     i1 = i(k) + bb - 1;               % index of first base
     i2 = j(k) + bb - 1;               % index of second
@@ -233,7 +258,7 @@ for k = 1:length(i),                  % loop through them
 
     Node(n).InteractionComment{K} = [ ' // Cluster Interaction ' File.NT(i1).Base File.NT(i1).Number ' - ' File.NT(i2).Base File.NT(i2).Number ' ' zEdgeText(File.Edge(i1,i2))];
 
-    if Verbose > 0,
+    if Verbose > 0
       fprintf('    RR Inter  %4s %4s %c%c %s\n', File.NT(i1).Number, File.NT(i2).Number, File.NT(i1).Base, File.NT(i2).Base, zEdgeText(File.Edge(i1,i2)));
 %fprintf('%d %d\n', Node(n).IBases(K,1), Node(n).IBases(K,2));
     end
@@ -246,36 +271,36 @@ end
 
 % ---- inserted bases which are treated as conserved insertions and modeled as interacting with themselves
 
-for i = Node(n).LeftNotInter,
+for i = Node(n).LeftNotInter
   K = length(Node(n).IBases(:,1))+1;
   Node(n).IBases(K,:) = [i i];
   i1 = i + a - 1;
   Node(n).InterIndices(K,:) = [i1 i1];
-  Node(n).InteractionComment{K} = [' // Left strand conserved insertion ' File.NT(i1).Base File.NT(i1).Number];
+  Node(n).InteractionComment{K} = [' // Left strand conserved insertion ' File.NT(i1).ID];
   M = eye(4);
   M(File.NT(i1).Code,File.NT(i1).Code) = 4;
   M = M / sum(sum(M));
   Node(n).SubsProb(:,:,K) = M;            % favor the observed base
-  
-  if Verbose > 0,
-    fprintf('    Left strand conserved insertion %c%4s at position %d\n', File.NT(i1).Base, File.NT(i1).Number, i);
+
+  if Verbose > 0
+    fprintf('    Left  strand conserved insertion %s at position %d\n', File.NT(i1).ID, i);
   end
 end
 
-for i = Node(n).RightNotInter,
+for i = Node(n).RightNotInter
   K = length(Node(n).IBases(:,1))+1;
 
   Node(n).IBases(K,:) = [i i] + length(leftinter); % shift from right strand numbering to whole motif numbering
   i1 = i + bb - 1;                        % index in original file
   Node(n).InterIndices(K,:) = [i1 i1];
-  Node(n).InteractionComment{K} = [' // Right strand conserved insertion ' File.NT(i1).Base File.NT(i1).Number];
+  Node(n).InteractionComment{K} = [' // Right strand conserved insertion ' File.NT(i1).ID];
   M = eye(4);
   M(File.NT(i1).Code,File.NT(i1).Code) = 4;
   M = M / sum(sum(M));
   Node(n).SubsProb(:,:,K) = M;            % favor the observed base
 
-  if Verbose > 0,
-    fprintf('    Right strand conserved insertion %c%4s at right strand position %d\n', File.NT(i1).Base, File.NT(i1).Number, i);
+  if Verbose > 0
+    fprintf('    Right strand conserved insertion %s at position %d\n', File.NT(i1).ID, i);
   end
 
 end
@@ -300,7 +325,20 @@ a = aa + 1;                           % current base on left
                                       % skip over rest of cluster
 B = bb - 1;                           % current base on right
 
-a = min(a,B);                         % just in case!
+fprintf('pMakeNodesCluster a=%d B=%d at the end\n', a, B)
+
+B = max(B,1);
+
+% a > B is an important sign that there are no more bases to model with a node
+
+% a = min(a,B);                         % just in case!
+
+if use_amax && a <= B
+  a = min(a,amax);                      % don't go beyond the current strand
+  B = max(B,bmin);
+end
+
+fprintf('pMakeNodesCluster a=%d B=%d at the end\n', a, B)
 
 % calculate normalization constant
 %if Normalize == 1,
@@ -309,7 +347,7 @@ a = min(a,B);                         % just in case!
 %    Node(n).NormCons = pClusterNorm(Node(n).InterIndices,Node(n).SubsProb,Node(n).LeftIndex,Node(n).RightIndex);
 %    Node(n).NormCons = .66;             % pClusterNorm only works for normalized matrices, temp fix!
 %end
-    
+
 %         psum = 0;
 %         numBases = length(Node(n).Left) + length(Node(n).Right);
 % 		if numBases < 11,
diff --git a/matlab/pMakeNodesHairpin.m b/matlab/pMakeNodesHairpin.m
index bb8b101..709156f 100644
--- a/matlab/pMakeNodesHairpin.m
+++ b/matlab/pMakeNodesHairpin.m
@@ -11,13 +11,13 @@ Node(n).RightLetter = '';
 Node(n).P           = ones(17,1);
 Node(n).PIns        = 1;
 
-if TertiaryFreeNode == 0 || Extension < 2,  % this stem has long-range inter
+if TertiaryFreeNode == 0 || Extension < 2   % this stem has long-range inter
                                             % or we are using regular hairpins
   Node(n).subtype     = 'XXXX';             % revise this later!
 
   % ----------------------------------------- model interactions
   [i,j] = find(triu(G(MI,MI)));
-  for k = 1:length(i),
+  for k = 1:length(i)
     Node(n).IBases(k,:) = [i(k) j(k)];      % these bases interact
     i1 = i(k) + a - 1;                      % index of first base
     i2 = j(k) + a - 1;                      % index of second base
@@ -32,7 +32,7 @@ if TertiaryFreeNode == 0 || Extension < 2,  % this stem has long-range inter
     [K,KK] = size(Node(n).IBases);
     K = K + 1;
 
-    Node(n).IBases(K,:) = [i i]; 
+    Node(n).IBases(K,:) = [i i];
     i1 = i + a - 1;                        % index in original file
     Node(n).InterIndices(K,:) = [i1 i1];
     Node(n).InteractionComment{K} = [' // Hairpin conserved non-basepairing position ' File.NT(i1).Base File.NT(i1).Number];
@@ -40,7 +40,7 @@ if TertiaryFreeNode == 0 || Extension < 2,  % this stem has long-range inter
     M(File.NT(i1).Code,File.NT(i1).Code) = 4;
     Node(n).SubsProb(:,:,K) = M / sum(sum(M));            % favor the observed base
 
-    if Verbose > 0,
+    if Verbose > 0
       fprintf('    Right strand conserved insertion %c%4s at right strand position %d\n', File.NT(i1).Base, File.NT(i1).Number, i);
     end
 
@@ -48,7 +48,7 @@ if TertiaryFreeNode == 0 || Extension < 2,  % this stem has long-range inter
 
   Node(n).Comment = [ ' // Hairpin node ' File.NT(a).Base File.NT(a).Number ':' File.NT(B).Base File.NT(B).Number];
 
-  if Verbose > 0,
+  if Verbose > 0
     fprintf('%3d Hairpin   %s:%s %s\n', n, File.NT(a).Number, File.NT(B).Number, cat(2,File.NT(MI).Base));
   end
 
@@ -61,7 +61,7 @@ else                                        % no long-range interactions
   % other program
 
   % --------------------------------------- % interaction between 1 and 3
-  
+
   Node(n).IBases      = [1 3];              % fixed bases 1 and 3 interact
 
   Node(n).InteractionComment{1} = [' // Hairpin on extensible stem ' File.NT(a).Number ' - ' File.NT(B).Number ' ' cat(2,File.NT(MI).Base)];
@@ -80,7 +80,7 @@ else                                        % no long-range interactions
   if Normalize == 1,
     Node(n).Insertion(1).LetterDist = [1 1 1 1]/4;
   else
-    Node(n).Insertion(1).LetterDist = [1 1 1 1];  
+    Node(n).Insertion(1).LetterDist = [1 1 1 1];
   end
   Node(n).InsertionComment{1} = ' // Insertion in vague hairpin';
 
@@ -105,30 +105,32 @@ if Verbose > 1,
   j = j(ii);
   e = e(ii);
 
-  if length(i) > 0,
+  if length(i) > 0
     fprintf('Hairpin has these long-range interactions: ===================\n');
-    for z = 1:length(i),
+    for z = 1:length(i)
       NT1 = File.NT(i(z));
       NT2 = File.NT(j(z));
       fprintf('Pair %s %s%5s_%s - %s%5s_%s %s\n', File.Filename, NT1.Base,NT1.Number,NT1.Chain,NT2.Base,NT2.Number,NT2.Chain, zEdgeText(File.Edge(i(z),j(z))));
     end
-  else
+  elseif Verbose > 1
     fprintf('Hairpin has no long-range interactions ***********************\n');
   end
 
   c = cat(1,File.NT(1:length(File.NT)).Center); % nucleotide centers
   cent = mean(c);
 
-  fprintf('Distance from center of molecule: %8.4f\n', norm(cent-File.NT(a).Center));
+  if Verbose > 1
+    fprintf('Distance from center of molecule: %8.4f\n', norm(cent-File.NT(a).Center));
+  end
 
-  if Verbose > 2,
+  if Verbose > 2
     fprintf('Press any key to continue\n');
     pause
   end
 end
 %Calculate normalization constant
 Node(n).InterIndices = Node(n).MiddleIndex(Node(n).IBases);
-if ~isempty(Node(n).InterIndices),
+if ~isempty(Node(n).InterIndices)
     Left = Node(n).MiddleIndex(1:length(Node(n).MiddleIndex)-1);
     Node(n).NormCons = pClusterNorm(Node(n).InterIndices,Node(n).SubsProb,Left,Node(n).RightIndex);
 else
diff --git a/matlab/pMakeNodesJunction.m b/matlab/pMakeNodesJunction.m
index 94a2549..c3700e9 100644
--- a/matlab/pMakeNodesJunction.m
+++ b/matlab/pMakeNodesJunction.m
@@ -1,253 +1,349 @@
-% pMakeNodesJunction identifies one or more junctions and make nodes for them
+% pMakeNodesJunction decides how to split up strands around a junction
+% and then makes a Node that splits off the first new branch
 
-C1 = full(sum(sum(H(r:r+jcdepth,t:t+jcdepth))));   % junction cluster 1-3
-C2 = full(sum(sum(H(r:r+jcdepth:u-jcdepth:u))));   % junction cluster 1-4
-C3 = full(sum(sum(H(s-jcdepth:s,t:t+jcdepth))));   % junction cluster 2-3
-C4 = full(sum(sum(H(s-jcdepth:s,u-jcdepth:u))));   % junction cluster 2-4
+% current position in the molecule is a on the left and B on the right
+r = a;                               % last index in the current strand before the junction
+rr= a;                               % start of current loop
 
-if C1+C2+C3+C4 > 0,
-% [C1 C2 C3 C4]
-  disp('Junction includes some nested pairs that will be removed.');
-end
-
-C1 = sum(sum(G(r:r+jcdepth,t:t+jcdepth)~=0));   % junction cluster 1-3
-C2 = sum(sum(G(r:r+jcdepth:u-jcdepth:u)~=0));   % junction cluster 1-4
-C3 = sum(sum(G(s-jcdepth:s,t:t+jcdepth)~=0));   % junction cluster 2-3
-C4 = sum(sum(G(s-jcdepth:s,u-jcdepth:u)~=0));   % junction cluster 2-4
-
-[i,j,k] = find(G(r:r+jcdepth,t:t+jcdepth));   % junction cluster 1-3
-kk = k;
-[i,j,k] = find(G(r:r+jcdepth:u-jcdepth:u));   % junction cluster 1-4
-kk = [kk; k];
-[i,j,k] = find(G(s-jcdepth:s,t:t+jcdepth));   % junction cluster 2-3
-kk = [kk; k];
-[i,j,k] = find(G(s-jcdepth:s,u-jcdepth:u));   % junction cluster 2-4
-kk = [kk; k];
+% this approach works for junction motifs, but not for junctions in molecules
+aaa = pNextTruncation(a,Truncate,N);
+BBB = pNextTruncation(B,Truncate,1);
 
-Node(1).JunctionDeletion = [Node(1).JunctionDeletion; kk];
+% next strand left, next strand right
+[NSL,NSR] = pNextStrands(a,B,Truncate,N);
 
-if Verbose > 1,
-  full([C1 C2 C3 C4])
+% find last nt on next strand left that interacts with current left strand
+s = NSL(end);
+while sum(sum(G(s,a:aaa))) == 0 && s > NSL(1)
+  s = s - 1;
 end
 
-      % ------------------ Remove junction clusters --------------------
-      % Note:  this is only happening between the two loops identified so
-      % far, but there may be more loops, and between them these interactions
-      % are not being removed!  Maybe this is not actually a problem.
-      % The little study above tells me that in E. coli 16S, no nested pairs
-      % were removed by this.
-
-      if C1 > 0,
-        G(r:r+jcdepth,t:t+jcdepth) = 0*G(r:r+jcdepth,t:t+jcdepth);
-      end
-      if C2 > 0,
-        G(r:r+jcdepth:u-jcdepth:u) = 0*G(r:r+jcdepth:u-jcdepth:u);
-      end
-      if C3 > 0,
-        G(s-jcdepth:s,t:t+jcdepth) = 0*G(s-jcdepth:s,t:t+jcdepth);
-      end
-      if C4 > 0,
-        G(s-jcdepth:s,u-jcdepth:u) = 0*G(s-jcdepth:s,u-jcdepth:u);
-      end
-
-      C1 = full(sum(sum(G(r:r+jcdepth,t:t+jcdepth))));   % junction cluster 1-3
-      C2 = full(sum(sum(G(r:r+jcdepth:u-jcdepth:u))));   % junction cluster 1-4
-      C3 = full(sum(sum(G(s-jcdepth:s,t:t+jcdepth))));   % junction cluster 2-3
-      C4 = full(sum(sum(G(s-jcdepth:s,u-jcdepth:u))));   % junction cluster 2-4
-
-      if C1+C2+C3+C4 == 0,                  % no interaction across junction
-
-        junc = [];                          % indices where loops start & end
-
-        while (sum(sum(H((r+1):(s-1),(r+1):(s-1)) > 0)) > 0) && ...
-              (sum(sum(H((s+1):(u),(s+1):(u)) > 0)) > 0),  % still two loops
-
-          % probe for start of next block of nested pairs, 
-          % s+1 to t-1 is junction strand
-          while sum(H(t,(t+1):B) > 0) == 0 && t < u,
-                                         % if t does not make a nested pair,
-            t = t + 1;
-          end
-
-          % decide which loop gets the strand between the loops
-          % these are the indices that it could interact with in a cluster
-
-          rrr = unique([rr:min(r+cdepth,s) max(rr,s-cdepth):s]);
-          ttt = unique([t:min(t+cdepth,u) max(Interact{t}.Index(1)-cdepth,t):u]);
-
-          % here the criterion is simple, just choose whichever has the
-          % larger number of interactions.  But it would be better yet to
-          % split the loop, as with 556:567 in 2avy
-
-          if sum(sum(G(rrr,(s+1):(t-1))>0)) >= sum(sum(G((s+1):(t-1),ttt))),
-            junc = [junc; [rr t-1]];           % store limits of this loop
-          else
-            junc = [junc; [rr s]];
-          end
-
-          r  = junc(end,2) + 1;           % NT after the first loop ends
-          rr = r;                         % copy of that, for probing forward
-          s  = Interact{t}.Index(1);      % the far side of the next loop
-          t  = s + 1;                     % one beyond that
-        end
-
-        junc = [junc; [r u]];             % store limits of this last loop
-
-        NL = length(junc(:,1));             % number of loops
-
-        id = fix(10000*rand);
-
-        if Verbose > 0,
+t = min([s+1 NSL(end) B]);           % next after that, keep it in range
+u = B;                               % end of current known loop
 
-%[File.NT(a).Number ' ' File.NT(b).Number ' ' File.NT(B).Number]
-
-          fprintf('\nJunction with %d loops, call it J%d\n', NL,id);
-          for ln = 1:NL,
-            fprintf('Actual loop %d of junction J%d - Nucleotides %5s_%s to %5s_%s, length %3d\n',ln,id,File.NT(junc(ln,1)).Number,File.NT(junc(ln,1)).Chain,File.NT(junc(ln,2)).Number,File.NT(junc(ln,2)).Chain,junc(ln,2)+1-junc(ln,1));
-          end
-        end
-  
-        n = n+1;                              % move to next node
-        Node(n).type       = 'Junction';      % junction with no cluster
-        Node(n).LeftIndex  = a;
-        Node(n).RightIndex = B;
-        Node(n).NumLoops   = 2;
-        Node(n).id         = ['J' num2str(id)];
-
-if Verbose > 0,
-  fprintf('%3d Junction\n', n);
+if Verbose > 0
+    fprintf('pMakeNodesJunction: a=%s r=%s s=%s t=%s u=B=%s\n', File.NT(a).ID, File.NT(r).ID, File.NT(s).ID, File.NT(t).ID, File.NT(B).ID);
+    fprintf('pMakeNodesJunction: a:s count %d\n', full(sum(sum(CanonicalcWW(r:s,r:s)==1))));
+    fprintf('pMakeNodesJunction: t:B count %d\n', full(sum(sum(CanonicalcWW(t:u,t:u)==1))));
 end
 
-        jn = n;                               % index of this node
-
-        if NL == 2,                           % exactly two branches,
-
-         for ln = 1:NL,
-          if Verbose > 0,
-            fprintf('\n');
-            fprintf('Loop %d of %d of junction J%d - Nucleotides %5s to %5s, length %3d\n',ln,NL,id,File.NT(junc(ln,1)).Number,File.NT(junc(ln,2)).Number,junc(ln,2)+1-junc(ln,1));
-          end
-          nn = length(Node) + 1;
-          Node(jn).nextnode(ln) =  length(Node)+1;
-          Node = pMakeNodes(File,Param,junc(ln,1),junc(ln,2),Truncate,Data,Node,n);
-          Node(nn).id         = ['J' num2str(id)];
-          n = length(Node);
-         end
-
-        elseif NL > 2                           % more than two branches
-
-          NN = ceil(NL/2);                      % # branches for 1st child
-
-          if Verbose > 0,
-            fprintf('\n');
-            fprintf('Loop %d of %d of junction J%d - Nucleotides %5s to %5s, length %3d\n',1,2,id,File.NT(junc(1,1)).Number,File.NT(junc(NN,2)).Number,junc(NN,2)+1-junc(1,1));
-          end
-
-          nn = length(Node) + 1;
-          Node(jn).nextnode(1) = length(Node) + 1;
-          Node = pMakeNodes(File,Param,junc(1,1),junc(NN,2),Truncate,Data,Node,n);
-          Node(nn).id         = ['J' num2str(id)];
-          n = length(Node);
-
-          if Verbose > 0,
-            fprintf('\n');
-            fprintf('Loop %d of %d of junction J%d - Nucleotides %5s to %5s, length %3d\n',2,2,id,File.NT(junc(NN+1,1)).Number,File.NT(junc(NL,2)).Number,junc(NL,2)+1-junc(NN+1,1));
-          end
-
-          nn = length(Node) + 1;
-          Node(jn).nextnode(2) = length(Node) + 1;
-          Node = pMakeNodes(File,Param,junc(NN+1,1),junc(NL,2),Truncate,Data,Node,n);
-          Node(nn).id         = ['J' num2str(id)];
-
-        end
+% if length(Truncate) > 1 && (sum(sum(CanonicalcWW(r:s,r:s)==1)) > 0) && (sum(sum(CanonicalcWW(t:u,t:u)==1)) > 0)
+% not modeling an IL or HL and ...
+% there are nested canonical cWW pairs between r and s and between t and u
+% use cWW pairs to avoid pairs between i and i+1 making junctions
 
-        Node(n).Comment = ['// Junction node ' File.NT(Node(n).LeftIndex).Base File.NT(Node(n).LeftIndex).Number ' - ' File.NT(Node(n).RightIndex).Base File.NT(Node(n).RightIndex).Number ' ID ' Node(n).id];
-
-      else                                      % two-loop junction cluster
-
-        % find extent of interactions between loops
-
-        t = b;
-
-        rr = r + jcdepth;
-        while (sum(G(rr,[t:t+jcdepth u-jcdepth:u])) == 0) && (rr > r),
-          rr = rr - 1;
-        end
-
-        ss = s - jcdepth;
-        while (sum(G(ss,[t:t+jcdepth u-jcdepth:u])) == 0) && (ss < s),
-          ss = ss + 1;
-        end
+if Verbose > 0
+    fprintf('pMakeNodesJunction: Found nested interactions between %s and %s and between %s and %s\n', File.NT(r).ID, File.NT(s).ID, File.NT(t).ID, File.NT(u).ID);
+    fprintf('pMakeNodesJunction: about to make a junction: a=%s s=%s t=%s B=%s\n', File.NT(a).ID, File.NT(s).ID, File.NT(t).ID, File.NT(B).ID);
+end
 
-        tt = t + jcdepth;
-        while (sum(G([r:r+jcdepth s-jcdepth:s],tt)) == 0) && (tt > t),
-          tt = tt - 1;
-        end
+jcdepth = 5;   % how far to look for junction clusters ... which don't exist
 
-        uu = u - jcdepth;
-        while (sum(G([r:r+jcdepth s-jcdepth:s],uu)) == 0) && (uu < u),
-          uu = uu + 1;
-        end
+fprintf('pMakeNodesJunction: first branch starts at   %s\n', File.NT(r).ID);
+fprintf('pMakeNodesJunction: first branch ends around %s\n', File.NT(s).ID);
+fprintf('pMakeNodesJunction: second branch starts at  %s\n', File.NT(t).ID);
+fprintf('pMakeNodesJunction: junction ends at         %s\n', File.NT(u).ID);
 
-        % second, extent of additional interactions within loops
+rplus  = min([r+jcdepth s-1 pNextTruncation(r,Truncate,N)]);  % how far to look on the strand past r
+sminus = max([s-jcdepth r+1 pNextTruncation(s,Truncate,1)]);  % how far to look on the strand before s
+tplus  = min([t+jcdepth u-1 pNextTruncation(t,Truncate,N)]);  % how far to look on the strand past t
+uminus = max([u-jcdepth t+1 pNextTruncation(u,Truncate,1)]);  % how far to look on the strand before u
 
-        rrr = r + jcdepth;
-        while (sum(G(rrr,[r:rr ss:s])) == 0) && (rrr > rr),
-          rrr = rrr - 1;
-        end
+fprintf('pMakeNodesJunction: first branch strand start goes up to  %s\n', File.NT(rplus).ID);
+fprintf('pMakeNodesJunction: first branch strand end goes down to  %s\n', File.NT(sminus).ID);
+fprintf('pMakeNodesJunction: second branch strand start goes up to %s\n', File.NT(tplus).ID);
+fprintf('pMakeNodesJunction: last strand of junction goes down to  %s\n', File.NT(uminus).ID);
 
-        sss = s - jcdepth;
-        while (sum(G(sss,[r:rr ss:s])) == 0) && (sss < ss),
-          sss = sss + 1;
-        end
+% count interactions beyond r and s that would cross the junction
+C1 = full(sum(sum(H(r:rplus,t:tplus))));   % junction strands  1-3
+C2 = full(sum(sum(H(r:rplus,uminus:u))));   % junction strands  1-4
+C3 = full(sum(sum(H(sminus:s,t:tplus))));   % junction strands  2-3
+C4 = full(sum(sum(H(sminus:s,uminus:u))));   % junction strands  2-4
 
-        ttt = t + jcdepth;
-        while (sum(G([t:tt uu:u],ttt)) == 0) && (ttt > tt),
-          ttt = ttt - 1;
-        end
+if C1+C2+C3+C4 > 0 && Verbose > 0
+  disp('pMakeNodesJunction: Junction includes some crossing pairs that will be lost. C1, C2, C3, C4:');
+  disp([C1 C2 C3 C4])
+end
 
-        uuu = u - jcdepth;
-        while (sum(G([t:tt uu:u],uuu)) == 0) && (uuu < uu),
-          uuu = uuu + 1;
-        end
+% [i,j,k] = find(G(r:rplus,t:tplus));   % junction strands  1-3
+% kk = k;
+% [i,j,k] = find(G(r:rplus,uminus:u));   % junction strands  1-4
+% kk = [kk; k];
+% [i,j,k] = find(G(sminus:s,t:tplus));   % junction strands  2-3
+% kk = [kk; k];
+% [i,j,k] = find(G(sminus:s,uminus:u));   % junction strands  2-4
+% kk = [kk; k];
+
+% Node(1).JunctionDeletion = [Node(1).JunctionDeletion; kk];
+
+% if Verbose > 1
+%   disp('pMakeNodesJunction: This is how many basepairs are being lost to simplify the junction:');
+%   disp(full([C1 C2 C3 C4]))
+% end
+
+% ----- Remove interactions that require junction cluster node -----
+% Because those have not been developed yet
+% Note:  this is only happening between the two loops identified so
+% far, but there may be more loops, and between them these interactions
+% are not being removed!  Maybe this is not actually a problem.
+% A little study tells me that in E. coli 16S, no nested pairs
+% were removed by this.
+
+if 0 > 1
+  if C1 > 0
+    G(r:rplus,t:tplus) = 0*G(r:rplus,t:tplus);
+  end
+  if C2 > 0
+    G(r:rplus,uminus:u) = 0*G(r:rplus,uminus:u);
+  end
+  if C3 > 0
+    G(sminus:s,t:tplus) = 0*G(sminus:s,t:tplus);
+  end
+  if C4 > 0
+    G(sminus:s,uminus:u) = 0*G(sminus:s,uminus:u);
+  end
+
+  C1 = full(sum(sum(G(r:rplus,t:tplus))));   % junction strands  1-3
+  C2 = full(sum(sum(G(r:rplus,uminus:u))));   % junction strands  1-4
+  C3 = full(sum(sum(G(sminus:s,t:tplus))));   % junction strands  2-3
+  C4 = full(sum(sum(G(sminus:s,uminus:u))));   % junction strands  2-4
+end
 
-        n = n + 1;
-        Node(n).type        = 'JunctionCluster';  % 
-        Node(n).LeftIndex   = [r:rrr];
-        Node(n).MiddleIndex = [sss:ttt];
-        Node(n).RightIndex  = [uuu:u];
+% probably we can just build the junction without zeroing out anything
+C1 = 0;
+C2 = 0;
+C3 = 0;
+C4 = 0;
+
+if C1+C2+C3+C4 == 0        % no interaction across junction, so it's a plain junction
+  % r to s will form one branch, t to u will form the others and they can be split further later
+
+  junc = [];              % each row tells indices where branches start and end
+
+  junc = [[r s]; [t u]];
+
+  % note below, r+1 might equal s, then this would not be what you want
+  % identify all of the branches coming off this junction,
+  % each starts at r and ends at s, which keep changing as you go to the next branch
+
+  % previously this was used to split up the junction
+  % but now we may already have a good method
+  branchesRemain = 0;
+  while branchesRemain
+  % while (r < pNextTruncation(r,Truncate,N)) && ...
+  %       (s > pNextTruncation(s,Truncate,1)) && ...
+  %       (sum(sum(H((r+1):(s-1),(r+1):(s-1)) > 0)) > 0) && ...
+  %       (sum(sum(H((s+1):(u),(s+1):(u)) > 0)) > 0)
+
+    % probe for start of next block of nested pairs,
+    % s+1 to t-1 is a strand of the junction
+    tStrandEnd = pNextTruncation(t,Truncate,N);
+    while sum(H(t,(t+1):B) > 0) == 0 && t < u && t < tStrandEnd
+      % if t does not make a nested pair later in this junction
+      t = t + 1;
+    end
+
+    fprintf('pMakeNodesJunction: first branch could end as late as %s\n', File.NT(t-1).ID);
+
+    tPartner = Interact{t}.Index(1);  % this had better be after t!
+    if tPartner <= t
+      fprintf('!!!!!!!!!!! tPartner is not after t, but %s\n', File.NT(tPartner).ID);
+    end
+
+    % decide how to split the strand between s and t between the branches
+
+    % Note: rr is defined to equal a before pMakeNodesJunction is called!
+    currentBranch = unique([rr:min(r+cdepth,s) max(rr,s-cdepth):s]); % indices of the current branch
+    nextBranch = unique([t:min(t+cdepth,u) max(tPartner-cdepth,t):u]); % indices of the next branch
+
+    % choose whichever endpoint has the larger number of interactions.
+    % But it would be better yet to split the stand optimally, as with 556:567 in 2avy
+
+    if sum(sum(G(currentBranch,(s+1):(t-1))>0)) >= sum(sum(G((s+1):(t-1),nextBranch))),
+      % append start and end of the current branch to junc
+      junc = [junc; [rr t-1]];      % current branch includes entire next strand
+      r = t;
+    else
+      % append start and end of the current branch to junc
+      junc = [junc; [rr s]];        % current branch ends at s
+      r = s+1;
+    end
+
+    if Verbose > 0
+      st = junc(end,1);         % start of this branch
+      en = junc(end,2);         % end of this branch
+      fprintf('Junction branch starts at %s ends at %s\n', File.NT(st).ID, File.NT(en).ID);
+    end
+
+    rr = r;                         % copy of r, for probing forward
+    s  = Interact{t}.Index(1);      % the far side of the next branch
+    t  = s + 1;                     % one position beyond s
+
+    % I did not think about the next line, it is a gift from co-pilot
+    if rr >= s || t > u || t > B || s > B || rr > B
+      branchesRemain = 0;          % no more branches to find
+    end
+    junc = [junc; [r u]];             % append limits of this last branch
+
+  end
+
+  NL = length(junc(:,1));           % number of branches = number of rows appended
+
+  id = fix(10000*rand);             % random id for large structures with many junctions
+
+  if Verbose > 0
+    fprintf('\nJunction with %d loops, call it J%d\n', NL,id);
+    for ln = 1:NL
+      fprintf('Actual Branch %d of junction J%d - Nucleotides %s to %s, length %3d\n',ln,id,File.NT(junc(ln,1)).ID,File.NT(junc(ln,2)).ID,junc(ln,2)+1-junc(ln,1));
+    end
+  end
+
+  n = n+1;                              % move to next node
+  Node(n).type       = 'Junction';      % junction node
+  Node(n).LeftIndex  = a;
+  Node(n).RightIndex = B;
+  Node(n).NumLoops   = NL;              % not sure about this
+  Node(n).id         = ['J' num2str(id)];
+  Node(n).Comment = ['// Junction node ' File.NT(Node(n).LeftIndex).Base File.NT(Node(n).LeftIndex).Number ' - ' File.NT(Node(n).RightIndex).Base File.NT(Node(n).RightIndex).Number ' ID ' Node(n).id];
+
+  if Verbose > 0
+    fprintf('%3d Junction\n', n);
+  end
+
+  jn = n;                               % index of this node
+
+  if NL == 2                            % exactly two branches,
+
+    Node(jn).numbranches = 2;           % more reliable than tracking length(nextnode)
+    for ln = 1:NL
+      if Verbose > 0
+        fprintf('\n');
+        fprintf('2B Branch %d of %d of junction J%d - Nucleotides %5s to %5s, length %3d\n',ln,NL,id,File.NT(junc(ln,1)).Number,File.NT(junc(ln,2)).Number,junc(ln,2)+1-junc(ln,1));
+      end
+      nn = length(Node) + 1;
+      Node(jn).nextnode(ln) =  length(Node)+1;
+      Node = pMakeNodes(File,Param,junc(ln,1),junc(ln,2),Truncate,Data,Node,n);
+      Node(nn).id         = ['J' num2str(id)];
+      n = length(Node);
+    end
+
+  elseif NL > 2                           % more than two branches
+
+    NN = ceil(NL/2);                      % # branches for 1st child
+
+    if Verbose > 0
+      fprintf('\n');
+      fprintf('Branch %d of %d of junction J%d - Nucleotides %5s to %5s, length %3d\n',1,2,id,File.NT(junc(1,1)).Number,File.NT(junc(NN,2)).Number,junc(NN,2)+1-junc(1,1));
+    end
+
+    nn = length(Node) + 1;
+    Node(jn).nextnode(1) = length(Node) + 1;
+    Node = pMakeNodes(File,Param,junc(1,1),junc(NN,2),Truncate,Data,Node,n);
+    Node(nn).id         = ['J' num2str(id)];
+    n = length(Node);
+
+    if Verbose > 0
+      fprintf('\n');
+      fprintf('Branch %d of %d of junction J%d - Nucleotides %5s to %5s, length %3d\n',2,2,id,File.NT(junc(NN+1,1)).Number,File.NT(junc(NL,2)).Number,junc(NL,2)+1-junc(NN+1,1));
+    end
+
+    % collect all remaining branches and process, maybe with a new junction
+    % that way, each junction node only has two branches and life is simpler
+    nn = length(Node) + 1;
+    Node(jn).nextnode(2) = length(Node) + 1;
+    Node = pMakeNodes(File,Param,junc(NN+1,1),junc(NL,2),Truncate,Data,Node,n);
+    Node(nn).id         = ['J' num2str(id)];
+    Node(jn).numbranches = length(Node(jn.nextnode));
+
+  end
+
+  % Node(n).Comment = ['// Junction node ' File.NT(Node(n).LeftIndex).Base File.NT(Node(n).LeftIndex).Number ' - ' File.NT(Node(n).RightIndex).Base File.NT(Node(n).RightIndex).Number ' ID ' Node(n).id];
+
+else
+
+  % find extent of interactions between loops
+
+  t = b;
+
+  rr = r + jcdepth;
+  while (sum(G(rr,[t:tplus uminus:u])) == 0) && (rr > r),
+    rr = rr - 1;
+  end
+
+  ss = s - jcdepth;
+  while (sum(G(ss,[t:tplus uminus:u])) == 0) && (ss < s),
+    ss = ss + 1;
+  end
+
+  tt = t + jcdepth;
+  while (sum(G([r:rplus sminus:s],tt)) == 0) && (tt > t),
+    tt = tt - 1;
+  end
+
+  uu = u - jcdepth;
+  while (sum(G([r:rplus sminus:s],uu)) == 0) && (uu < u),
+    uu = uu + 1;
+  end
+
+  % second, extent of additional interactions within loops
+
+  currentBranch = r + jcdepth;
+  while (sum(G(currentBranch,[r:rr ss:s])) == 0) && (currentBranch > rr),
+    currentBranch = currentBranch - 1;
+  end
+
+  sss = s - jcdepth;
+  while (sum(G(sss,[r:rr ss:s])) == 0) && (sss < ss),
+    sss = sss + 1;
+  end
+
+  nextBranch = t + jcdepth;
+  while (sum(G([t:tt uu:u],nextBranch)) == 0) && (nextBranch > tt),
+    nextBranch = nextBranch - 1;
+  end
+
+  uuu = u - jcdepth;
+  while (sum(G([t:tt uu:u],uuu)) == 0) && (uuu < uu),
+    uuu = uuu + 1;
+  end
+
+  n = n + 1;
+  Node(n).type        = 'JunctionCluster';  %
+  Node(n).LeftIndex   = [r:currentBranch];
+  Node(n).MiddleIndex = [sss:nextBranch];
+  Node(n).RightIndex  = [uuu:u];
 
 %        Node(n).Left(1,:)   = union(zs,xs);
 %        Node(n).Middle(1,:) = fliplr(union(zt,yt)); % correct?
 %        Node(n).Right(1,:)  = fliplr(union(zt,yt)); % correct?
 
-        Node(n).LIP = [1];
-        Node(n).MIP = [1];
-        Node(n).RIP = [1];
+  Node(n).LIP = [1];
+  Node(n).MIP = [1];
+  Node(n).RIP = [1];
+
+  % add additional insertion combinations and probabilities here!
+  % add scores for the various basepairs here!
 
-        % add additional insertion combinations and probabilities here!
-        % add scores for the various basepairs here!
+  if Verbose > 0,
+    fprintf('%3d Junction Cluster %4s %4s %4s %4s %4s %4s\n', n, File.NT(r).Number, File.NT(currentBranch).Number, File.NT(sss).Number, File.NT(nextBranch).Number, File.NT(uuu).Number, File.NT(u).Number);
+    fprintf('================================================================================================================\n');
+  end
 
-        if Verbose > 0,
-          fprintf('%3d Junction Cluster %4s %4s %4s %4s %4s %4s\n', n, File.NT(r).Number, File.NT(rrr).Number, File.NT(sss).Number, File.NT(ttt).Number, File.NT(uuu).Number, File.NT(u).Number);
-          fprintf('================================================================================================================\n');
-        end
+  r = currentBranch;
+  s = sss;
+  t = nextBranch;
+  u = uuu;
 
-        r = rrr;
-        s = sss;
-        t = ttt;
-        u = uuu;
+  Node(n).nextnode(1) =  n+1;          % index of next node in tree
+  Node = pMakeNodes(File,Param,r,s,Truncate,Data,Node,n);
 
-        Node(n).nextnode(1) =  n+1;          % index of next node in tree
-        Node = pMakeNodes(File,Param,r,s,Truncate,Data,Node,n);
+  Node(n).nextnode(2)  = length(Node)+1;
+  Node = pMakeNodes(File,Param,t,u,Truncate,Data,Node,length(Node));
+end                                  % junction cluster
 
-        Node(n).nextnode(2)  = length(Node)+1;
-        Node = pMakeNodes(File,Param,t,u,Truncate,Data,Node,length(Node));
-      end                                  % junction cluster
+Node(n).P    = [0.05*ones(17,1) 0.95*ones(17,1)]; % state to state transitions
 
-      Node(n).P    = [0.05*ones(17,1) 0.95*ones(17,1)];
-                                            % state to state transitions
-      Node(n).PIns = [0.05 0.95];   % when no previous state
+Node(n).PIns = [0.05 0.95];   % when no previous state
 
-      EndLoop = 1;
+EndLoop = 1;
 
diff --git a/matlab/pMakeNodesProbeForInsertions.m b/matlab/pMakeNodesProbeForInsertions.m
index 40551b6..254cb07 100644
--- a/matlab/pMakeNodesProbeForInsertions.m
+++ b/matlab/pMakeNodesProbeForInsertions.m
@@ -1,199 +1,231 @@
 % probe for insertions on left and right strands, set insertion probabilities
+% if current node is a cluster, always insert an initial node after that
+% there should be no interaction between a and B
 
-  Node(n).newfield = 'hello';
+aa = a;                                  % initial location on left strand
+BB = B;                                  % initial location on right strand
 
-aa = a;                                  % initial values of these
-BB = B;
+movea = 1;                               % plan to advance a until we see a reason not to
+moveB = 1;
 
-LeftIns  = 0;                            % number of insertions on the left
-RightIns = 0;                            % number of insertions on the right
+if pStrandBreaksBetween(a,B,Truncate) > 1
+  % there is a junction ahead, don't skip ahead super greedily
+  % this section is for junction motifs, not for entire molecules
 
-% ---------------------------------------- Carefully written probing algorithm!
-% ---------------------------------------- Easy insertions on the left
+  % indices of last nucleotides on current left and right strands
+  aaa = pNextTruncation(a,Truncate,N);
+  BBB = pNextTruncation(B,Truncate,1);
 
-while sum(sum(G(a,a:B))) == 0,          % a makes no interactions w/in loop
-  if Verbose > 0,
-    fprintf('    Insertion %4s      %s\n', File.NT(a).Number, File.NT(a).Base);
-  end
-  a = a + 1;
-  LeftIns = LeftIns + 1;
-end
+  % nucleotides on next strand(s) (NSL and NSR are the same for J3)
+  [NSL,NSR] = pNextStrands(a,B,Truncate,N);
 
-% ---------------------------------------- Easy insertions on the right
-
-while sum(sum(G(a:B,B))) == 0,          % B makes no interactions w/in loop
-  if Verbose > 0,
-    fprintf('    Insertion      %4s %s\n', File.NT(B).Number, File.NT(B).Base);
+  while movea == 1
+    if a == aaa
+      % reached the end of this strand
+      movea = 0;
+    elseif sum(sum(H(a,NSL))) > sum(sum(H(a,BBB:B)))
+      % more interactions with NSL than right strand, stop
+      movea = 0;
+    elseif sum(sum(H(a,BBB:B))) == 0 && sum(sum(H(a,(a+1):aaa))) == 0
+      % a makes no interactions
+      fprintf('    Insertion on left  %s\n', File.NT(a).ID);
+      a = a + 1;
+    else
+      movea = 0;
+    end
   end
-  RightIns = RightIns + 1;         % increase mean number of insertions
-  B = B - 1;                               % next base on right
-end
 
-% ['Done with easy insertions ' File.NT(a).Number ' ' File.NT(B).Number]
+  while moveB == 1
+    if B == BBB
+      % reached the end of this strand
+      moveB = 0;
+    elseif sum(sum(H(B,NSR))) > sum(sum(H(B,a:aaa)))
+      % more interactions with NSL than right strand, stop
+      moveB = 0;
+    elseif sum(sum(H(B,a:aaa))) == 0 && sum(sum(H(B,BBB:(B-1)))) == 0
+      % B makes no interactions
+      fprintf('    Insertion on right %s\n', File.NT(B).ID);
+      B = B - 1;
+    else
+      moveB = 0;
+    end
+  end
 
-% ---------------------------------------- a interacts, but skip anyway?
+else
+  % HL and IL probing
+  % ---------------------------------------- Carefully written probing algorithm!
+  %                                          Appropriate for HL and IL
+  [aaa,BBB] = pNextNucleotides(a,B,Truncate,N,cdepth);
+
+  % ---------------------------------------- Easy insertions on the left
+  while sum(sum(H(a,a:B))) == 0 && a < aaa   % a makes no basepairs w/in loop
+    if Verbose > 0
+      fprintf('    Insertion on left  %s\n', File.NT(a).ID);
+    end
+    a = a + 1;
+  end
 
-aaa = min([length(File.NT) a+cdepth floor((a+B)/2)]);
-LS  = (a+1):aaa;                           % left strand not including a
-BBB = max([1 B-cdepth floor((a+B)/2)+1]);  % how far down right strand to look
-RS  = BBB:B;                               % right strand including B
-aB  = a:B;                                 % indices from a to B
-na  = find(H(a,aB));                       % nested interaction(s) a makes
-nB  = find(H(B,aB));                       % nested interaction(s) B makes
+  % ---------------------------------------- Easy insertions on the right
+  while sum(sum(H(a:B,B))) == 0 && B > BBB   % B makes no basepairs w/in loop
+    if Verbose > 0
+      fprintf('    Insertion on right %s\n', File.NT(B).ID);
+    end
+    B = B - 1;                               % next base on right
+  end
 
-if ~isempty(na),
-%  ['a interacts with ' File.NT(aB(max(na))).Number]
-end
+  % ---------------------------------------- a interacts, but skip anyway?
+  LS  = (a+1):aaa;                           % left strand not including a
+  RS  = BBB:B;                               % right strand including B
+  aB  = a:B;                                 % indices from a to B
+  na  = find(H(a,aB));                       % nested interaction(s) a makes
+  nB  = find(H(B,aB));                       % nested interaction(s) B makes
 
-if isempty(na),                             % a makes no nested interactions
-  movea = 1;
-elseif sum(sum(H((a+1):aB(max(na)),(a+1):(aB(max(na)))))) > 0, % 
-  movea = 0;
-%  disp('Found that the interaction a makes contains a stem');
-elseif ~isempty(nB),                        % B makes a nested interaction
-  if min(abs(nonzeros(G(a,aB(na))))) < min(abs(nonzeros(G(B,aB(nB))))),
-    movea = 0;                              % a makes a more important one
-%    disp('Both a and B make nested interactions, but a makes a more important one');
-  else
-    movea = 1;                              % B makes a more important one
+  if ~isempty(na) && Verbose > 0
+    fprintf('pMakeNodesProbeForInsertions:  a %s interacts with %s\n', File.NT(a).ID, File.NT(aB(max(na))).ID);
   end
-elseif any(abs(G(a,aB(na)))==1),
-  movea = 0;
-else
-  movea = 1;
-end
-
-%movea
-%full(nonzeros(abs(G(a,aB))))
-%full(nonzeros(abs(G(B,aB))))
 
-while sum(abs(G(a,[LS RS]))) == 0 && movea == 1,
-                                        % no interaction w/in this loop
-  if Verbose > 0,
-    fprintf('    Insertion %4s      %s\n', File.NT(a).Number, File.NT(a).Base);
+  if ~isempty(nB) && Verbose > 0
+    fprintf('pMakeNodesProbeForInsertions:  B %s interacts with %s\n', File.NT(B).ID, File.NT(aB(min(nB))).ID);
   end
-  LeftIns = LeftIns + 1;           % increase mean number of insertions
-  a = a + 1;                              % next base on left
-  aaa = min([length(File.NT) a+cdepth floor((a+B)/2)]);
-  BBB = max([1 B-cdepth floor((a+B)/2)+1]);% how far down right strand to look
-  LS  = (a+1):aaa;                        % left strand
-  RS  = BBB:B;                            % right strand
-  aB  = a:B;                            % indices from a to B
-  na  = find(H(a,aB));                       % nested interaction(s) a makes
-  nB  = find(H(B,aB));                       % nested interaction(s) B makes
 
-  if isempty(na),                             % a makes no nested interactions
-    movea = 1;
-  elseif sum(sum(H((a+1):aB(max(na)),(a+1):(aB(max(na)))))) > 0, % 
+  if a == aaa
+    % reached the end of the strand
     movea = 0;
-%    disp('Found that the interaction a makes contains a stem');
-  elseif ~isempty(nB),                        % B makes a nested interaction
-    if min(abs(nonzeros(G(a,aB(na))))) < min(abs(nonzeros(G(B,aB(nB))))),
-      movea = 0;
-%      disp('Both a and B make nested interactions, but a makes a more important one');
+  elseif sum(sum(H((a+1):aB(max(na)),(a+1):(aB(max(na)))))) > 0
+    % after a and up to the last interaction partner of a, there are basepairs
+    % that will always happen in an IL if a makes a basepair with the other strand
+    movea = 0;
+    if Verbose > 0
+      disp('pMakeNodesProbeForInsertions:  Found that the interaction a makes contains a stem');
     end
-  elseif any(abs(G(a,aB(na)))==1),
+  elseif ~isempty(nB)                         % B makes a nested interaction
+    if min(abs(nonzeros(G(a,aB(na))))) < min(abs(nonzeros(G(B,aB(nB)))))
+      movea = 0;                              % a makes a more important one
+      if Verbose > 0
+        disp('pMakeNodesProbeForInsertions:  Both a and B make nested interactions, but a makes a more important one');
+      end
+    else
+      movea = 1;                              % B makes a more important one
+      if Verbose > 0
+        disp('pMakeNodesProbeForInsertions:  Both a and B make nested interactions, but B makes a more important one');
+      end
+    end
+  elseif any(abs(G(a,aB(na)))==1)
+    % a makes a cWW with something up to B
     movea = 0;
-  else
-    movea = 1;
   end
 
-%movea
-%abs(G(a,aB))
-%abs(G(B,aB))
-
-end
-
-%['Moved a ' File.NT(a).Number ' ' File.NT(B).Number]
-
-% ---------------------------------------- Easy insertions on the right
-
-while sum(sum(G(a:B,B))) == 0,          % B makes no interactions w/in loop
-  if Verbose > 0,
-    fprintf('    Insertion      %4s %s\n', File.NT(B).Number, File.NT(B).Base);
+  % accumulate interactions on the left
+  % could just set movea = 1 and check the conditions at the start of the while loop
+  while sum(abs(G(a,[LS RS]))) == 0 && movea == 1
+                                          % no interaction w/in this loop
+    if Verbose > 0
+      fprintf('    Insertion on left$ %s\n', File.NT(a).ID);
+    end
+    a = a + 1;                              % next base on left
+    [aaa,BBB] = pNextNucleotides(a,B,Truncate,N,cdepth);
+    LS  = (a+1):aaa;                        % left strand
+    RS  = BBB:B;                            % right strand
+    aB  = a:B;                              % indices from a to B
+    na  = find(H(a,aB));                       % nested interaction(s) a makes
+    nB  = find(H(B,aB));                       % nested interaction(s) B makes
+
+    if a == aaa
+      % reached the end of the strand
+      movea = 0;
+    elseif sum(sum(H((a+1):aB(max(na)),(a+1):(aB(max(na)))))) > 0
+      movea = 0;
+    elseif ~isempty(nB)                        % B makes a nested interaction
+      if min(abs(nonzeros(G(a,aB(na))))) < min(abs(nonzeros(G(B,aB(nB)))))
+        movea = 0;
+      end
+    elseif any(abs(G(a,aB(na)))==1)
+      movea = 0;
+    end
   end
-  RightIns = RightIns + 1;         % increase mean number of insertions
-  B = B - 1;                               % next base on right
-end
 
-% --------------------------------------- B interacts, but skip anyway?
+  % ---------------------------------------- More easy insertions on the right
 
-aaa = min([length(File.NT) a+cdepth floor((a+B)/2)]);
-LS  = a:aaa;                            % left strand including a
-BBB = max([1 B-cdepth floor((a+B)/2)+1]);  % how far down right strand to look
-RS  = BBB:(B-1);                        % right strand not including B
-aB  = a:B;                              % indices from a to B
-na  = find(H(a,aB));                       % nested interaction(s) a makes
-nB  = find(H(B,aB));                       % nested interaction(s) B makes
-
-if ~isempty(nB),
-%  ['B interacts with ' File.NT(aB(max(nB))).Number]
-end
-
-if isempty(nB),                             % a makes no nested interactions
-  moveB = 1;
-elseif sum(sum(H(aB(min(nB)):(B-1),aB(min(nB)):(B-1)))) > 0, % 
-  moveB = 0;
-%  disp('Found that the interaction B makes contains a stem');
-elseif ~isempty(nB),                        % B makes a nested interaction
-  if min(abs(nonzeros(G(B,aB(nB))))) < min(abs(nonzeros(G(a,aB(na))))),
-    moveB = 0;
-%    disp('Both a and B make nested interactions, but B makes a more important one');
+  while sum(sum(G(a:B,B))) == 0 && B > BBB   % B makes no interactions w/in loop
+    if Verbose > 0
+      fprintf('    Insertion on right %s\n', File.NT(B).ID);
+    end
+    B = B - 1;                               % next base on right
   end
-elseif any(abs(G(B,aB(nB)))==1),
-  moveB = 0;
-else
-  moveB = 1;
-end
 
-while sum((G([LS RS],B))) == 0 && moveB == 1,
-                                        % no interaction w/in this loop
-  if Verbose > 0,
-    fprintf('    Insertion      %4s %s\n', File.NT(B).Number, File.NT(B).Base);
-  end
-  RightIns = RightIns + 1;         % increase mean number of insertions
-  B = B - 1;                               % next base on right
-  aaa = min([length(File.NT) a+cdepth floor((a+B)/2)]);
-  LS  = a:aaa;                             % left strand
-  BBB = max([1 B-cdepth floor((a+B)/2)+1]);
-  RS  = BBB:(B-1);                         % right strand
-  aB  = a:B;                            % indices from a to B
+  % --------------------------------------- B interacts, but skip anyway?
+
+  [aaa,BBB] = pNextNucleotides(a,B,Truncate,N,cdepth);
+  LS  = a:aaa;                               % left strand including a
+  RS  = BBB:(B-1);                           % right strand not including B
+  aB  = a:B;                                 % indices from a to B
   na  = find(H(a,aB));                       % nested interaction(s) a makes
   nB  = find(H(B,aB));                       % nested interaction(s) B makes
 
-  if ~isempty(nB),
-%    ['B interacts with ' File.NT(aB(max(nB))).Number]
+  if ~isempty(nB) && Verbose > 0
+    fprintf('pMakeNodesProbeForInsertions:  B %s interacts with %s\n', File.NT(B).ID, File.NT(aB(max(nB))).ID);
   end
 
-  if isempty(nB),                             % a makes no nested interactions
-    moveB = 1;
-  elseif sum(sum(H(aB(min(nB)):(B-1),aB(min(nB)):(B-1)))) > 0, % 
+  if B == BBB
+    % reached the end of the strand
+    moveB = 0;
+  elseif sum(sum(H(aB(min(nB)):(B-1),aB(min(nB)):(B-1)))) > 0
     moveB = 0;
-%    disp('Found that the interaction B makes contains a stem');
-  elseif ~isempty(nB),                        % B makes a nested interaction
+    if Verbose > 0
+      disp('pMakeNodesProbeForInsertions:  Found that the interaction B makes contains a stem');
+    end
+  elseif ~isempty(nB)                        % B makes a nested interaction
     if min(abs(nonzeros(G(B,aB(nB))))) < min(abs(nonzeros(G(a,aB(na))))),
       moveB = 0;
-%      disp('Both a and B make nested interactions, but B makes a more important one');
+      if Verbose > 0
+        disp('pMakeNodesProbeForInsertions:  Both a and B make nested interactions, but B makes a more important one');
+      end
     end
-  elseif any(abs(G(B,aB(nB)))==1),
+  elseif any(abs(G(B,aB(nB)))==1)
     moveB = 0;
-  else
-    moveB = 1;
   end
 
+  while sum((G([LS RS],B))) == 0 && moveB == 1
+                                          % no interaction w/in this loop
+    if Verbose > 0
+      fprintf('    Insertion      %4s %s\n', File.NT(B).Number, File.NT(B).Base);
+    end
+    B = B - 1;                               % next base on right
+    [aaa,BBB] = pNextNucleotides(a,B,Truncate,N,cdepth);
+    LS  = a:aaa;                             % left strand
+    RS  = BBB:(B-1);                         % right strand
+    aB  = a:B;                            % indices from a to B
+    na  = find(H(a,aB));                       % nested interaction(s) a makes
+    nB  = find(H(B,aB));                       % nested interaction(s) B makes
+
+    if B == BBB
+      % reached the end of the strand
+      moveB = 0;
+    elseif sum(sum(H(aB(min(nB)):(B-1),aB(min(nB)):(B-1)))) > 0
+      moveB = 0;
+    elseif ~isempty(nB)                        % B makes a nested interaction
+      if min(abs(nonzeros(G(B,aB(nB))))) < min(abs(nonzeros(G(a,aB(na)))))
+        moveB = 0;
+      end
+    elseif any(abs(G(B,aB(nB)))==1)
+      moveB = 0;
+    end
+  end
 end
 
-%['Moved B ' File.NT(a).Number ' ' File.NT(B).Number]
+LeftIns  = a-aa;                            % number of insertions on the left
+RightIns = BB-B;                            % number of insertions on the right
 
 % ---------------------------------------------- Set insertion parameters
+% a and B have been moved as much as possible, now set parameters in the right place
 
 uniform = [1 1 1 1]'/4;
- 
-if strcmp(Node(n).type,'Basepair'),   % add insertions to basepair
+
+if strcmp(Node(n).type,'Basepair')    % add insertions to basepair
   i1 = Node(n).LeftIndex+1;           % index of first inserted base on left
   LeftCodes = cat(2,File.NT(i1:(a-1)).Code);
   ID = pMakeNodesInsertionDist(LeftCodes,'Basepair',Normalize);
-  if length(LeftCodes) == 1 && AdjustSubsForLR == 1,  % exactly one insertion
+  if length(LeftCodes) == 1 && AdjustSubsForLR == 1  % exactly one insertion
     R = pAdjustSubsProb(File,i1,[],uniform,method); % adjust for LR basepairs
     ID.LetterDist = R;
   end
@@ -201,36 +233,31 @@ if strcmp(Node(n).type,'Basepair'),   % add insertions to basepair
   Node(n).leftLengthDist  = ID.LengthDist;
   Node(n).leftLetterDist  = ID.LetterDist;
 
-  if length(LeftCodes) > 0 && Verbose > 1, 
+  if length(LeftCodes) > 0 && Verbose > 1
     fprintf('pMakeNodesProbeForInsertions:  LeftIns %d  length(LeftCodes) %d\n', LeftIns, length(LeftCodes));
-    ID.LengthDist
-    ID.LetterDist
   end
 
   i1 = Node(n).RightIndex-1;           % index of first inserted base on right
   RightCodes = cat(2,File.NT((B+1):(Node(n).RightIndex-1)).Code);
   ID = pMakeNodesInsertionDist(RightCodes,'Basepair',Normalize);
-  if length(RightCodes) == 1 && AdjustSubsForLR == 1, % exactly one insertion
+  if length(RightCodes) == 1 && AdjustSubsForLR == 1 % exactly one insertion
     R = pAdjustSubsProb(File,i1,[],uniform,method); % adjust for LR basepairs
     ID.LetterDist = R;
- disp('Adjusted for LR interactions');
+    disp('Adjusted for LR interactions');
   end
-  Node(n).rightLengthDist = ID.LengthDist; 
+  Node(n).rightLengthDist = ID.LengthDist;
   Node(n).rightLetterDist = ID.LetterDist;
 
-
-if length(RightCodes) > 0 && Verbose > 1,
-  fprintf('pMakeNodesProbeForInsertions:  RightIns %d  length(RightCodes) %d\n', RightIns, length(RightCodes));
-  ID.LengthDist
-  ID.LetterDist
-end
+  if length(RightCodes) > 0 && Verbose > 1
+    fprintf('pMakeNodesProbeForInsertions:  RightIns %d  length(RightCodes) %d\n', RightIns, length(RightCodes));
+  end
 
   Node(n).LeftLetter  = [Node(n).LeftLetter cat(2,File.NT((Node(n).LeftIndex+1):(a-1)).Base)];
   Node(n).RightLetter = [cat(2,File.NT((B+1):(Node(n).RightIndex-1)).Base) Node(n).RightLetter];
 
 % ----------------------------------------------- Insertions for Initial node
 
-elseif strcmp(Node(n).type,'Initial'),
+elseif strcmp(Node(n).type,'Initial')
   i1 = Node(n).LeftIndex;               % index of first inserted base on left
   LeftCodes = cat(2,File.NT(i1:(a-1)).Code);
   ID = pMakeNodesInsertionDist(LeftCodes,'Initial',Normalize);
@@ -244,11 +271,11 @@ elseif strcmp(Node(n).type,'Initial'),
   i1 = Node(n).RightIndex;           % index of first inserted base on right
   RightCodes = cat(2,File.NT((B+1):i1).Code);
   ID = pMakeNodesInsertionDist(RightCodes,'Initial',Normalize);
-  if length(RightCodes) == 1 && AdjustSubsForLR == 1, % exactly one insertion
+  if length(RightCodes) == 1 && AdjustSubsForLR == 1 % exactly one insertion
     R = pAdjustSubsProb(File,i1,[],uniform,method); % adjust for LR basepairs
     ID.LetterDist = R;
   end
-  Node(n).rightLengthDist = ID.LengthDist; 
+  Node(n).rightLengthDist = ID.LengthDist;
   Node(n).rightLetterDist = ID.LetterDist;
 
   Node(n).LeftLetter  = cat(2,File.NT(Node(n).LeftIndex:(a-1)).Base);
@@ -256,7 +283,8 @@ elseif strcmp(Node(n).type,'Initial'),
 
 % ----------------------------------------------- Insertion node after cluster
 
-elseif strcmp(Node(n).type,'Cluster') && (LeftIns > 0 || RightIns > 0),
+% elseif strcmp(Node(n).type,'Cluster') && (LeftIns > 0 || RightIns > 0)
+elseif strcmp(Node(n).type,'Cluster') % always put an initial node after a cluster node
   n = n + 1;                          % initial node after cluster
   Node(n).type = 'Initial';
   Node(n).nextnode  = n+1;            % index of next node in tree
@@ -268,7 +296,7 @@ elseif strcmp(Node(n).type,'Cluster') && (LeftIns > 0 || RightIns > 0),
   i1 = Node(n).LeftIndex;               % index of first inserted base on left
   LeftCodes = cat(2,File.NT(i1:(i1+LeftIns-1)).Code);
   ID = pMakeNodesInsertionDist(LeftCodes,'Initial',Normalize);
-  if length(LeftCodes) == 1 && AdjustSubsForLR == 1,  % exactly one insertion
+  if length(LeftCodes) == 1 && AdjustSubsForLR == 1  % exactly one insertion
     R = pAdjustSubsProb(File,i1,[],uniform,method);% adjust for LR basepairs
     ID.LetterDist = R;
   end
@@ -278,21 +306,21 @@ elseif strcmp(Node(n).type,'Cluster') && (LeftIns > 0 || RightIns > 0),
   i1 = Node(n).RightIndex;           % index of first inserted base on right
   RightCodes = cat(2,File.NT((BB-RightIns+1):i1).Code);
   ID = pMakeNodesInsertionDist(RightCodes,'Initial',Normalize);
-  if length(RightCodes) == 1 && AdjustSubsForLR == 1, % exactly one insertion
+  if length(RightCodes) == 1 && AdjustSubsForLR == 1 % exactly one insertion
     R = pAdjustSubsProb(File,i1,[],uniform,method); % adjust for LR basepairs
     ID.LetterDist = R;
   end
-  Node(n).rightLengthDist = ID.LengthDist; 
+  Node(n).rightLengthDist = ID.LengthDist;
   Node(n).rightLetterDist = ID.LetterDist;
 
 end
 
 % ---------------------------------------------- Add comments for initial node
 
-if strcmp(Node(n).type,'Initial'),
-  Node(n).Comment = [' // Initial node ' File.NT(aa).Base File.NT(aa).Number ' - ' File.NT(BB).Base File.NT(BB).Number ' from junction ' Node(n).id];
+if strcmp(Node(n).type,'Initial')
+  Node(n).Comment = [' // Initial node ' File.NT(aa).ID ' - ' File.NT(BB).ID ' from Node ' Node(n).id];
 
-  if Verbose > 0,
+  if Verbose > 0
     fprintf('%3d Initial   %4s (%d insertion) and %4s (%d insertion)\n', n, File.NT(Node(n).LeftIndex).Number, LeftIns, File.NT(Node(n).RightIndex).Number, RightIns);
   end
 end
diff --git a/matlab/pMakeRandomSequencesWeighted.m b/matlab/pMakeRandomSequencesWeighted.m
index da68214..278c7a5 100644
--- a/matlab/pMakeRandomSequencesWeighted.m
+++ b/matlab/pMakeRandomSequencesWeighted.m
@@ -1,58 +1,68 @@
-% pMakeRandomSequencesWeighted(Node,loopType,sampsize,TransitionFile) generates random sequences
+% pMakeRandomSequencesWeighted(seqlengths,loopType,sampsize,TransitionFile) generates random sequences
 
 % BetterEmpDist('IL_225_05_cWW-cWW-cSH','IL',100)
 
-function [Text,D,FASTA] = pMakeRandomSequencesWeighted(Node,loopType,sampsize,TransitionFile,Mode)
+function [Text,D,FASTA] = pMakeRandomSequencesWeighted(seqlengths,loopType,sampsize,TransitionFile,Mode)
 
-if nargin < 5,
+if nargin < 5
   Mode = 3;                       % no constraints on base combinations
 end
 
-[s,t] = size(Node);
+[s,t] = size(seqlengths);
 
-if s == sampsize,
-    dim = Node';                  % first argument is the desired sequence lengths
+if s == sampsize
+    fprintf('pMakeRandomSequencesWeighted: using passed in sequence dimensions\n')
+    dim = seqlengths';                  % first argument is the desired sequence lengths
 else
+    Node = seqlengths;            % no idea when that would be needed
     D = pModelLengthDist(Node);
     cWW_M = zeros(6,1);           %CG,GC,AU,UA,GU,UG
     initial_M = zeros(4,1);       %A,C,G,U
     transition_M = zeros(4,4);    %(A,C,G,U)^2
 
     % ---------------------------------------- generate strand lengths
-    switch loopType,
-    case 'IL'
-        ld = sum(D,2);                       % marginal distribution of left
-        dim=zeros(2,sampsize);
-
-        dim(1,:) = myrandsample(ld,sampsize,1) - 1;
-
-        for i = 1:sampsize,
-            rd = D(dim(1,i)+1,:);            % almost the conditional distn
-            rd = rd / sum(rd);               % normalize
-            dim(2,i) = myrandsample(rd)-1;
-        end
-    case 'HL'
-        dim=zeros(1,sampsize);
-        dim = myrandsample(D,1,sampsize)-1;
+    switch loopType
+        case 'HL'
+            % dim=zeros(1,sampsize);
+            dim = myrandsample(D,1,sampsize)-1;
+        case 'IL'
+            ld = sum(D,2);                       % marginal distribution of left
+            dim=zeros(2,sampsize);
+
+            dim(1,:) = myrandsample(ld,sampsize,1) - 1;
+
+            for i = 1:sampsize
+                rd = D(dim(1,i)+1,:);            % almost the conditional distn
+                rd = rd / sum(rd);               % normalize
+                dim(2,i) = myrandsample(rd)-1;
+            end
     end
 end
 
+fprintf('pMakeRandomSequencesWeighted: dim variable columns 1 to 10\n')
+disp(dim(:,1:10))
+
 load(TransitionFile)
+fprintf('pMakeRandomSequencesWeighted: cWW distribution, initial letter distribution, transition matrix')
+disp(cWW_M)
+disp(initial_M)
+disp(transition_M)
 
 % -------------------------------------- make sequences
 
 r = 1;
 v = 1;
-cWW = ['CG','GC','AU','UA','GU','UG'];
-[strands,N]=size(dim);
+cWW = ['CG','GC','AU','UA','GU','UG'];          % string 'CGGCAUUAGUUG'
+[strands,N]=size(dim);                          % N is the sample size
 Text{N} = '';                                   % allocate space for all sequences
 FASTA(N).Header = '';
 
 switch Mode
 case 1
+    % prohibit these base combinations next to the flanking pair
     RemoveCombinations = ['CG'; 'GC'; 'AU'; 'UA'; 'GU'; 'UG'];
 case 2
-    RemoveCombinations = ['CG'; 'GC'; 'AU'; 'GU'; 'UG'];
+    RemoveCombinations = ['CG'; 'GC'; 'AU'; 'GU'; 'UG'];          % UA tWH occurs often
 case 3
     RemoveCombinations = '';
 end
@@ -61,55 +71,86 @@ letter = 'ACGU';
 
 retry = 0;
 
-if strands == 2,
+if strands == 1
+    % generate flanking cWW and initial nucleotide for all samples
+    openprand = myrandsample(cWW_M,sampsize,1);
+    mrand     = myrandsample(initial_M,sampsize,1);
+
+    for i = 1:N
+        Text{r} = sprintf('> Variant %d',i);
+        r = r + 1;
+        openp = openprand(i,1); % flanking cWW pair
+        LL = max(dim(1,i),2);
+
+        s = GenerateStrand(LL,mrand(i,1),transition_M);
+
+        if LL > 2
+            while ismember([s(1) s(end)],RemoveCombinations,'rows')
+                retry = retry + 1;
+                s = GenerateStrand(LL,mrand(i,1),transition_M);
+            end
+        end
+
+        %fprintf('pMakeRandomSequencesWeighted: LL=%2d s=%s\n',LL,s);
+
+        Text{r} = [cWW(2*openp-1) s cWW(2*openp)];
+        r = r + 1;
+
+        FASTA(v).Header = sprintf('> Variant %d',i);
+        FASTA(v).Sequence = [cWW(2*openp-1) s cWW(2*openp)];
+        v = v + 1;
+    end
+elseif strands == 2
+    % IL
     openprand  = myrandsample(cWW_M,sampsize,1);
     closeprand = myrandsample(cWW_M,sampsize,1);
 
-    for i = 1:N,                                % N sequences
-        LL = max(dim(1,i),2);                   % left strand length
-        RL = max(dim(2,i),2);                   % right strand length
+    for i = 1:N                                 % N sequences
         Text{r} = sprintf('> Variant %d',i);
         r = r + 1;
+
+        LL = max(dim(1,i),2);                   % left strand length
+        RL = max(dim(2,i),2);                   % right strand length
         openp = openprand(i,1);
         closep = closeprand(i,1);
 
-        if LL == 2,
+        if LL == 2
             s = [];
-        elseif LL == 3,
+        elseif LL == 3
             m = myrandsample(initial_M,1,1);
             s = letter(m);
-        else,
+        else
             m = myrandsample(initial_M,1,1);
             s = letter(m);
-            for j = 1:(LL-3),
+            for j = 1:(LL-3)
                 m = myrandsample(transition_M(m,:));
                 s = [s letter(m)];
             end
         end
 
-        if RL == 2,
+        if RL == 2
             t = [];
-        elseif RL == 3,
+        elseif RL == 3
             m = myrandsample(initial_M,1,1);
             t = letter(m);
-        else,
+        else
             m = myrandsample(initial_M,1,1);
             t = letter(m);
-            for j = 1:(RL-3),
+            for j = 1:(RL-3)
                 m = myrandsample(transition_M(m,:));
                 t = [t letter(m)];
             end
         end
 
-        if LL > 2 && RL > 2,
+        if LL > 2 && RL > 2
             while ismember([s(1) t(end)],RemoveCombinations,'rows') || ismember([t(1) s(end)],RemoveCombinations,'rows'),
                 retry = retry + 1;
-                if LL == 2,
+                if LL == 2
                     s = [];
-                elseif LL == 3,
+                elseif LL == 3
                     m = myrandsample(initial_M,1,1);
                     s = letter(m);
-                else,
+                else
                     m = myrandsample(initial_M,1,1);
                     s = letter(m);
                     for j = 1:(LL-3),
@@ -118,12 +159,12 @@ if strands == 2,
                     end
                 end
 
-                if RL == 2,
+                if RL == 2
                     t = [];
-                elseif RL == 3,
+                elseif RL == 3
                     m = myrandsample(initial_M,1,1);
                     t = letter(m);
-                else,
+                else
                     m = myrandsample(initial_M,1,1);
                     t = letter(m);
                     for j = 1:(RL-3),
@@ -134,62 +175,111 @@ if strands == 2,
             end
         end
 
-        Text{r} = [cWW(2*openp-1) s cWW(2*closep-1) '*' cWW(2*closep) t cWW(2*openp)];
+        Text{r} = [cWW(2*openp-1) s cWW(2*closep) '*' cWW(2*closep-1) t cWW(2*openp)];
 
 % fprintf('%5d %2d %2d %s * %s | %s\n',i,LL,RL,s,t,Text{r});
 
         FASTA(v).Header = sprintf('> Variant %d',i);
         FASTA(v).Sequence = Text{r};
         v = v + 1;
-
         r = r + 1;
 
     end
-else
-    openprand = myrandsample(cWW_M,sampsize,1);
-    mrand     = myrandsample(initial_M,sampsize,1);
 
-    for i = 1:N,
-        Text{r} = sprintf('> Variant %d',i);
-        r = r + 1;
-        openp = openprand(i,1); % flanking cWW pair
-        LL = max(dim(1,i),2);
+else
+    % J3, J4, and will also cover IL and maybe HL
+    retry = 0;
+    for i = 1:N                              % N sequences
+        % generate and check interior sequences
+        badPairFound = 1;                    % pretend, so we get into the while loop
+
+        while badPairFound
+            interior = cell(1,strands);
+            for strand = 1:strands
+                sL = max(dim(strand,i),2);        % strand length
+
+                % generate the interior of each strand sequence
+                if sL == 2
+                    s = '';
+                elseif sL == 3
+                    m = myrandsample(initial_M,1,1);
+                    s = letter(m);
+                else
+                    s = repmat('X',1,sL-2);
+                    m = myrandsample(initial_M,1,1);
+                    s(1) = letter(m);
+                    for j = 2:(sL-2)
+                        m = myrandsample(transition_M(m,:));
+                        s(j) = letter(m);
+                    end
+                end
+                interior{strand} = s;
+            end
+            interior{strands+1} = interior{1};  % simplify code below
 
-        s = GenerateStrand(LL,mrand(i,1),transition_M);
+            badPairFound = 0;
 
-        if LL > 2,
-            while ismember([s(1) s(end)],RemoveCombinations,'rows'),
-                retry = retry + 1;
-                s = GenerateStrand(LL,mrand(i,1),transition_M);
+            % check to see if any of the pairs are "bad"
+            % if so, set badPairFound = 1
+            if strands == 1
+                s = interior{1};
+                if length(s) >= 2
+                    if ismember([s(1) s(end)],RemoveCombinations,'rows')
+                        badPairFound = 1;
+                    end
+                end
+            else
+                for strand = 1:strands
+                    s = interior{strand};
+                    t = interior{strand+1};  % wraps around to first strand
+                    if length(s) > 0 && length(t) > 0
+                        if ismember([s(end) t(1)],RemoveCombinations,'rows')
+                            badPairFound = 1;
+                        end
+                    end
+                end
             end
+
+            retry = retry + badPairFound;
         end
 
-%fprintf('%2d %s\n',LL,s);
+        % now that we have a good sequence, record it
+        f = '';                         % full sequence
+        for strand = 2:strands
+            % generate code for one flanking pair
+            p = myrandsample(cWW_M,1,1);
+            % add this pair; the 2*p-1 goes at the beginning of a strand
+            f = [f cWW(2*p) '*' cWW(2*p-1) interior{strand} ]; %#ok<AGROW>
+        end
+        f = [cWW(2*p-1) interior{1} f cWW(2*p)]; %#ok<AGROW>
 
-        Text{r} = [cWW(2*openp-1) s cWW(2*openp)];
+        Text{r} = sprintf('> Variant %d',i);
+        r = r + 1;
+        Text{r} = f;
         r = r + 1;
 
         FASTA(v).Header = sprintf('> Variant %d',i);
-        FASTA(v).Sequence = [cWW(2*openp-1) s cWW(2*openp)];
+        FASTA(v).Sequence = f;
         v = v + 1;
     end
 end
 
-if Mode ~= 3,
-    fprintf('Generating %d sequences required %d additional attempts to avoid the specified pairs\n',N,retry);
+if Mode ~= 3
+    fprintf('pMakeRandomSequencesWeighted: Generating %d sequences required %d additional attempts to avoid the specified pairs\n',N,retry);
 end
 
-function [s] = GenerateStrand(LL,m,transition_M);
+function [s] = GenerateStrand(LL,m,transition_M)
 
     letter = 'ACGU';
-    if LL == 2,
-        s = [];
-    elseif LL == 3,
+    if LL == 2
+        s = '';
+    elseif LL == 3
         s = letter(m);
-    else,
+    else
         s = letter(m);
-        for i = 1:(LL-3),
+        for w = 1:(LL-3)
             m = myrandsample(transition_M(m,:));
             s = [s letter(m)];
         end
     end
+
diff --git a/matlab/pMakeSCFGModels.m b/matlab/pMakeSCFGModels.m
index a266b3a..99a45db 100644
--- a/matlab/pMakeSCFGModels.m
+++ b/matlab/pMakeSCFGModels.m
@@ -16,7 +16,7 @@ if nargin < 4,
   Mode = 1;    % make normal models
 end
 
-DiagnosticsMode = 1;           % make normal models
+DiagnosticMode = 1;  % normal mode
 
 % ----------------------------------- user controls
 
@@ -101,25 +101,29 @@ end
 
 % --------------------------------- Determine number of rotations
 
-switch loopType,
-case 'JL'
-  Rotations = 3;                      % three rotations, for 3-way junctions
-case 'IL'
-  Rotations = 2;                      % two rotations are computed
-case 'HL'
-  Rotations = 1;                      % only one "rotation"
+switch loopType
+  case 'HL'
+    Rotations = 1;                      % only one "rotation"
+  case 'IL'
+    Rotations = 2;                      % two rotations are computed
+end
+
+if loopType(1) == 'J'
+  Rotations = str2num(replace(loopType,'J',''));
 end
 
 % --------------------------------- read .mat filenames, select right ones
 
+fprintf("pMakeSCFGModels: Looking for motifs in %s\n", MotifLibraryPath)
+
 Filenames = dir(MotifLibraryPath);
 
 keep = [];                               % of all models, which to keep
 
-for m = 1:length(Filenames),
+for m = 1:length(Filenames)
   Filenames(m).modeled = 0;
-  if (length(Filenames(m).name) > 2),
-    if (Filenames(m).name(1:2) == loopType),
+  if (length(Filenames(m).name) > 2)
+    if (upper(Filenames(m).name(1:2)) == upper(loopType))
       keep(m) = 1;
       Filenames(m).name = strrep(Filenames(m).name,'.mat','');
     end
@@ -128,6 +132,14 @@ end
 
 Filenames = Filenames(find(keep));
 
+if length(Filenames) == 0
+  fprintf('pMakeSCFGModels: No motif .mat files found in %s\n', MotifLibraryPath)
+  return
+end
+
+fprintf('pMakeSCFGModels: Found %d files\n',length(Filenames))
+
+
 % ----------------------------------- set paths, make directories if needed
 
 DiagnosticBase = [OutputPath filesep 'diagnostic'];
@@ -170,35 +182,30 @@ Temp.B = 9876;                             % only used for error catching
 
 % ----------------------------------- start log file
 
-LogFile = [ModelPath filesep 'log ' date '.txt'];
-delete(LogFile);
-clc
-diary(LogFile);
+%LogFile = [OutputPath filesep 'log ' date '.txt'];
+%delete(LogFile);
+%diary(LogFile);
 
 if MakeEmpiricalDistribution > 0,
-  fprintf('Generating %d random sequences for each group\n', SampleSize);
+  fprintf('Generating %d random sequences for each group to calculate percentiles\n', SampleSize);
 end
 
-fprintf('Normalization variable is %d\n', Param(8));
-
-fprintf('pIsoScore2(1,1,4,2) is:\n');
+fprintf('pMakeSCFGModels: Normalization variable is %d\n', Param(8));
 
 load PairExemplars
 
-pIsoScore2(1,1,4,ExemplarIDI,Param(8))
-
-fprintf('pIsoScore2(1,1,4,2) normalization:\n');
-
-sum(sum(pIsoScore2(1,1,4,ExemplarIDI,Param(8))))
+% fprintf('pMakeSCFGModels: pIsoScore2(1,1,4,2) is:\n');
+% pIsoScore2(1,1,4,ExemplarIDI,Param(8))
+% fprintf('pMakeSCFGModels: pIsoScore2(1,1,4,2) normalization: %8.6f\n', sum(sum(pIsoScore2(1,1,4,ExemplarIDI,Param(8)))));
 
-fprintf('Parameter vector is \n');
+fprintf('pMakeSCFGModels: Parameter vector is \n');
 Param
 
 % ------------------------------------- Gather sequence transition data
 
 TransitionFile = [OutputPath filesep 'transitions.mat'];
 
-if ~(exist(TransitionFile) == 2),
+if ~(exist(TransitionFile) == 2)
   fprintf('No transitions.mat file found, calculating transition probabilities\n');
   pCalculateTransitions;
 else
@@ -214,18 +221,19 @@ BPhcount = 0;                       % number of conserved BPh so far
 BRcount  = 0;                       % number of conserved BR so far
 
 clear OwnScoreStats
-tic
-for m = 1:length(Filenames),
-  toc
-  tic
+
+% loop over motif groups and their .mat files
+
+% temporary start at 64
+
+for m = 1:length(Filenames)
   MotifName = Filenames(m).name;
 
-  fprintf('\n');
   disp(['Timestamp ' datestr(now)])
 
   % ---------- set names of files
 
-  fprintf('pMakeSCFGModels: Analyzing motif group %s\n', MotifName);
+  fprintf('pMakeSCFGModels: Making JAR3D model for motif group %s, number %d of %d\n', MotifName, m, length(Filenames));
 
   FastaFile = [SequencePath filesep MotifName '.fasta'];
   FastaFileNoGap = [SequencePath filesep MotifName '_nogap.fasta'];
@@ -248,7 +256,43 @@ for m = 1:length(Filenames),
 
   clear Search
 
-  load([MotifLibraryPath filesep MotifName '.mat']);
+  load([MotifLibraryPath filesep MotifName '.mat'], 'Search');
+
+  % set some variables that might not have been created yet
+  % best place to make sure we know where the strands end
+  if isfield(Search,'chainbreak') && ~isfield(Search,'Truncate')
+    Truncate = zeros(length(Search.chainbreak),1);
+    % check if Search.chainbreak is a cell array
+    if iscell(Search.chainbreak)
+      for i = 1:length(Search.chainbreak)
+        % this code uses the index of the nucleotide after the break
+        Truncate(i) = str2double(Search.chainbreak{i})+1;
+      end
+    else
+      for i = 1:length(Search.chainbreak)
+        % this code uses the index of the nucleotide after the break
+        Truncate(i) = Search.chainbreak(i)+1;
+      end
+    end
+    Search.Truncate = Truncate;
+  end
+
+  if ~isfield(Search,'NumFixed')
+    % actually, the signature is a bad way to count the number of fixed nodes
+    Search.NumFixed = 0;
+    % count number of F, L, R characters in Search.Signature
+    % Search.NumFixed = Search.NumFixed + sum(Search.Signature == 'F');
+    % Search.NumFixed = Search.NumFixed + sum(Search.Signature == 'L');
+    % Search.NumFixed = Search.NumFixed + sum(Search.Signature == 'R');
+    % fprintf('pMakeSCFGModels: Signature is %s, NumFixed is %d\n', Search.Signature, Search.NumFixed);
+  end
+
+  if m == 1
+    fprintf('pMakeSCFGModels: Loaded %s, looks like:', [MotifLibraryPath filesep MotifName '.mat']);
+    Search
+    Search.File
+    Search.File(1)
+  end
 
   [L,N] = size(Search.Candidates);
   N = N - 1;
@@ -262,29 +306,45 @@ for m = 1:length(Filenames),
   Search.File = zBaseRiboseInteractions(Search.File);
 
   % ---------- make an SCFG model of the current model type, write to file
-
   [Search,Node] = pMakeSingleJAR3DModel(Search,Param,Prior,loopType);
 
- if isempty(Node),
+  % temporarily focus on just one motif group zzz
+  % if strcmp(MotifName,'IL_15698.3')
+  %   fprintf('pMakeSCFGModels is stopping here\n');
+  %   print(crash);
+  % end
+
+  % if strcmp(MotifName,'IL_63596.11')
+  %   fprintf('pMakeSCFGModels is stopping here\n');
+  %   print(crash);
+  % end
+
+
+  if isempty(Node)
 %    mkdir([MotifLibraryPath filesep 'trouble']);
 %    movefile([MotifLibraryPath filesep MotifName '.mat'],[MotifLibraryPath filesep 'trouble' filesep MotifName '.mat']);
     fprintf('@@@@@@@@@@@@ pMakeSCFGModels: Motif %s could not be modeled for some reason\n', MotifName);
     Filenames(m).modeled = 0;
 
- else
+  else
 
     Filenames(m).modeled = 1;
 
     Text = pNodeToSCFGModelText(Node,5);
 
-    if WriteModel > 0,
+    if WriteModel > 0
       fid = fopen(ModelFile,'w');
-      for i = 1:length(Text),
+      for i = 1:length(Text)
         fprintf(fid,'%s\n', Text{i});
       end
       fclose(fid);
     end
 
+    % ---------- count the number of fixed positions
+    NumFixed = length(strfind(Text,'FixedNode'));
+    NumFixed = NumFixed + length(strfind(Text,'conserved insertion'));
+    Search.NumFixed = NumFixed;
+
     % ---------- extract sequences of instances into .fasta file
 
     [Text,T3,T4,T5,ModelFASTA,T7] = xFASTACandidates(Search.File,Search,0,MotifName);
@@ -324,12 +384,14 @@ for m = 1:length(Filenames),
     case 'IL'
       GroupData(m).Signature{1} = Search.Signature;
       GroupData(m).Signature{2} = Search.RSignature;
+    otherwise
+      GroupData(m).Signature{1} = Search.Signature;
     end
     GroupData(m).NumNT = N;
     E = abs(fix(triu(Search.Edge)));
     GroupData(m).NumBasepairs = full(sum(sum((E > 0) .* (E < 14))));
 
-    if GroupData(m).NumBasepairs > Rotations,
+    if GroupData(m).NumBasepairs > Rotations
       GroupData(m).Structured = 1;            % consider this motif to be "structured"
     else
       GroupData(m).Structured = 0;
@@ -346,12 +408,13 @@ for m = 1:length(Filenames),
     GroupData(m).NumBR  = full(sum(sum(BR > 0)));
     GroupData(m).NumInstances = length(Search.Candidates(:,1));
     GroupData(m).Truncate = Search.Truncate;
-
-    si = strrep(GroupData(m).Signature{1},'L','R');
-    GroupData(m).NumFixed = length(strfind(si,'-R-'));
+    GroupData(m).NumFixed = Search.NumFixed;
 
     % --------------------------------------- write out base-backbone interactions
 
+    if Verbose > 0
+      fprintf('pMakeSCFGModels: Writing base-backbone interactions\n');
+    end
     for a = 1:N,
       for b = 1:N,
         if a~= b && Search.BPh(a,b) > 0,
@@ -408,10 +471,11 @@ for m = 1:length(Filenames),
 
     % ---------- Write motif data file
 
+    fprintf('pMakeSCFGModels: Writing motif data file %s\n', DataFile);
     fid = fopen(DataFile,'w');
-    if strcmp(loopType,'IL'),
+    if strcmp(loopType,'IL')
       fprintf(fid,'%s %s\n', Search.Signature, Search.RSignature);
-    elseif strcmp(loopType,'HL'),
+    else
       fprintf(fid,'%s\n', Search.Signature);
     end
     fprintf(fid,'%d nucleotides\n',GroupData(m).NumNT);
@@ -435,19 +499,16 @@ for m = 1:length(Filenames),
     if WriteOwnScores > 0,
 
       if Verbose > 0,
-        fprintf('pMakeSCFGModels: Calculating scores of sequences against their own model\n');
-
         fprintf('pMakeSCFGModels: FastaFile:  %s\n', FastaFile);
         fprintf('pMakeSCFGModels: ModelFile:  %s\n', ModelFile);
         fprintf('pMakeSCFGModels: OutputPath: %s\n', OutputPath);
-
       end
 
+      fprintf('pMakeSCFGModels: Calculating scores of sequences against their own model\n');
       OwnScores = edu.bgsu.rna.jar3d.JAR3DMatlab.MotifParseSingle(OutputPath,FastaFile,ModelFile);
 
       OwnScores
 
-
       % ----------- The following lines prevent the program from being stopped
       % ----------- by a crazy Matlab bug.  It is intermittent, but after a call
       % ----------- to JAR3D, it is hell bent on saying
@@ -458,7 +519,7 @@ for m = 1:length(Filenames),
 
       try
         x = Temp.A + 1;
-        %Temp.A
+         Temp.A;
       catch ME
         Temp.B = 9876;
       end
@@ -512,7 +573,7 @@ for m = 1:length(Filenames),
           % ----------- "Dot name reference on non-scalar structure"
           try
             x = Temp.A + 1;
-             Temp.A
+             Temp.A;
           catch ME
             Temp.B = 9876;
           end
@@ -560,9 +621,6 @@ for m = 1:length(Filenames),
 
       print(gcf,'-dpng',[DiagnosticPath filesep MotifName '_randomsequencescatter.png']);
 
-%        pause
-
-
       figure(3)
       clf
       hist(-MixedScores,30);
@@ -644,16 +702,16 @@ end                           % loop over filenames
 % ------------------------------------------------------- write lists of model files
 
 fid = fopen(AllFileList,'w');
-for m = 1:length(Filenames),
-  if Filenames(m).modeled == 1,
+for m = 1:length(Filenames)
+  if Filenames(m).modeled == 1
     fprintf(fid,'%s\n',[Filenames(m).name '_model.txt']);
   end
 end
 fclose(fid);
 
 fid = fopen(StructuredFileList,'w');
-for m = 1:length(Filenames),
-  if Filenames(m).modeled == 1 && GroupData(m).Structured > 0,
+for m = 1:length(Filenames)
+  if Filenames(m).modeled == 1 && GroupData(m).Structured > 0
     fprintf(fid,'%s\n',[Filenames(m).name '_model.txt']);
   end
 end
@@ -695,11 +753,9 @@ for m = 1:length(Filenames),
 end
 fclose(fid);
 
-diary off
-
 % -------------------------- show statistics about own scores
 
-if Verbose > 0,
+if Verbose > 0
   fprintf('pMakeSCFGModels: Statistics on own scores\n');
 
   for m = 1:length(OwnScoreStats),
diff --git a/matlab/pMakeSingleJAR3DModel.m b/matlab/pMakeSingleJAR3DModel.m
index 44c8e10..d3285af 100644
--- a/matlab/pMakeSingleJAR3DModel.m
+++ b/matlab/pMakeSingleJAR3DModel.m
@@ -4,7 +4,7 @@
 
 function [Search,Node] = pMakeSingleJAR3DModel(Search,Param,Prior,loopType)
 
-if nargin < 2,
+if nargin < 2
   Param = [0 2 0 4 100 1 1 1 Inf 5 3];                   % See below
 
   % Parameters stored in Param:
@@ -27,6 +27,13 @@ if nargin < 3,
   Prior = [.5 .5 .5 .5 0];              % Prior distribution for insertion bases
 end
 
+CL = zClassLimits;
+if exist('PairExemplars.mat','file') > 0
+    load('PairExemplars','Exemplar');
+else
+    Exemplar = [];
+end
+
 % ----- Calculate coplanar measure for each File in Search
 
 [L,N] = size(Search.Candidates);        % L = num instances; N = num NT
@@ -96,14 +103,38 @@ end
 
 [Node,Search] = pMakeMotifModelFromSSF(Search,Param,Prior,loopType,1:L);
 
-if length(Node) > 0,
+% simple quality check on junctions
+if loopType(1) == 'J'
+    Rotations = str2num(strrep(loopType,'J',''));  % J3, J4, etc.
+    hairpin_count = 0;
+    junction_count = 0;
+    for n = 1:length(Node)
+        if strcmp(Node(n).type,'Junction')
+            junction_count = junction_count + 1;
+        end
+        if strcmp(Node(n).type,'Hairpin')
+            hairpin_count = hairpin_count + 1;
+        end
+    end
+    if hairpin_count ~= Rotations-1
+        fprintf('pMakeSingleJAR3DModel: number of hairpins is incorrect, stopping\n');
+        fprintf(crash)
+    end
+    if junction_count ~= Rotations-2
+        fprintf('pMakeSingleJAR3DModel: number of junctions is incorrect, stopping\n');
+        fprintf(crash)
+    end
+end
+
+% simple quality check on IL, hopefully no longer needed
+if length(Node) > 0
   OK = 1;
-  for n = 1:length(Node),
-    if strcmp(loopType,'IL') && strcmp(Node(n).type,'Junction'),
+  for n = 1:length(Node)
+    if strcmp(loopType,'IL') && strcmp(Node(n).type,'Junction')
       OK = 0;
     end
   end
-  if OK == 0,
+  if OK == 0
     Node = [];
   end
 end
diff --git a/matlab/pNextNodeJunction.m b/matlab/pNextNodeJunction.m
new file mode 100644
index 0000000..844c306
--- /dev/null
+++ b/matlab/pNextNodeJunction.m
@@ -0,0 +1,29 @@
+% Run through nodes until a hairpin is reached, then return the node number
+% Returns the index of the last hairpin after N
+% When a junction is encountered, call recursively and record the next node values
+
+function [Node,n] = pNextNodeJunction(Node,N)
+
+    n = N;
+    while n <= length(Node)
+        if strcmp(Node(n).type,'Junction')
+            fprintf('pNextNodeJunction: Found a junction at node %d\n',n);
+            Node(n).nextnode(1) = n+1;
+            k = n;
+            fprintf('pNextNodeJunction: Found a junction child at node %d\n',k+1);
+            for j = 2:length(Node(n).nextnode)
+                [Node, k] = pNextNodeJunction(Node,k+1);
+                Node(n).nextnode(j) = k+1;
+                fprintf('pNextNodeJunction: Found a junction child at node %d\n',k+1);
+            end
+            [Node, k] = pNextNodeJunction(Node,k+1);
+            n = k+1;
+        elseif strcmp(Node(n).type,'Hairpin')
+            fprintf('pNextNodeJunction: Found a hairpin at node %d\n',n);
+            return
+        else
+            n = n + 1;
+        end
+    end
+    n = min(n,length(Node));
+    fprintf('pNextNodeJunction: Finished at node %d out of %d, type %s\n',n, length(Node), Node(n).type);
diff --git a/matlab/pNextNucleotides.m b/matlab/pNextNucleotides.m
new file mode 100644
index 0000000..d4f2815
--- /dev/null
+++ b/matlab/pNextNucleotides.m
@@ -0,0 +1,13 @@
+% find next nucleotides on the strand ahead of a and behind B
+
+function [aaa,BBB] = pNextNucleotides(a,B,Truncate,N,cdepth)
+
+    if pStrandBreaksBetween(a,B,Truncate) == 0
+        % hairpin
+        aaa = min([N a+cdepth floor((a+B)/2)]);
+        BBB = max([1 B-cdepth floor((a+B)/2)+1]);
+    else
+        % IL or junction
+        aaa = min([N a+cdepth pNextTruncation(a,Truncate,N)]);
+        BBB = max([1 B-cdepth pNextTruncation(B,Truncate,1)]);
+    end
diff --git a/matlab/pNextStrands.m b/matlab/pNextStrands.m
new file mode 100644
index 0000000..3620786
--- /dev/null
+++ b/matlab/pNextStrands.m
@@ -0,0 +1,17 @@
+% find next nucleotides on the strand after a and before B
+% for junction situations only
+
+function [NSL,NSR] = pNextStrands(a,B,Truncate,N)
+
+    r = pNextTruncation(a,Truncate,N);  % end of a strand
+    s = r+1;  % start of next strand after a
+    t = pNextTruncation(s,Truncate,N);
+
+    NSL = s:t;
+
+    z = pNextTruncation(B,Truncate,1);  % beginning of B strand
+    y = z-1;                            % end of strand before B
+    x = pNextTruncation(y,Truncate,1);  % start of strand before B
+
+    NSR = x:y;
+end
\ No newline at end of file
diff --git a/matlab/pNextTruncation.m b/matlab/pNextTruncation.m
new file mode 100644
index 0000000..6470cbe
--- /dev/null
+++ b/matlab/pNextTruncation.m
@@ -0,0 +1,28 @@
+% pNextTruncation(a,Truncate,N) finds the last value in the same strand as a is in,
+% on the way to N
+
+function [c] = pNextTruncation(a,Truncate,N)
+
+    % make sure that Truncate is a row vector so the function returns just one value
+    if size(Truncate,1) > 1
+        Truncate = Truncate';
+    end
+
+    c = N;
+    if N == 1
+        % look earlier in the sequence, toward 1
+        for t = Truncate
+            if t <= a
+                c = t;
+            end
+        end
+    else
+        % look later in the sequence, toward N
+        for t = Truncate
+            if t > a
+                c = t-1;  % last index before the next strand starts
+                break;
+            end
+        end
+    end
+end
diff --git a/matlab/pNodeToSCFGModelText.m b/matlab/pNodeToSCFGModelText.m
index 8d1ef16..3653c75 100644
--- a/matlab/pNodeToSCFGModelText.m
+++ b/matlab/pNodeToSCFGModelText.m
@@ -5,22 +5,22 @@
 
 function [T] = pNodeToSCFGModelText(Node,NumChar)
 
-if nargin < 2,
+if nargin < 2
   NumChar = 4;
 end
 
-if NumChar == 4,
+if NumChar == 4
   Text = 'Character Definition | A,C,G,U // Define characters here';
-elseif NumChar == 5,
+elseif NumChar == 5
   Text = 'Character Definition | A,C,G,U,* // Define characters here';
-elseif NumChar == 6,
+elseif NumChar == 6
   Text = 'Character Definition | A,C,G,U,N // Define characters here';
 end
 
 T{1} = Text;
 r = 2;
 
-for n=1:length(Node),
+for n=1:length(Node)
   switch Node(n).type
     case 'Initial' % -----------------------------------------------------
 
@@ -79,7 +79,7 @@ for n=1:length(Node),
 
     case 'Junction' % -----------------------------------------------------
       Text = [sprintf('JunctionNode | Branches ')];
-      Text = [Text sprintf('[%d] ',length(Node(n).nextnode))];
+      Text = [Text sprintf('[%d] ',Node(n).numbranches)];
 
       LI = Node(n).LeftIndex;
       RI = Node(n).RightIndex;
@@ -196,7 +196,7 @@ for n=1:length(Node),
         RI = Node(n).MiddleIndex(end);                    % use the last
       else
         LI = Node(n).LeftIndex(1);                        % use the first
-        RI = Node(n).RightIndex(end);                     % use the last  
+        RI = Node(n).RightIndex(end);                     % use the last
         fprintf('pNodeToSCFGModelText: Warning, Node(%d).MiddleIndex is empty\n',n);
       end
 
@@ -205,7 +205,7 @@ for n=1:length(Node),
       if(isfield(Node(n),'NormCons')),
         Text = [Text sprintf(' | Norm Constant [%0.15f]', Node(n).NormCons)];
       else
-        Text = [Text sprintf(' | Norm Constant [%0.15f]', 1.0)];  
+        Text = [Text sprintf(' | Norm Constant [%0.15f]', 1.0)];
       end
       Text = [Text Node(n).Comment];
 
diff --git a/matlab/pSetModelSpecificCutoffs.m b/matlab/pSetModelSpecificCutoffs.m
index a4bf683..a50577b 100644
--- a/matlab/pSetModelSpecificCutoffs.m
+++ b/matlab/pSetModelSpecificCutoffs.m
@@ -17,7 +17,7 @@
 
 function [void] = pSetModelSpecificCutoffs(OutputBase,Release,UseAlignmentSequences)
 
-if nargin < 3,
+if nargin < 3
 	UseAlignmentSequences = 2;               % use alignment sequences to set cutoffs and show them too
 	UseAlignmentSequences = 1;               % show alignment sequences but don't use them to set cutoffs
 	UseAlignmentSequences = 0;               % don't use or show alignment sequences
@@ -29,7 +29,7 @@ Params.CoreEditCutoff   = 5;
 Grayscale = 0;                              % plot in grayscale for the paper or in color for talks
 tfs = 13;
 
-if UseAlignmentSequences == 2,
+if UseAlignmentSequences == 2
 	NumAlignmentSequencesNeeded = 20;           % number for cutoffs based on alignment and random sequences
 else
 	NumAlignmentSequencesNeeded = Inf;          % for cutoffs based only on random sequences
@@ -47,16 +47,14 @@ MaxNumFP = [200 200 400 500 600 800 1000];  % maximum number of false positives
 MaxNumFP = [MaxNumFP Inf * ones(1,200)];
 Params.CutoffType = 2;
 
-if Save3DPlots > 0,
+if Save3DPlots > 0
 	Show3dPlots = 1;
 end
 
-Release = strrep(Release,'/',filesep);
-Release = strrep(Release,'\',filesep);
 OutputPath = [OutputBase filesep Release];
-MotifRelease = Release(4:end);
 
 loopType = Release(1:2);
+MotifRelease = Release(4:end);
 
 ModelPath = [OutputPath filesep 'lib'];
 
@@ -64,7 +62,7 @@ GroupData = pGetModelData(OutputPath,loopType);
 
 MSCOutputPath = [OutputPath filesep 'ModelSpecificCutoffs'];
 
-if ~(exist(MSCOutputPath) == 7),        % if directory doesn't yet exist
+if ~(exist(MSCOutputPath) == 7)        % if directory doesn't yet exist
   mkdir(MSCOutputPath);
 end
 
@@ -72,21 +70,21 @@ DiaryFile = [MSCOutputPath filesep 'log_' date '.txt'];
 
 diary(DiaryFile);
 
-if ~(exist(MSCOutputPath) == 7),        % if directory doesn't yet exist
+if ~(exist(MSCOutputPath) == 7)        % if directory doesn't yet exist
   mkdir(MSCOutputPath);
 end
 
-if UseAlignmentSequences > 0 && ~exist('AlignmentData'),
+if UseAlignmentSequences > 0 && ~exist('AlignmentData')
 	load([OutputPath filesep loopType '_Alignment_Sequence_Data.mat']);
 	AlignmentData = SequenceData;
 	clear SequenceData
 
-	if isfield(AlignmentData,'Percentile'),
+	if isfield(AlignmentData,'Percentile')
 		AlignmentData = rmfield(AlignmentData,'Percentile');
 	end
 
 	AlignmentDataMotifIDs = cell(1,length(AlignmentData));
-	for i = 1:length(AlignmentData),
+	for i = 1:length(AlignmentData)
 		AlignmentDataMotifIDs{i} = AlignmentData(i).MotifID;
 	end
 
@@ -100,12 +98,12 @@ end
 
 motiforder = 1:length(GroupData);
 
-for iii = 1:length(GroupData),
+for iii = 1:length(GroupData)
 
 	motifnum = motiforder(iii);
 	pauseafter = 0;
 
-	if ListSequences > 0,
+	if ListSequences > 0
 		clc
 	end
 
@@ -116,9 +114,9 @@ for iii = 1:length(GroupData),
 	% -------------------------- filter out poor alignment data
 
 	k = find(ismember(AlignmentDataMotifIDs,CurrentMotif));
-  SequenceData = AlignmentData(k);
+    SequenceData = AlignmentData(k);
 
-  if length(SequenceData) > 0,
+	if length(SequenceData) > 0
 		ce = cat(1,SequenceData.CoreEdit);
 		k = find(ce <= CoreEditCutoff);
 		SequenceData = SequenceData(k);
@@ -126,7 +124,7 @@ for iii = 1:length(GroupData),
 		def = cat(1,SequenceData.Deficit);
 		k = find(def <= Params.DeficitCutoff);
 		SequenceData = SequenceData(k);
-	  fprintf('Removed based on deficit, %d sequences remaining\n',length(SequenceData));
+		fprintf('Removed based on deficit, %d sequences remaining\n',length(SequenceData));
 		fprintf('%10d sequences from alignments with deficits between %d %d\n', length(SequenceData), 0, Params.DeficitCutoff);
 
 		[y,k] = sort(rand(1,length(SequenceData)));         % randomize order
@@ -136,7 +134,7 @@ for iii = 1:length(GroupData),
 	% ---------------------------- record data from motif group
 
 	clear NSD
-	for co = 1:GroupData(motifnum).NumInstances,
+	for co = 1:GroupData(motifnum).NumInstances
 		NSD(co).Deficit      = max(GroupData(motifnum).OwnScore) - GroupData(motifnum).OwnScore(co);
 		NSD(co).CoreEdit     = 0;
 		NSD(co).FullEdit     = 0;
@@ -157,13 +155,13 @@ for iii = 1:length(GroupData),
 
 	AllSD = [NSD SequenceData];      % put sequences from 3D first
 
-	if isfield(GroupData(motifnum),'DeficitEditData'),
+	if isfield(GroupData(motifnum),'DeficitEditData')
 		RSNum = length(GroupData(motifnum).DeficitEditData(:,1));
 	else
 		fprintf('pSetModelSpecificCutoffs:  No data about how random sequences match the model\n');
 
-		for mm = 1:length(GroupData),
-			if ~isfield(GroupData(mm),'DeficitEditData'),
+		for mm = 1:length(GroupData)
+			if ~isfield(GroupData(mm),'DeficitEditData')
 				fprintf('Group %3d is missing DeficitEditData\n',mm);
 			end
 		end
@@ -174,13 +172,13 @@ for iii = 1:length(GroupData),
 
 	fprintf('Using %d random sequences, %d from an alignment, and %d from 3D structures\n', RSNum, length(SequenceData), length(NSD));
 
-	if RSNum + length(AllSD) > 0,
+	if RSNum + length(AllSD) > 0
 
 		clear SequenceData
 
 		Keep = ones(1,length(AllSD));
-		for i = 1:length(AllSD),
-			if isempty(AllSD(i).CoreEdit),
+		for i = 1:length(AllSD)
+			if isempty(AllSD(i).CoreEdit)
 				Keep(1,i) = 0;
 			end
 		end
@@ -199,7 +197,7 @@ for iii = 1:length(GroupData),
 		SD(:,10) = cat(1,AllSD.NumFixed);
 		SD(:,11) = cat(1,AllSD.Basepairs);
 
-		if RSNum > 0,
+		if RSNum > 0
 			clear RSD
 			RSD(:,1) = cat(1,GroupData(motifnum).DeficitEditData(:,1));
 			RSD(:,2) = cat(1,GroupData(motifnum).DeficitEditData(:,2));
@@ -241,17 +239,17 @@ for iii = 1:length(GroupData),
 		Names{5} = 'NumConserved';
 		Names{6} = 'FlankEdit';
 		Names{7} = 'AlignmentScore';
-	  Names{10} = 'NumFixed';
-	  Names{11} = 'Basepairs';
+		Names{10} = 'NumFixed';
+		Names{11} = 'Basepairs';
 
 		f = 1;
-	  if Show2dPlots > 0,
+	    if Show2dPlots > 0
 			j = 1:min(length(Source),10000);
 
-		  n = [1 2 3 4 6 7];                  % which variables to plot and in what order
+ 		    n = [1 2 3 4 6 7];                  % which variables to plot and in what order
 
-			for a = 1:length(n),
-				for b = (a+1):length(n),
+			for a = 1:length(n)
+				for b = (a+1):length(n)
 					figure(f)
 					clf
 					scatter(SDR(j,n(a)),SDR(j,n(b)),4,min(Source(j),3),'filled');
@@ -263,7 +261,7 @@ for iii = 1:length(GroupData),
 			end
 		end
 
-		if Show3dPlots > 0,
+		if Show3dPlots > 0
 
 			Triple(1,:) = [1 2 8];
 			Triple(2,:) = [1 2 9];
@@ -274,14 +272,14 @@ for iii = 1:length(GroupData),
 			Triple(7,:) = [4 5 10];
 			Triple(8,:) = [2 4 7];
 
-	  	clear Triple
+		  	clear Triple
 
 			Triple(1,:) = [2 4 1];
 
 			j = 1:min(2000,length(Source));  % plot up to 2000 points
 			j = [j find(Source == 0)'];
 
-			for t = 1:length(Triple(:,1)),
+			for t = 1:length(Triple(:,1))
 				figure(f)
 				[ax,az] = view;
 				clf
@@ -309,42 +307,48 @@ for iii = 1:length(GroupData),
 
 		i = [2 4 1];  % core edit, sequence length, deficit
 
-  	if ListSequences > 0,
-  		OrderMatrix = [BinarySource SD(:,7)];
-  		[y,ii] = sortrows(OrderMatrix,[1 2]);
-  		for n = 1:length(ii),
-  			j = ii(n);
-  			fprintf('Source %d %50s CoreEdit %d Score %8.4f Deficit %8.4f \n', Source(j), AllSD(j).Sequence, SD(j,2), SD(j,7), SD(j,1));
-  		end
-  	end
+		if ListSequences > 0
+			OrderMatrix = [BinarySource SD(:,7)];
+			[y,ii] = sortrows(OrderMatrix,[1 2]);
+			for n = 1:length(ii)
+				j = ii(n);
+				fprintf('Source %d %50s CoreEdit %d Score %8.4f Deficit %8.4f \n', Source(j), AllSD(j).Sequence, SD(j,2), SD(j,7), SD(j,1));
+			end
+		end
 
 		ra = find(Source == 1);
-    AlignmentMixedScores = SD(ra,[1 2]) * Coeff';          % scores of these sequences against current coefficients
+	    AlignmentMixedScores = SD(ra,[1 2]) * Coeff';          % scores of these sequences against current coefficients
 
 		ra = find(Source == 2);
-    RandomMixedScores = SD(ra,[1 2]) * Coeff';             % scores of these sequences against current coefficients
+    	RandomMixedScores = SD(ra,[1 2]) * Coeff';             % scores of these sequences against current coefficients
 
 		ra = find((Source == 2) .* (SD(:,2) > 1));             % random sequences at core edit distance 2 or greater
-    RandomMixedScoresB = SD(ra,[1 2]) * Coeff';            % scores of these sequences against current coefficients
+	    RandomMixedScoresB = SD(ra,[1 2]) * Coeff';            % scores of these sequences against current coefficients
 
 		GroupData(motifnum).RandomQuantile80 = quantile(RandomMixedScores,0.2);
 		GroupData(motifnum).RandomQuantile96 = quantile(RandomMixedScores,0.04);
 		GroupData(motifnum).RandomQuantile98 = quantile(RandomMixedScores,0.02);
 
-		switch loopType,
-		case 'IL'
-			DefaultMixedScoreCutoff = min(25,10+1.8*(GroupData(motifnum).NumNT-5));
-		case 'HL'
-			DefaultMixedScoreCutoff = min(25,10+3*(GroupData(motifnum).NumNT-5));
+		switch loopType
+			case 'HL'
+				DefaultMixedScoreCutoff = min(25,10+3*(GroupData(motifnum).NumNT-5));
+			case 'IL'
+				DefaultMixedScoreCutoff = min(25,10+1.8*(GroupData(motifnum).NumNT-5));
+			case 'J3'
+				fprintf('Trying a definition of DefaultMixedScoreCutoff for J3\n');
+				DefaultMixedScoreCutoff = min(25,10+1.8*(GroupData(motifnum).NumNT-5));
+			otherwise
+				fprintf('Trying a definition of DefaultMixedScoreCutoff for %s\n', loopType);
+				DefaultMixedScoreCutoff = min(25,10+1.8*(GroupData(motifnum).NumNT-5));
 		end
 		MixedScoreCutoff = DefaultMixedScoreCutoff;
  		GroupData(motifnum).CutoffMethod = 1;
 
-    figure(2)
-  	clf
+		figure(2)
+		clf
 
-  	k = find((Source <= 1) + (Source == 2).*(SD(:,2) > 0));  % only use alignment sequences and "bad" random sequences
-  	MixedScores = SD(k,[1 2]) * Coeff';
+		k = find((Source <= 1) + (Source == 2).*(SD(:,2) > 0));  % only use alignment sequences and "bad" random sequences
+		MixedScores = SD(k,[1 2]) * Coeff';
 
 		if sum(Source == 2) > 0 && sum(Source <= 1) > NumAlignmentSequencesNeeded,  % enough of both random and alignment sequences
 
@@ -352,7 +356,7 @@ for iii = 1:length(GroupData),
 	  	MixedScoreValues = 0:0.1:40;
 	  	performance = zeros(length(MixedScoreValues),3);
 
-	  	for c = 1:length(MixedScoreValues),
+	  	for c = 1:length(MixedScoreValues)
 	  	  mynewclasses = 2 - (MixedScores <= MixedScoreValues(c));
 	  	  TP = sum((mynewclasses == 1) .* (BinarySource(k,:) == 1)) / sum(BinarySource(k,:) == 1);
 	  	  TN = sum((mynewclasses == 2) .* (BinarySource(k,:) == 2)) / sum(BinarySource(k,:) == 2);
@@ -365,7 +369,7 @@ for iii = 1:length(GroupData),
 				fprintf('Borderline case for imposing a model-specific cutoff, maximum %8.4f\n',mm);
 			end
 
-			if min(performance(:,3)) < -0.5,
+			if min(performance(:,3)) < -0.5
 				fprintf('Many random sequences perform better than sequences from alignments.\n');
 			end
 
@@ -396,7 +400,7 @@ for iii = 1:length(GroupData),
 		  TP = sum((mynewclasses == 1) .* (BinarySource(k,:) == 1)) / sum(BinarySource(k,:) == 1);
 
 	  	if NumFalsePositive > LocalMaxNumFP && TP > 0.5,  % large number of false positives and an acceptable true positive rate
-	  		while NumFalsePositive >= LocalMaxNumFP && MixedScoreCutoff > 0,
+	  		while NumFalsePositive >= LocalMaxNumFP && MixedScoreCutoff > 0
 	  			fprintf('Constant %8.4f False positives %4d\n',MixedScoreCutoff,sum((2 - (MixedScores <= MixedScoreCutoff) == 1) .* (BinarySource(k,:) == 2)));
 		  		MixedScoreCutoff = MixedScoreCutoff - 0.1;
 			  	NumFalsePositive = sum((2 - (MixedScores <= MixedScoreCutoff) == 1) .* (BinarySource(k,:) == 2));
@@ -405,66 +409,66 @@ for iii = 1:length(GroupData),
 	  		GroupData(motifnum).CutoffMethod = GroupData(motifnum).CutoffMethod + 2;
 	  	end
 
-	  elseif sum(Source == 2) > 20,                           % 3D and random sequences, few alignment sequences
+	elseif sum(Source == 2) > 20                 % 3D and random sequences, few alignment sequences
 	    MixedScoreCutoff = (quantile(RandomMixedScores,0.04)+quantile(RandomMixedScoresB,0.02))/2;  % find the cutoff which gets the true negative rate roughly equal to 98%
 	    MixedScoreCutoff = quantile(RandomMixedScores,0.05);  % find the cutoff which gets the true negative rate roughly equal to 96%
 	    MixedScoreCutoff = quantile(RandomMixedScores,0.04);  % find the cutoff which gets the true negative rate roughly equal to 96%
   		GroupData(motifnum).CutoffMethod = 6;
 
-	    if MixedScoreCutoff > 20,
-				fprintf('Decreased cutoff from %8.4f because the cutoff seemed overly generous\n',MixedScoreCutoff);
+	    if MixedScoreCutoff > 20
+			fprintf('Decreased cutoff from %8.4f because the cutoff seemed overly generous\n',MixedScoreCutoff);
 		    MixedScoreCutoff = max(20,min(RandomMixedScores)-0.1);
 		    MixedScoreCutoff = max(20,quantile(RandomMixedScores,0.02));  % find the cutoff which gets the true negative rate roughly equal to 98%
 	  		GroupData(motifnum).CutoffMethod = 8;
-			end
+		end
 
-	  elseif sum(Source == 2) == 0,                         % no random sequences meet the generic cutoffs
+	elseif sum(Source == 2) == 0,                         % no random sequences meet the generic cutoffs
 	  	MixedScoreCutoff = 35;                                        % impose essentially no model-specific cutoff
 	  	fprintf('No random sequence matches, so essentially no model-specific cutoff imposed\n');
   		GroupData(motifnum).CutoffMethod = 9;
 
-	  elseif sum(Source == 1) > NumAlignmentSequencesNeeded,                       % 3D and alignment sequences, few random sequences
+	elseif sum(Source == 1) > NumAlignmentSequencesNeeded,                       % 3D and alignment sequences, few random sequences
 	    MixedScoreCutoff = quantile(AlignmentMixedScores,0.90);                    % 90th percentile of alignment sequences
 	  	GroupData(motifnum).CutoffMethod = 10;
-		end
+	end
 
-		if MixedScoreCutoff < 9.5,
-			MixedScoreCutoff = 5 + Coeff(2);
-			MixedScoreCutoff = 9.5;
-			fprintf('Increased cutoff to %8.4f so that at least a few sequences with core edit distance 1 can meet the cutoff\n',MixedScoreCutoff);
-	  	GroupData(motifnum).CutoffMethod = 11;
-		end
+	if MixedScoreCutoff < 9.5
+		MixedScoreCutoff = 5 + Coeff(2);
+		MixedScoreCutoff = 9.5;
+		fprintf('Increased cutoff to %8.4f so that at least a few sequences with core edit distance 1 can meet the cutoff\n',MixedScoreCutoff);
+	GroupData(motifnum).CutoffMethod = 11;
+	end
 
-		if MixedScoreCutoff > 25,
-			MixedScoreCutoff = 25;
-			fprintf('Decreased cutoff to %8.4f so that it is possible to reject matches\n',MixedScoreCutoff);
-	  	GroupData(motifnum).CutoffMethod = 12;
-		end
+	if MixedScoreCutoff > 25
+		MixedScoreCutoff = 25;
+		fprintf('Decreased cutoff to %8.4f so that it is possible to reject matches\n',MixedScoreCutoff);
+		GroupData(motifnum).CutoffMethod = 12;
+	end
 
-	  mynewclasses = 2 - (MixedScores <= MixedScoreCutoff);
-	  TP = sum((mynewclasses == 1) .* (BinarySource(k,:) == 1)) / sum(BinarySource(k,:) == 1);
-	  TN = sum((mynewclasses == 2) .* (BinarySource(k,:) == 2)) / sum(BinarySource(k,:) == 2);
+	mynewclasses = 2 - (MixedScores <= MixedScoreCutoff);
+	TP = sum((mynewclasses == 1) .* (BinarySource(k,:) == 1)) / sum(BinarySource(k,:) == 1);
+	TN = sum((mynewclasses == 2) .* (BinarySource(k,:) == 2)) / sum(BinarySource(k,:) == 2);
 
-		GroupData(motifnum).TruePositiveRate           = TP;
-		GroupData(motifnum).TrueNegativeRate           = TN;
-		GroupData(motifnum).NumberOf3DSequences        = length(GroupData(motifnum).OwnScore);
-		GroupData(motifnum).NumberOfAlignmentSequences = sum(Source == 1);
-		GroupData(motifnum).NumberOfRandomSequences    = sum(Source == 2);
-		GroupData(motifnum).NumberOfFalsePositives     = sum((mynewclasses == 1) .* (Source(k,:) == 2));  % number of false positives
+	GroupData(motifnum).TruePositiveRate           = TP;
+	GroupData(motifnum).TrueNegativeRate           = TN;
+	GroupData(motifnum).NumberOf3DSequences        = length(GroupData(motifnum).OwnScore);
+	GroupData(motifnum).NumberOfAlignmentSequences = sum(Source == 1);
+	GroupData(motifnum).NumberOfRandomSequences    = sum(Source == 2);
+	GroupData(motifnum).NumberOfFalsePositives     = sum((mynewclasses == 1) .* (Source(k,:) == 2));  % number of false positives
 
-		GroupData(motifnum).DeficitCutoff    = Params.DeficitCutoff;
-		GroupData(motifnum).CoreEditCutoff   = Params.CoreEditCutoff;
+	GroupData(motifnum).DeficitCutoff    = Params.DeficitCutoff;
+	GroupData(motifnum).CoreEditCutoff   = Params.CoreEditCutoff;
 
-		GroupData(motifnum).DeficitEditCutoff = MixedScoreCutoff;
+	GroupData(motifnum).DeficitEditCutoff = MixedScoreCutoff;
 
-		GroupData(motifnum).MinScore        = max(GroupData(motifnum).OwnScore) - Params.DeficitCutoff;
-		GroupData(motifnum).MaxScore        = max(GroupData(motifnum).OwnScore);
-		GroupData(motifnum).ScoreEditCutoff = GroupData(motifnum).DeficitEditCutoff - Coeff(1) * max(GroupData(motifnum).OwnScore);
+	GroupData(motifnum).MinScore        = max(GroupData(motifnum).OwnScore) - Params.DeficitCutoff;
+	GroupData(motifnum).MaxScore        = max(GroupData(motifnum).OwnScore);
+	GroupData(motifnum).ScoreEditCutoff = GroupData(motifnum).DeficitEditCutoff - Coeff(1) * max(GroupData(motifnum).OwnScore);
 
-		m = motifnum;
-		GD = GroupData(motifnum);
-		fprintf('Group %3d, %-11s has acceptance rules AlignmentScore >= %8.4f, CoreEdit <= %d, and %8.4f * CoreEdit - %8.4f * AlignmentScore <= %8.4f\n',motifnum, GD.MotifID, GD.MinScore, GD.CoreEditCutoff, GD.CoreEditCoeff, GD.DeficitCoeff, GD.ScoreEditCutoff);
-		fprintf('TP %8.2f%%, TN %8.2f%%, min %8.2f%%, %3d 3D sequences, %5d alignment sequences, %4d random sequences, %4d random matches, %2d NTs, %s\n',100*GD.TruePositiveRate, 100*GD.TrueNegativeRate, 100*min(GD.TruePositiveRate,GD.TrueNegativeRate), GD.NumInstances, GD.NumberOfAlignmentSequences, GD.NumberOfRandomSequences, GD.NumberOfFalsePositives, GD.NumNT, GD.Signature{1});
+	m = motifnum;
+	GD = GroupData(motifnum);
+	fprintf('Group %3d, %-11s has acceptance rules AlignmentScore >= %8.4f, CoreEdit <= %d, and %8.4f * CoreEdit - %8.4f * AlignmentScore <= %8.4f\n',motifnum, GD.MotifID, GD.MinScore, GD.CoreEditCutoff, GD.CoreEditCoeff, GD.DeficitCoeff, GD.ScoreEditCutoff);
+	fprintf('TP %8.2f%%, TN %8.2f%%, min %8.2f%%, %3d 3D sequences, %5d alignment sequences, %4d random sequences, %4d random matches, %2d NTs, %s\n',100*GD.TruePositiveRate, 100*GD.TrueNegativeRate, 100*min(GD.TruePositiveRate,GD.TrueNegativeRate), GD.NumInstances, GD.NumberOfAlignmentSequences, GD.NumberOfRandomSequences, GD.NumberOfFalsePositives, GD.NumNT, GD.Signature{1});
 
     % ---------------------------- Deficit versus core edit distance - the graph that really matters
 		% ---------------- main figure - represent points from 3D, from alignments, random sequences
@@ -472,16 +476,16 @@ for iii = 1:length(GroupData),
     clf
 
     i = find(Source >= 2);                        % randomly-generated sequences
-    if length(i) > 2000,
+    if length(i) > 2000
     	i = i(1:2000);
     end
     ii = find(Source == 1);                        % sequences from alignments
-    if length(i) > 2000,
+    if length(i) > 2000
     	ii = ii(1:2000);
     end
     iii = find(Source == 0);                        % use all sequences from 3D
 
-		ced = 0.01:0.01:100;                                % range of core edit distances
+	ced = 0.01:0.01:100;                                % range of core edit distances
   	ycutoff = (GroupData(motifnum).DeficitEditCutoff - Coeff(2) * ced)/Coeff(1);
   	ar = find(ycutoff >= 0);
   	ced = ced(ar);
@@ -491,8 +495,8 @@ for iii = 1:length(GroupData),
   	cutofffifty = min(19.9,cutofffifty);
   	ar2 = find(cutofffifty >= 0);
 
-    if Grayscale > 0,
-			plot(ced,(GroupData(motifnum).DeficitEditCutoff - Coeff(2) * ced)/Coeff(1),'k','linewidth',3);
+    if Grayscale > 0
+		plot(ced,(GroupData(motifnum).DeficitEditCutoff - Coeff(2) * ced)/Coeff(1),'k','linewidth',3);
 	    hold on
 	    plot(SDR(i,2),SDR(i,1),'k.');
 	    plot(SDR(ii,2),SDR(ii,1),'x','color',0.6*[1 1 1]);
@@ -519,7 +523,7 @@ for iii = 1:length(GroupData),
 			plot(ced,cutofffifty,'color',cutofflines,'linewidth',3);
 			plot([0 5.5],[0 0],'k');
 			plot([0 0],[0 20],'k');
-			if ced(ar(end)) < 5.3,
+			if ced(ar(end)) < 5.3
 				text(ced(ar(end)),1,'0','color',cutofflines,'fontweight','bold','fontsize',20)
 			end
 			text(ced(ar2(end)),1,'50','color',cutofflines,'fontweight','bold','fontsize',20)
@@ -537,13 +541,13 @@ for iii = 1:length(GroupData),
 
 		axis([0 5.5 0 20]);                           % show every case on the same scale
 
-		if SaveDeficitCoreEditPlot > 0,
+		if SaveDeficitCoreEditPlot > 0
 			figure(1)
 			saveas(gcf,[MSCOutputPath filesep CurrentMotif '_alignment_random_sequences_method_' num2str(GroupData(motifnum).CutoffMethod) '_NumNT_' num2str(GroupData(motifnum).NumNT) '.png']);
 			saveas(gcf,[MSCOutputPath filesep CurrentMotif '_alignment_random_sequences_method_' num2str(GroupData(motifnum).CutoffMethod) '_NumNT_' num2str(GroupData(motifnum).NumNT) '.pdf']);
 		end
 
-		if PlotCutoffPlane > 0 && MixedScoreCutoff < Inf,
+		if PlotCutoffPlane > 0 && MixedScoreCutoff < Inf
 			figure(1)
 			hold on
 			ax = axis;
@@ -552,7 +556,7 @@ for iii = 1:length(GroupData),
 
 			xmax = 5.5;
 
-			for x = 0:xmax,
+			for x = 0:xmax
 				xx = x * ones(1,1001);                      % core edit values
 				yy = ax(3) + (0:1000)*(ax(4)-ax(3))/1000;   % sequence length values
 				zz = (MixedScoreCutoff - Coeff(2)*xx)/Coeff(1);        % values that exactly match the cutoff
@@ -560,7 +564,7 @@ for iii = 1:length(GroupData),
 				ii = find((zz < ax(4)) .* (zz > ax(3)));    % values to display on the screen without going above/below the current limits
 				plot3(xx(ii),yy(ii),zz(ii),'r');
 			end
-			for y = ax(3):ax(4),
+			for y = ax(3):ax(4)
 				xx = 0 + (0:1000)*ax(2)/1000;               % core edit values
 				yy = y * ones(1,1001);                      % sequence length values
 				zz = (MixedScoreCutoff - Coeff(2)*xx)/Coeff(1);
@@ -579,13 +583,13 @@ for iii = 1:length(GroupData),
 		fprintf('Motif index %d\n', iii);
 	  fprintf('\n');
 
-	  if pauseafter > 0,
+	  if pauseafter > 0
 	  	pause
 	  end
 	end
 end
 
-if SaveGroupData > 0,
+if SaveGroupData > 0
 	save([OutputPath filesep loopType '_GroupData_with_full_cutoffs.mat'],'GroupData');
 end
 
@@ -595,7 +599,7 @@ end
 
 CM = cat(1,GroupData.CutoffMethod);
 
-for j = 1:max(CM),
+for j = 1:max(CM)
 	datacounter(j) = sum(CM == j);
 end
 
@@ -615,7 +619,7 @@ CMText{9} = 'models had no random sequences and so no model-specific cutoff impo
 CMText{10} = 'models had the cutoff set from alignment sequences only';
 CMText{11} = 'models got the minimum cutoff';
 
-for j = 1:length(CMText),
+for j = 1:length(CMText)
 	fprintf('%3d (%6.2f%%) %s\n', datacounter(j), 100*datacounter(j)/length(GroupData), CMText{j});
 end
 
@@ -623,10 +627,10 @@ fprintf('%d groups, total in this table is %d\n',length(GroupData),sum(datacount
 
 % -------------- Write out model-specific cutoffs
 
-if isfield(GroupData,'ScoreEditCutoff'),
+if isfield(GroupData,'ScoreEditCutoff')
 	clear TN
 	clear TP
-	for m = 1:length(GroupData),
+	for m = 1:length(GroupData)
 		GD = GroupData(m);
 		TP(m) = GroupData(m).TruePositiveRate;
 		TN(m) = GroupData(m).TrueNegativeRate;
@@ -634,20 +638,20 @@ if isfield(GroupData,'ScoreEditCutoff'),
 		fprintf('TP %8.2f%%, TN %8.2f%%, min %8.2f%%, %3d 3D sequences, %5d alignment sequences, %5d random sequences, %4d random matches, %2d NTs, %s\n',100*GD.TruePositiveRate, 100*GD.TrueNegativeRate, 100*min(GD.TruePositiveRate,GD.TrueNegativeRate), GD.NumInstances, GD.NumberOfAlignmentSequences, GD.NumberOfRandomSequences, GD.NumberOfFalsePositives, GD.NumNT, GD.Signature{1});
 	end
 
-	if 0 > 1,
-		for m = 1:length(GroupData),
+	if 0 > 1
+		for m = 1:length(GroupData)
 			fprintf('Group %3d, %-11s has acceptance rules AlignmentScore >= %8.4f, CoreEdit <= %d, and %8.4f * CoreEdit - %8.4f * AlignmentScore <= %8.4f\n',m, GroupData(m).MotifID, GroupData(m).MinScore, GroupData(m).CoreEditCutoff, GroupData(m).CoreEditCoeff, GroupData(m).DeficitCoeff, GroupData(m).ScoreEditCutoff);
 		end
 	end
 
 	MSCOutputPath = [OutputPath filesep 'ModelSpecificCutoffs'];
 	fid = fopen([MSCOutputPath filesep loopType '_' MotifRelease '_acceptance_rule_numbers.txt'],'w');
-	for m = 1:length(GroupData),
+	for m = 1:length(GroupData)
 		fprintf(fid,'%s\t%0.8f\t%d\t%0.8f\t%0.8f\t%0.8f\n', GroupData(m).MotifID, GroupData(m).MinScore, GroupData(m).CoreEditCutoff, GroupData(m).CoreEditCoeff, GroupData(m).DeficitCoeff, GroupData(m).ScoreEditCutoff);
 	end
 	fclose(fid);
 
-	for m = 1:length(GroupData),
+	for m = 1:length(GroupData)
 		fid = fopen([ModelPath filesep GroupData(m).MotifID '_cutoffs.txt'],'w');
 		fprintf(fid,'%0.8f\t%d\t%0.8f\t%0.8f\t%0.8f\t%0.8f\t%0.8f\n', GroupData(m).MinScore, GroupData(m).CoreEditCutoff, GroupData(m).CoreEditCoeff, GroupData(m).DeficitCoeff, GroupData(m).ScoreEditCutoff, GroupData(m).DeficitEditCutoff, GroupData(m).MaxScore);
 		fclose(fid);
@@ -673,11 +677,13 @@ if isfield(GroupData,'ScoreEditCutoff'),
 	scatter(cat(1,GroupData.NumNT),cat(1,GroupData.DeficitEditCutoff),10,cutoffmethods,'filled');
 	hold on
 	x = 4:18;
-	switch loopType,
-	case 'IL'
-		plot(x,10+1.8*(x-5),'r');
+	switch loopType
 	case 'HL'
 		plot(x,10+3*(x-5),'r');
+	case 'IL'
+		plot(x,10+1.8*(x-5),'r');
+	otherwise
+		plot(x,10+1.8*(x-5),'r');
 	end
 	xlabel('Number of nucleotides');
 	ylabel('MixedScore cutoff');
diff --git a/matlab/pSetModelSpecificCutoffsTemp.m b/matlab/pSetModelSpecificCutoffsTemp.m
new file mode 100644
index 0000000..7ffe395
--- /dev/null
+++ b/matlab/pSetModelSpecificCutoffsTemp.m
@@ -0,0 +1,701 @@
+% pSetModelSpecificCutoffs sets model-specific cutoffs using data from alignments and randomly-generated data
+
+% Each sequence is represented by a structured variable whose fields are:
+% .Deficit
+% .CoreEdit
+% .FullEdit
+% .Conserved
+% .NumInstances
+% .MLPS
+% .Length
+% .Source    = 1 for alignment, = 2 for random but which maximizes alignment score, 2.2 for worse random sequences, etc.
+% .Sequence
+% .LoopID
+% .MotifID
+% .NumFixed
+% .Basepairs
+
+function [void] = pSetModelSpecificCutoffs(OutputBase,Release,UseAlignmentSequences)
+
+if nargin < 3,
+	UseAlignmentSequences = 2;               % use alignment sequences to set cutoffs and show them too
+	UseAlignmentSequences = 1;               % show alignment sequences but don't use them to set cutoffs
+	UseAlignmentSequences = 0;               % don't use or show alignment sequences
+end
+
+Params.DeficitCutoff    = 20;              % don't ever change this number because it has become hard-coded into the java code
+Params.CoreEditCutoff   = 5;
+
+Grayscale = 0;                              % plot in grayscale for the paper or in color for talks
+tfs = 13;
+
+if UseAlignmentSequences == 2,
+	NumAlignmentSequencesNeeded = 20;           % number for cutoffs based on alignment and random sequences
+else
+	NumAlignmentSequencesNeeded = Inf;          % for cutoffs based only on random sequences
+end
+
+Show2dPlots = 0;
+Show3dPlots = 0;
+Save3DPlots = 0;
+SaveDeficitCoreEditPlot = 1;
+SaveGroupData = 1;
+ListSequences = 0;
+PlotCutoffPlane = 0;
+CoreEditCutoff = 5;
+MaxNumFP = [200 200 400 500 600 800 1000];  % maximum number of false positives according to number of conserved basepairs
+MaxNumFP = [MaxNumFP Inf * ones(1,200)];
+Params.CutoffType = 2;
+
+if Save3DPlots > 0,
+	Show3dPlots = 1;
+end
+
+Release = strrep(Release,'/',filesep);
+Release = strrep(Release,'\',filesep);
+OutputPath = [OutputBase filesep Release];
+MotifRelease = Release(4:end);
+
+loopType = Release(1:2);
+
+ModelPath = [OutputPath filesep 'lib'];
+
+GroupData = pGetModelData(OutputPath,loopType);
+
+MSCOutputPath = [OutputPath filesep 'ModelSpecificCutoffs'];
+
+if ~(exist(MSCOutputPath) == 7),        % if directory doesn't yet exist
+  mkdir(MSCOutputPath);
+end
+
+DiaryFile = [MSCOutputPath filesep 'log_' date '.txt'];
+
+diary(DiaryFile);
+
+if ~(exist(MSCOutputPath) == 7),        % if directory doesn't yet exist
+  mkdir(MSCOutputPath);
+end
+
+if UseAlignmentSequences > 0 && ~exist('AlignmentData'),
+	load([OutputPath filesep loopType '_Alignment_Sequence_Data.mat']);
+	AlignmentData = SequenceData;
+	clear SequenceData
+
+	if isfield(AlignmentData,'Percentile'),
+		AlignmentData = rmfield(AlignmentData,'Percentile');
+	end
+
+	AlignmentDataMotifIDs = cell(1,length(AlignmentData));
+	for i = 1:length(AlignmentData),
+		AlignmentDataMotifIDs{i} = AlignmentData(i).MotifID;
+	end
+
+	fprintf('Loaded data from %d sequences from alignments\n',length(AlignmentData));
+else
+	AlignmentData = [];
+	AlignmentDataMotifIDs = {};
+end
+
+[y,motiforder] = sort(cat(1,GroupData.NumNT),1,'ascend');
+
+motiforder = 1:length(GroupData);
+
+for iii = 1:length(GroupData),
+
+	motifnum = motiforder(iii);
+	pauseafter = 0;
+
+	if ListSequences > 0,
+		clc
+	end
+
+	GroupData(motifnum)
+
+	CurrentMotif = GroupData(motifnum).MotifID;
+
+	% -------------------------- filter out poor alignment data
+
+	k = find(ismember(AlignmentDataMotifIDs,CurrentMotif));
+  SequenceData = AlignmentData(k);
+
+  if length(SequenceData) > 0,
+		ce = cat(1,SequenceData.CoreEdit);
+		k = find(ce <= CoreEditCutoff);
+		SequenceData = SequenceData(k);
+
+		def = cat(1,SequenceData.Deficit);
+		k = find(def <= Params.DeficitCutoff);
+		SequenceData = SequenceData(k);
+	  fprintf('Removed based on deficit, %d sequences remaining\n',length(SequenceData));
+		fprintf('%10d sequences from alignments with deficits between %d %d\n', length(SequenceData), 0, Params.DeficitCutoff);
+
+		[y,k] = sort(rand(1,length(SequenceData)));         % randomize order
+		SequenceData = SequenceData(k);
+	end
+
+	% ---------------------------- record data from motif group
+
+	clear NSD
+	for co = 1:GroupData(motifnum).NumInstances,
+		NSD(co).Deficit      = max(GroupData(motifnum).OwnScore) - GroupData(motifnum).OwnScore(co);
+		NSD(co).CoreEdit     = 0;
+		NSD(co).FullEdit     = 0;
+		NSD(co).Conserved    = GroupData(motifnum).NumNT;
+		NSD(co).NumInstances = GroupData(motifnum).NumInstances;
+		NSD(co).MLPS         = GroupData(motifnum).OwnScore(co);
+		NSD(co).Length       = length(GroupData(motifnum).OwnSequence{co}) - length(strfind(GroupData(motifnum).OwnSequence{co},'*'));
+		NSD(co).Source       = 0;                                    % from 3D structures
+		NSD(co).Basepairs    = GroupData(motifnum).NumBasepairs;
+		NSD(co).NumFixed     = GroupData(motifnum).NumFixed;
+		NSD(co).MotifID      = GroupData(motifnum).MotifID;
+		NSD(co).Sequence     = GroupData(motifnum).OwnSequence{1};
+	end
+
+	fprintf('%d sequences from 3D structures\n',length(NSD));
+
+	% ---------------------------- record data from random sequences
+
+	AllSD = [NSD SequenceData];      % put sequences from 3D first
+
+	if isfield(GroupData(motifnum),'DeficitEditData'),
+		RSNum = length(GroupData(motifnum).DeficitEditData(:,1));
+	else
+		fprintf('pSetModelSpecificCutoffs:  No data about how random sequences match the model\n');
+
+		for mm = 1:length(GroupData),
+			if ~isfield(GroupData(mm),'DeficitEditData'),
+				fprintf('Group %3d is missing DeficitEditData\n',mm);
+			end
+		end
+
+		pause
+		RSNum = 0;
+	end
+
+	fprintf('Using %d random sequences, %d from an alignment, and %d from 3D structures\n', RSNum, length(SequenceData), length(NSD));
+
+	if RSNum + length(AllSD) > 0,
+
+		clear SequenceData
+
+		Keep = ones(1,length(AllSD));
+		for i = 1:length(AllSD),
+			if isempty(AllSD(i).CoreEdit),
+				Keep(1,i) = 0;
+			end
+		end
+		AllSD = AllSD(find(Keep));
+
+		Source = cat(1,AllSD.Source);
+
+		clear SD
+		SD(:,1) = cat(1,AllSD.Deficit);
+		SD(:,2) = cat(1,AllSD.CoreEdit);
+		SD(:,3) = cat(1,AllSD.FullEdit);
+		SD(:,4) = cat(1,AllSD.Length);
+		SD(:,5) = cat(1,AllSD.Conserved);
+		SD(:,6) = SD(:,3) - SD(:,2);
+		SD(:,7) = cat(1,AllSD.MLPS);
+		SD(:,10) = cat(1,AllSD.NumFixed);
+		SD(:,11) = cat(1,AllSD.Basepairs);
+
+		if RSNum > 0,
+			clear RSD
+			RSD(:,1) = cat(1,GroupData(motifnum).DeficitEditData(:,1));
+			RSD(:,2) = cat(1,GroupData(motifnum).DeficitEditData(:,2));
+			RSD(:,3) = 99 * ones(RSNum,1);                                % just pretend
+			RSD(:,4) = zeros(RSNum,1);                                    % just pretend
+			RSD(:,5) = GroupData(motifnum).NumNT * ones(RSNum,1);
+			RSD(:,6) = RSD(:,3) - RSD(:,2);
+			RSD(:,7) = max(GroupData(motifnum).OwnScore) - RSD(:,1);
+			RSD(:,10) = GroupData(motifnum).NumFixed * ones(RSNum,1);
+			RSD(:,11) = GroupData(motifnum).NumBasepairs * ones(RSNum,1);
+
+			SD = [SD; RSD];              % append randomly-generated sequences
+		end
+
+		Source = [Source; 2*ones(RSNum,1)];
+
+		LL = length(Source);
+
+		clear SDR
+		SDR(:,1) = SD(:,1);
+		SDR(:,2) = SD(:,2) + 0.25*max(0,(min(Source,2)-1)) + 0.25*rand(LL,1);
+		i = find(Source == 0);
+		SDR(i,2) = SD(i,2);                  % no random shift for edit distances for sequences from 3D structures
+		SDR(:,3) = SD(:,3) + rand(LL,1)/4;
+		SDR(:,4) = SD(:,4) + rand(LL,1)/4;
+		SDR(:,5) = SD(:,5) + rand(LL,1)/4;
+		SDR(:,6) = SD(:,6) + rand(LL,1)/4;
+		SDR(:,7) = SD(:,7);
+		SDR(:,10) = SD(:,10) + rand(LL,1)/4;
+		SDR(:,11) = SD(:,11) + rand(LL,1)/4;
+
+		k = find((SD(:,2) == 0) .* (Source==2));        % random sequences with core edit distance 0
+		Source(k) = 3;
+
+		Names{1} = 'Alignment Score Deficit';
+		Names{2} = 'Interior Edit Distance';
+		Names{3} = 'FullEdit';
+		Names{4} = 'SequenceLength';
+		Names{5} = 'NumConserved';
+		Names{6} = 'FlankEdit';
+		Names{7} = 'AlignmentScore';
+	  Names{10} = 'NumFixed';
+	  Names{11} = 'Basepairs';
+
+		f = 1;
+	  if Show2dPlots > 0,
+			j = 1:min(length(Source),10000);
+
+		  n = [1 2 3 4 6 7];                  % which variables to plot and in what order
+
+			for a = 1:length(n),
+				for b = (a+1):length(n),
+					figure(f)
+					clf
+					scatter(SDR(j,n(a)),SDR(j,n(b)),4,min(Source(j),3),'filled');
+					caxis([1 4])
+					xlabel(Names{n(a)});
+					ylabel(Names{n(b)});
+					f = f + 1;
+				end
+			end
+		end
+
+		if Show3dPlots > 0,
+
+			Triple(1,:) = [1 2 8];
+			Triple(2,:) = [1 2 9];
+			Triple(3,:) = [1 2 4];
+			Triple(4,:) = [4 5 1];
+			Triple(5,:) = [4 5 7];
+			Triple(6,:) = [3 5 11];
+			Triple(7,:) = [4 5 10];
+			Triple(8,:) = [2 4 7];
+
+	  	clear Triple
+
+			Triple(1,:) = [2 4 1];
+
+			j = 1:min(2000,length(Source));  % plot up to 2000 points
+			j = [j find(Source == 0)'];
+
+			for t = 1:length(Triple(:,1)),
+				figure(f)
+				[ax,az] = view;
+				clf
+				clf
+				scatter3(SDR(j,Triple(t,1)),SDR(j,Triple(t,2)),SDR(j,Triple(t,3)),4+40*(Source(j) == 0),min(Source(j),2),'filled')
+				xlabel(Names{Triple(t,1)});
+				ylabel(Names{Triple(t,2)});
+				zlabel(Names{Triple(t,3)});
+				rotate3d on
+				caxis([-0.5 3]);
+				view([ax az]);                % keep the current orientation
+				drawnow
+				f = f + 1;
+				axis([0 5.2 0 20 0 20]);                           % show every case on the same scale
+				view([0 0]);
+			end
+		end
+
+		DeficitCoeff = GroupData(motifnum).DeficitCoeff;
+		GroupData(motifnum).CoreEditCoeff = 3;               % insist on this being 3
+		CoreEditCoeff = GroupData(motifnum).CoreEditCoeff;
+		Coeff = [DeficitCoeff CoreEditCoeff];
+
+		BinarySource = 1*(Source <= 1) + 2*(Source > 1);
+
+		i = [2 4 1];  % core edit, sequence length, deficit
+
+  	if ListSequences > 0,
+  		OrderMatrix = [BinarySource SD(:,7)];
+  		[y,ii] = sortrows(OrderMatrix,[1 2]);
+  		for n = 1:length(ii),
+  			j = ii(n);
+  			fprintf('Source %d %50s CoreEdit %d Score %8.4f Deficit %8.4f \n', Source(j), AllSD(j).Sequence, SD(j,2), SD(j,7), SD(j,1));
+  		end
+  	end
+
+		ra = find(Source == 1);
+    AlignmentMixedScores = SD(ra,[1 2]) * Coeff';          % scores of these sequences against current coefficients
+
+		ra = find(Source == 2);
+    RandomMixedScores = SD(ra,[1 2]) * Coeff';             % scores of these sequences against current coefficients
+
+		ra = find((Source == 2) .* (SD(:,2) > 1));             % random sequences at core edit distance 2 or greater
+    RandomMixedScoresB = SD(ra,[1 2]) * Coeff';            % scores of these sequences against current coefficients
+
+		GroupData(motifnum).RandomQuantile80 = quantile(RandomMixedScores,0.2);
+		GroupData(motifnum).RandomQuantile96 = quantile(RandomMixedScores,0.04);
+		GroupData(motifnum).RandomQuantile98 = quantile(RandomMixedScores,0.02);
+
+		switch loopType,
+		case 'IL'
+			DefaultMixedScoreCutoff = min(25,10+1.8*(GroupData(motifnum).NumNT-5));
+		case 'HL'
+			DefaultMixedScoreCutoff = min(25,10+3*(GroupData(motifnum).NumNT-5));
+		end
+		MixedScoreCutoff = DefaultMixedScoreCutoff;
+ 		GroupData(motifnum).CutoffMethod = 1;
+
+    figure(2)
+  	clf
+
+  	k = find((Source <= 1) + (Source == 2).*(SD(:,2) > 0));  % only use alignment sequences and "bad" random sequences
+  	MixedScores = SD(k,[1 2]) * Coeff';
+
+		if sum(Source == 2) > 0 && sum(Source <= 1) > NumAlignmentSequencesNeeded,  % enough of both random and alignment sequences
+
+			% find the cutoff which maximizes the TN - (1-TP) rate, if large enough
+	  	MixedScoreValues = 0:0.1:40;
+	  	performance = zeros(length(MixedScoreValues),3);
+
+	  	for c = 1:length(MixedScoreValues),
+	  	  mynewclasses = 2 - (MixedScores <= MixedScoreValues(c));
+	  	  TP = sum((mynewclasses == 1) .* (BinarySource(k,:) == 1)) / sum(BinarySource(k,:) == 1);
+	  	  TN = sum((mynewclasses == 2) .* (BinarySource(k,:) == 2)) / sum(BinarySource(k,:) == 2);
+				performance(c,:) = [TP TN TN-(1-TP)];
+	  	end
+
+	  	[mm,ii] = max(performance(:,3));
+
+			if mm > 0.1 && mm < 0.4
+				fprintf('Borderline case for imposing a model-specific cutoff, maximum %8.4f\n',mm);
+			end
+
+			if min(performance(:,3)) < -0.5,
+				fprintf('Many random sequences perform better than sequences from alignments.\n');
+			end
+
+	  	figure(2)
+	  	clf
+	  	plot(MixedScoreValues,performance(:,3));
+	  	hold on
+	  	plot(MixedScoreValues,mm-0.02,'r');
+	  	xlabel('MixedScore before adjustments')
+	  	drawnow
+
+	  	if mm > 0.2,                                              % random matches occur where true positives do not
+	  		ii = sort(find(performance(:,3) > mm-0.02));            % find places with nearly as good a performance
+	  		MixedScoreCutoff = MixedScoreValues(ii(1));                          % use the most restrictive one
+	  		fprintf('MixedScore cutoff set to maximize TN - (1 - TP)\n');
+	  		fprintf('TP rate %8.4f, TN rate %8.4f\n', 100*performance(ii(1),1), 100*performance(ii(1),2));
+	  		GroupData(motifnum).CutoffMethod = 2;
+	  	else
+		    MixedScoreCutoff = (quantile(RandomMixedScores,0.04)+quantile(RandomMixedScoresB,0.02))/2;  % find the cutoff which gets the true negative rate roughly equal to 98%
+	  		fprintf('Setting cutoff by percentiles of random sequences, %8.4f\n',MixedScoreCutoff);
+	  		GroupData(motifnum).CutoffMethod = 3;
+	  	end
+
+	  	LocalMaxNumFP = MaxNumFP(GroupData(motifnum).NumBasepairs);
+
+	  	NumFalsePositive = sum((2 - (MixedScores <= MixedScoreCutoff) == 1) .* (BinarySource(k,:) == 2));
+ 		  mynewclasses = 2 - (MixedScores <= MixedScoreCutoff);
+		  TP = sum((mynewclasses == 1) .* (BinarySource(k,:) == 1)) / sum(BinarySource(k,:) == 1);
+
+	  	if NumFalsePositive > LocalMaxNumFP && TP > 0.5,  % large number of false positives and an acceptable true positive rate
+	  		while NumFalsePositive >= LocalMaxNumFP && MixedScoreCutoff > 0,
+	  			fprintf('Constant %8.4f False positives %4d\n',MixedScoreCutoff,sum((2 - (MixedScores <= MixedScoreCutoff) == 1) .* (BinarySource(k,:) == 2)));
+		  		MixedScoreCutoff = MixedScoreCutoff - 0.1;
+			  	NumFalsePositive = sum((2 - (MixedScores <= MixedScoreCutoff) == 1) .* (BinarySource(k,:) == 2));
+	  		end
+    		fprintf('Tightened the cutoff to reduce the sheer number of false positives\n');
+	  		GroupData(motifnum).CutoffMethod = GroupData(motifnum).CutoffMethod + 2;
+	  	end
+
+	  elseif sum(Source == 2) > 20,                           % 3D and random sequences, few alignment sequences
+	    MixedScoreCutoff = (quantile(RandomMixedScores,0.04)+quantile(RandomMixedScoresB,0.02))/2;  % find the cutoff which gets the true negative rate roughly equal to 98%
+	    MixedScoreCutoff = quantile(RandomMixedScores,0.05);  % find the cutoff which gets the true negative rate roughly equal to 96%
+	    MixedScoreCutoff = quantile(RandomMixedScores,0.04);  % find the cutoff which gets the true negative rate roughly equal to 96%
+  		GroupData(motifnum).CutoffMethod = 6;
+
+	    if MixedScoreCutoff > 20,
+				fprintf('Decreased cutoff from %8.4f because the cutoff seemed overly generous\n',MixedScoreCutoff);
+		    MixedScoreCutoff = max(20,min(RandomMixedScores)-0.1);
+		    MixedScoreCutoff = max(20,quantile(RandomMixedScores,0.02));  % find the cutoff which gets the true negative rate roughly equal to 98%
+	  		GroupData(motifnum).CutoffMethod = 8;
+			end
+
+	  elseif sum(Source == 2) == 0,                         % no random sequences meet the generic cutoffs
+	  	MixedScoreCutoff = 35;                                        % impose essentially no model-specific cutoff
+	  	fprintf('No random sequence matches, so essentially no model-specific cutoff imposed\n');
+  		GroupData(motifnum).CutoffMethod = 9;
+
+	  elseif sum(Source == 1) > NumAlignmentSequencesNeeded,                       % 3D and alignment sequences, few random sequences
+	    MixedScoreCutoff = quantile(AlignmentMixedScores,0.90);                    % 90th percentile of alignment sequences
+	  	GroupData(motifnum).CutoffMethod = 10;
+		end
+
+		if MixedScoreCutoff < 9.5,
+			MixedScoreCutoff = 5 + Coeff(2);
+			MixedScoreCutoff = 9.5;
+			fprintf('Increased cutoff to %8.4f so that at least a few sequences with core edit distance 1 can meet the cutoff\n',MixedScoreCutoff);
+	  	GroupData(motifnum).CutoffMethod = 11;
+		end
+
+		if MixedScoreCutoff > 25,
+			MixedScoreCutoff = 25;
+			fprintf('Decreased cutoff to %8.4f so that it is possible to reject matches\n',MixedScoreCutoff);
+	  	GroupData(motifnum).CutoffMethod = 12;
+		end
+
+	  mynewclasses = 2 - (MixedScores <= MixedScoreCutoff);
+	  TP = sum((mynewclasses == 1) .* (BinarySource(k,:) == 1)) / sum(BinarySource(k,:) == 1);
+	  TN = sum((mynewclasses == 2) .* (BinarySource(k,:) == 2)) / sum(BinarySource(k,:) == 2);
+
+		GroupData(motifnum).TruePositiveRate           = TP;
+		GroupData(motifnum).TrueNegativeRate           = TN;
+		GroupData(motifnum).NumberOf3DSequences        = length(GroupData(motifnum).OwnScore);
+		GroupData(motifnum).NumberOfAlignmentSequences = sum(Source == 1);
+		GroupData(motifnum).NumberOfRandomSequences    = sum(Source == 2);
+		GroupData(motifnum).NumberOfFalsePositives     = sum((mynewclasses == 1) .* (Source(k,:) == 2));  % number of false positives
+
+		GroupData(motifnum).DeficitCutoff    = Params.DeficitCutoff;
+		GroupData(motifnum).CoreEditCutoff   = Params.CoreEditCutoff;
+
+		GroupData(motifnum).DeficitEditCutoff = MixedScoreCutoff;
+
+		GroupData(motifnum).MinScore        = max(GroupData(motifnum).OwnScore) - Params.DeficitCutoff;
+		GroupData(motifnum).MaxScore        = max(GroupData(motifnum).OwnScore);
+		GroupData(motifnum).ScoreEditCutoff = GroupData(motifnum).DeficitEditCutoff - Coeff(1) * max(GroupData(motifnum).OwnScore);
+
+		m = motifnum;
+		GD = GroupData(motifnum);
+		fprintf('Group %3d, %-11s has acceptance rules AlignmentScore >= %8.4f, CoreEdit <= %d, and %8.4f * CoreEdit - %8.4f * AlignmentScore <= %8.4f\n',motifnum, GD.MotifID, GD.MinScore, GD.CoreEditCutoff, GD.CoreEditCoeff, GD.DeficitCoeff, GD.ScoreEditCutoff);
+		fprintf('TP %8.2f%%, TN %8.2f%%, min %8.2f%%, %3d 3D sequences, %5d alignment sequences, %4d random sequences, %4d random matches, %2d NTs, %s\n',100*GD.TruePositiveRate, 100*GD.TrueNegativeRate, 100*min(GD.TruePositiveRate,GD.TrueNegativeRate), GD.NumInstances, GD.NumberOfAlignmentSequences, GD.NumberOfRandomSequences, GD.NumberOfFalsePositives, GD.NumNT, GD.Signature{1});
+
+    % ---------------------------- Deficit versus core edit distance - the graph that really matters
+		% ---------------- main figure - represent points from 3D, from alignments, random sequences
+    figure(1)
+    clf
+
+    i = find(Source >= 2);                        % randomly-generated sequences
+    if length(i) > 2000,
+    	i = i(1:2000);
+    end
+    ii = find(Source == 1);                        % sequences from alignments
+    if length(i) > 2000,
+    	ii = ii(1:2000);
+    end
+    iii = find(Source == 0);                        % use all sequences from 3D
+
+		ced = 0.01:0.01:100;                                % range of core edit distances
+  	ycutoff = (GroupData(motifnum).DeficitEditCutoff - Coeff(2) * ced)/Coeff(1);
+  	ar = find(ycutoff >= 0);
+  	ced = ced(ar);
+  	ycutoff = ycutoff(ar);
+  	cutofffifty = ycutoff - 0.5*ycutoff(1);
+  	ycutoff = min(19.9,ycutoff);
+  	cutofffifty = min(19.9,cutofffifty);
+  	ar2 = find(cutofffifty >= 0);
+
+    if Grayscale > 0,
+			plot(ced,(GroupData(motifnum).DeficitEditCutoff - Coeff(2) * ced)/Coeff(1),'k','linewidth',3);
+	    hold on
+	    plot(SDR(i,2),SDR(i,1),'k.');
+	    plot(SDR(ii,2),SDR(ii,1),'x','color',0.6*[1 1 1]);
+	    plot(SDR(iii,2),SDR(iii,1),'x','Color',0.3*[1 1 1],'MarkerSize',8,'LineWidth',2);
+	  else
+	  	mediumorchid1 = [224	102	255]/255;
+	  	thistle1 = [255	225	255]/255;
+
+	  	Lightgreen = [233 250 233]/255;
+			Darkgreen  = [211 227 211]/255;
+
+			background = Lightgreen;
+			cutofflines = Darkgreen;
+
+			background = thistle1;
+			cutofflines = thistle1*0.7;
+
+			background = 0.85*[1 1 1];
+			cutofflines = 0.5*[1 1 1];
+
+			patch([0.01 ced 0.01],[0.01 ycutoff 0.01],background)
+			hold on
+			plot(ced,ycutoff,'color',cutofflines,'linewidth',3);
+			plot(ced,cutofffifty,'color',cutofflines,'linewidth',3);
+			plot([0 5.5],[0 0],'k');
+			plot([0 0],[0 20],'k');
+			if ced(ar(end)) < 5.3,
+				text(ced(ar(end)),1,'0','color',cutofflines,'fontweight','bold','fontsize',20)
+			end
+			text(ced(ar2(end)),1,'50','color',cutofflines,'fontweight','bold','fontsize',20)
+			text(0.1,1,'100','color',cutofflines,'fontweight','bold','fontsize',20)
+%	    scatter(SDR(i,2),SDR(i,1),4,'r','filled');
+%	    scatter(SDR(ii,2),SDR(ii,1),4,'k','filled');
+	    plot(SDR(iii,2),SDR(iii,1),'bx','MarkerSize',14,'LineWidth',3);
+	  end
+		NameForTitle = strrep(GroupData(motifnum).MotifID,'_','\_');
+		xlabel(['Minimum interior edit distance to 3D instances in ' NameForTitle],'fontsize',tfs);
+		ylabel('Alignment score deficit','fontsize',tfs)
+		title(['Random and alignment sequences for ' NameForTitle],'fontsize',tfs);
+		set(gca,'fontsize',tfs);
+		set(gca,'XTick',0:5);
+
+		axis([0 5.5 0 20]);                           % show every case on the same scale
+
+		if SaveDeficitCoreEditPlot > 0,
+			figure(1)
+			saveas(gcf,[MSCOutputPath filesep CurrentMotif '_temp_alignment_random_sequences_method_' num2str(GroupData(motifnum).CutoffMethod) '_NumNT_' num2str(GroupData(motifnum).NumNT) '.png']);
+			saveas(gcf,[MSCOutputPath filesep CurrentMotif '_temp_alignment_random_sequences_method_' num2str(GroupData(motifnum).CutoffMethod) '_NumNT_' num2str(GroupData(motifnum).NumNT) '.pdf']);
+		end
+
+		if PlotCutoffPlane > 0 && MixedScoreCutoff < Inf,
+			figure(1)
+			hold on
+			ax = axis;
+			xmax = min(5.5,max(ax(2),2));
+			xmax = ax(2);
+
+			xmax = 5.5;
+
+			for x = 0:xmax,
+				xx = x * ones(1,1001);                      % core edit values
+				yy = ax(3) + (0:1000)*(ax(4)-ax(3))/1000;   % sequence length values
+				zz = (MixedScoreCutoff - Coeff(2)*xx)/Coeff(1);        % values that exactly match the cutoff
+				ii = find((zz < max(SD(:,1))) .* (zz > min(SD(:,1))));    % values to display on the screen without going above/below the current limits
+				ii = find((zz < ax(4)) .* (zz > ax(3)));    % values to display on the screen without going above/below the current limits
+%				plot3(xx(ii),yy(ii),zz(ii),'r');
+			end
+			for y = ax(3):ax(4),
+				xx = 0 + (0:1000)*ax(2)/1000;               % core edit values
+				yy = y * ones(1,1001);                      % sequence length values
+				zz = (MixedScoreCutoff - Coeff(2)*xx)/Coeff(1);
+				ii = find((zz < max(SD(:,1))) .* (zz > min(SD(:,1))));    % values to display on the screen without going above/below the current limits
+				ii = find((zz < ax(4)) .* (zz > ax(3)));    % values to display on the screen without going above/below the current limits
+%				plot3(xx(ii),yy(ii),zz(ii),'r');
+			end
+			view([0 0]);
+%			axis(ax);
+			drawnow
+		end
+
+		fprintf('Sensitivity %6.2f%%, Specificity %6.2f%%, Minimum %6.2f%% using method %d\n', 100*TP, 100*TN, 100*min(TP,TN),GroupData(motifnum).CutoffMethod);
+		fprintf('Number of false positives with core edit > 0 is %d\n',sum((mynewclasses == 1) .* (Source(k,:) == 2)));
+		fprintf('%d * Deficit + %d * Core Edit <= %0.4f\n', Coeff(1), Coeff(2), GroupData(motifnum).DeficitEditCutoff);
+		fprintf('Motif index %d\n', iii);
+	  fprintf('\n');
+
+	  if pauseafter > 0,
+	  	pause
+	  end
+	end
+end
+
+if SaveGroupData > 0,
+	save([OutputPath filesep loopType '_GroupData_with_full_cutoffs.mat'],'GroupData');
+end
+
+% load([OutputPath filesep loopType '_GroupData_with_full_cutoffs.mat']);
+
+% -------------- Summarize the type of decisions that were made
+
+CM = cat(1,GroupData.CutoffMethod);
+
+for j = 1:max(CM),
+	datacounter(j) = sum(CM == j);
+end
+
+%datacounter(2) = sum(datacounter([2 4]));
+%datacounter(3) = sum(datacounter([3 5]));
+%datacounter(6) = sum(datacounter([6 7 8]));
+
+CMText{1} = 'models got the default cutoff from model size';
+CMText{2} = 'models had their cutoff set by maximizing TP+TN';
+CMText{3} = 'models got the default cutoff plus 2';
+CMText{4} = 'models with cutoffs from TP+TN had the cutoff tightened to reduce false positives';
+CMText{5} = 'models with default plus 2 had the cutoff tightened to reduce false positives';
+CMText{6} = 'models had cutoff set from random sequences only';
+CMText{7} = 'random cutoff models had their cutoff made more generous';
+CMText{8} = 'random cutoff models had their cutoff made more restrictive';
+CMText{9} = 'models had no random sequences and so no model-specific cutoff imposed';
+CMText{10} = 'models had the cutoff set from alignment sequences only';
+CMText{11} = 'models got the minimum cutoff';
+
+for j = 1:length(CMText),
+	fprintf('%3d (%6.2f%%) %s\n', datacounter(j), 100*datacounter(j)/length(GroupData), CMText{j});
+end
+
+fprintf('%d groups, total in this table is %d\n',length(GroupData),sum(datacounter));
+
+% -------------- Write out model-specific cutoffs
+
+if isfield(GroupData,'ScoreEditCutoff'),
+	clear TN
+	clear TP
+	for m = 1:length(GroupData),
+		GD = GroupData(m);
+		TP(m) = GroupData(m).TruePositiveRate;
+		TN(m) = GroupData(m).TrueNegativeRate;
+		fprintf('Group %3d, %-11s has acceptance rules %8.4f - AlignmentScore <= %8.4f, CoreEdit <= %d, and %8.4f * (%8.4f - AlignmentScore) + %8.4f * CoreEdit <= %8.4f, method %2d,',m, GD.MotifID, max(GD.OwnScore), GD.DeficitCutoff, GD.CoreEditCutoff, GD.DeficitCoeff, max(GD.OwnScore), GD.CoreEditCoeff, GD.DeficitEditCutoff, GD.CutoffMethod);
+		fprintf('TP %8.2f%%, TN %8.2f%%, min %8.2f%%, %3d 3D sequences, %5d alignment sequences, %5d random sequences, %4d random matches, %2d NTs, %s\n',100*GD.TruePositiveRate, 100*GD.TrueNegativeRate, 100*min(GD.TruePositiveRate,GD.TrueNegativeRate), GD.NumInstances, GD.NumberOfAlignmentSequences, GD.NumberOfRandomSequences, GD.NumberOfFalsePositives, GD.NumNT, GD.Signature{1});
+	end
+
+	if 0 > 1,
+		for m = 1:length(GroupData),
+			fprintf('Group %3d, %-11s has acceptance rules AlignmentScore >= %8.4f, CoreEdit <= %d, and %8.4f * CoreEdit - %8.4f * AlignmentScore <= %8.4f\n',m, GroupData(m).MotifID, GroupData(m).MinScore, GroupData(m).CoreEditCutoff, GroupData(m).CoreEditCoeff, GroupData(m).DeficitCoeff, GroupData(m).ScoreEditCutoff);
+		end
+	end
+
+	MSCOutputPath = [OutputPath filesep 'ModelSpecificCutoffs'];
+	fid = fopen([MSCOutputPath filesep loopType '_' MotifRelease '_acceptance_rule_numbers.txt'],'w');
+	for m = 1:length(GroupData),
+		fprintf(fid,'%s\t%0.8f\t%d\t%0.8f\t%0.8f\t%0.8f\n', GroupData(m).MotifID, GroupData(m).MinScore, GroupData(m).CoreEditCutoff, GroupData(m).CoreEditCoeff, GroupData(m).DeficitCoeff, GroupData(m).ScoreEditCutoff);
+	end
+	fclose(fid);
+
+	for m = 1:length(GroupData),
+		fid = fopen([ModelPath filesep GroupData(m).MotifID '_cutoffs.txt'],'w');
+		fprintf(fid,'%0.8f\t%d\t%0.8f\t%0.8f\t%0.8f\t%0.8f\t%0.8f\n', GroupData(m).MinScore, GroupData(m).CoreEditCutoff, GroupData(m).CoreEditCoeff, GroupData(m).DeficitCoeff, GroupData(m).ScoreEditCutoff, GroupData(m).DeficitEditCutoff, GroupData(m).MaxScore);
+		fclose(fid);
+	end
+
+	figure(5)
+	clf
+	%hist(100*ma(ma > 0),30);
+	subplot(2,1,1)
+	hist(100*TP(TP > 0),30);
+	hist(100*TP,30);
+	xlabel(['True positive rate for ' loopType ' models']);
+	subplot(2,1,2)
+	hist(100*TN(TN > 0),30);
+	hist(100*TN,30);
+	xlabel(['True negative rate for ' loopType ' models']);
+
+	saveas(gcf,[MSCOutputPath filesep loopType '_TP_TN_rate_histogram.png']);
+
+	figure(3)
+	clf
+	cutoffmethods = cat(1,GroupData.CutoffMethod);
+	scatter(cat(1,GroupData.NumNT),cat(1,GroupData.DeficitEditCutoff),10,cutoffmethods,'filled');
+	hold on
+	x = 4:18;
+	switch loopType,
+	case 'IL'
+		plot(x,10+1.8*(x-5),'r');
+	case 'HL'
+		plot(x,10+3*(x-5),'r');
+	end
+	xlabel('Number of nucleotides');
+	ylabel('MixedScore cutoff');
+	title('Colored by CutoffMethod');
+	caxis([min(cutoffmethods)-0.5 max(cutoffmethods)+0.5])
+	colorbar('eastoutside')
+
+	figure(6)
+	clf
+	scatter(cat(1,GroupData.RandomQuantile96),cat(1,GroupData.DeficitEditCutoff),10,cat(1,GroupData.CutoffMethod),'filled');
+	hold on
+	plot(0:35,0:35,'r');
+	xlabel('96th percentile of MixedScore of random sequences');
+	ylabel('MixedScore cutoff');
+	title('Colored by CutoffMethod');
+	caxis([min(cutoffmethods)-0.5 max(cutoffmethods)+0.5])
+	colorbar('eastoutside')
+
+end
+
+diary off
diff --git a/matlab/pStrandBreaksBetween.m b/matlab/pStrandBreaksBetween.m
new file mode 100644
index 0000000..5955a6c
--- /dev/null
+++ b/matlab/pStrandBreaksBetween.m
@@ -0,0 +1,6 @@
+% pStrandBreaksBetween(a,B,Truncate) counts the number of strand breaks after a
+% and before or at B
+
+function [count] = pStrandBreaksBetween(a,B,Truncate)
+    count = sum(B >= Truncate) - sum(a > Truncate);
+end
\ No newline at end of file
diff --git a/matlab/pUpdateModelWithSSF.m b/matlab/pUpdateModelWithSSF.m
index 7a1d599..0d6b39f 100644
--- a/matlab/pUpdateModelWithSSF.m
+++ b/matlab/pUpdateModelWithSSF.m
@@ -12,17 +12,25 @@ Verbose = Param(1);
 [L,N] = size(Search.Candidates);        % L = num instances; N = num NT
 N = N - 1;                              % number of nucleotides
 
-Noncanonical = [];
-switch loopType,
-case 'HL'
-  if N >= 4,
-    Noncanonical = [2 N-1];
-  end
-case 'IL'
-  if Search.Truncate > 2 && N - Search.Truncate > 2,  % number of nucleotides on each strand
-    Noncanonical = [[2 N-1]; [Search.Truncate-1 Search.Truncate+2]];
-  end
+% apparently Noncanonical is not actually being used
+% if we do want to use it, we should check the new code below
+Noncanonical = ones(1,N);
+Noncanonical(1) = 0;
+Noncanonical(N) = 0;
+for k = 1:length(Search.chainbreak)
+    Noncanonical(Search.chainbreak{k}) = 0;
+    Noncanonical(Search.chainbreak{k}+1) = 0;
 end
+% switch loopType
+% case 'HL'
+%   if N >= 4
+%     Noncanonical = [2 N-1];
+%   end
+% case 'IL'
+%   if Search.Truncate > 2 && N - Search.Truncate > 2  % number of nucleotides on each strand
+%     Noncanonical = [[2 N-1]; [Search.Truncate-1 Search.Truncate+2]];
+%   end
+% end
 
 if nargin < 9,
     UseCandidate = 1:L;                     % Use all instances
@@ -79,7 +87,7 @@ for n = 1:length(Node),
             % ----------------------------- fixed base on the left
             letter = zeros(size(Prior));                     % record which bases occur
 
-            if length(Node(n).leftLengthDist) > 1,           % fixed base on left
+            if length(Node(n).leftLengthDist) > 1            % fixed base on left
                 a = Node(n).LeftIndex;                       % index within file
                 for c = 1:L,                                 % loop through candidates
                     ff = Search.Candidates(UseCandidate(c),N+1); % file number
@@ -92,11 +100,16 @@ for n = 1:length(Node),
 
                 Pr = Prior;
 
-                for e = 1:3,                                        % loop through edges
-                    if Param(10) > 0 && sum(Search.BPh(a,:)==e) > 0,
+                % disp('pUpdateModelWithSSF line 103')
+                % Search
+                % Node(n)
+                % a
+
+                for e = 1:3                                        % loop through edges
+                    if Param(10) > 0 && sum(Search.BPh(a,:)==e) > 0
                         Pr = Pr / Param(10);                  % weaken the prior distribution
 %                        fprintf('pUpdateModelWithSSF: Fixed node gets new distribution on the left from BPh made by base %d using edge %d\n',a,e);
-                    elseif Param(11) > 0 && sum(Search.BR(a,:)==e) > 0,
+                    elseif Param(11) > 0 && sum(Search.BR(a,:)==e) > 0
                         Pr = Pr / Param(11);                  % weaken the prior distribution
 %                        fprintf('pUpdateModelWithSSF: Fixed node gets new distribution on the left from BR made by base %d using edge %d\n',a,e);
                     end
diff --git a/matlab/pWriteSequencesWithRotations.m b/matlab/pWriteSequencesWithRotations.m
index 083ff49..e86b986 100644
--- a/matlab/pWriteSequencesWithRotations.m
+++ b/matlab/pWriteSequencesWithRotations.m
@@ -1,47 +1,52 @@
-% pWriteSequencesWithRotations writes the sequences in FASTA to a file, and if they are from an internal loop, rotates the sequences and writes them again, etc.
+% pWriteSequencesWithRotations writes the sequences in FASTA to a file, and if they
+% are from an internal loop, rotates the sequences and writes them again, etc.
 
-function [AllSequencesFile] = pWriteSequencesWithRotations(ModelPath,FASTA,loopType,Rotations,CF)
+function [AllSequencesFile,rotatedFASTA] = pWriteSequencesWithRotations(DiagnosticPath,FASTA,loopType,Rotations,CF)
 
-if nargin < 5,
+% in the future, use loopType to determine the number of rotations,
+% especially if you want to do every permutation of the strands for J3, J4, etc.
+
+if nargin < 5
   CF = '';
 end
 
-r = 1;                          % first rotation
-AllSequencesFile{1} = [ModelPath filesep CF '_All_Sequences_' num2str(r) '.fasta'];
+r = 1;                          % write first rotation
+rotatedFASTA{r} = FASTA;
+AllSequencesFile{1} = [DiagnosticPath filesep CF '_All_Sequences_' num2str(r) '.fasta'];
 fid = fopen(AllSequencesFile{1},'w');
-for n = 1:length(FASTA),
+for n = 1:length(FASTA)
   fprintf(fid,'>%s\n',FASTA(n).Header);
   fprintf(fid,'%s\n',FASTA(n).Sequence);
-end  
-fclose(fid);
-
-if Rotations > 1,                       % more than one rotation, for IL, JL
-  FASTA_R = FASTA;
 end
+fclose(fid);
 
-for r = 2:Rotations,
-  for n = 1:length(FASTA_R),
-    a = FASTA_R(n).Sequence;
-    b = FASTA_R(n).Aligned;
-
-    % fprintf('%s and %s become ', a, b);
-
-    i = strfind(a,'*');
-    a = [a((i(1)+1):end) '*' a(1:(i(1)-1))];
-    i = strfind(b,'*');
-    b = [b((i(1)+1):end) '*' b(1:(i(1)-1))];
-
-    % fprintf('%s and %s.\n', a, b);
-
-    FASTA_R(n).Sequence = a;
-    FASTA_R(n).Aligned = b;
+if Rotations > 1                       % more than one rotation, for IL, J3
+  FASTA_R = FASTA;                     % start with the same FASTA data each time
+
+  for r = 2:Rotations
+    for n = 1:length(FASTA_R)
+      a = FASTA_R(n).Sequence;
+      i = strfind(a,'*');
+      i = i(r-1);                      % pick one of the * characters to rotate around
+      a = [a((i+1):end) '*' a(1:(i-1))];
+
+      b = FASTA_R(n).Aligned;
+      i = strfind(b,'*');
+      i = i(r-1);                      % pick one of the * characters to rotate around
+      b = [b((i+1):end) '*' b(1:(i-1))];
+
+      FASTA_R(n).Sequence = a;
+      FASTA_R(n).Aligned = b;
+    end
+
+    rotatedFASTA{r} = FASTA_R;
+
+    AllSequencesFile{r} = [DiagnosticPath filesep CF '_All_Sequences_' num2str(r) '.fasta'];
+    fid = fopen(AllSequencesFile{r},'w');
+    for n = 1:length(FASTA_R)
+      fprintf(fid,'>%s\n',FASTA_R(n).Header);
+      fprintf(fid,'%s\n',FASTA_R(n).Sequence);
+    end
+    fclose(fid);
   end
-
-  AllSequencesFile{r} = [ModelPath filesep CF '_All_Sequences_' num2str(r) '.fasta'];
-  fid = fopen(AllSequencesFile{r},'w');
-  for n = 1:length(FASTA_R),
-    fprintf(fid,'>%s\n',FASTA_R(n).Header);
-    fprintf(fid,'%s\n',FASTA_R(n).Sequence);
-  end  
-  fclose(fid);
-end
+end
\ No newline at end of file
diff --git a/matlab/zReadFASTA.m b/matlab/zReadFASTA.m
index 469510f..0eff297 100644
--- a/matlab/zReadFASTA.m
+++ b/matlab/zReadFASTA.m
@@ -3,6 +3,9 @@
 % Data(n).Aligned is the sequence, with gaps
 % Data(n).Sequence is the sequence with all gaps stripped out
 
+% FASTA = zReadFASTA('Alignments\16S_Bacterial_Stombaugh_et_al_Sup_Mat_S2.fasta');
+% FASTA = zReadFASTA('Alignments\Greengenes_Ecoli_Tth_16S_2_sequences.fasta');
+
 function [Data] = zReadFASTA(Filename, RemoveJAR3DSymbols, Verbose, KeepSequence)
 
 if nargin < 2,
@@ -84,6 +87,6 @@ if fid > 0
 
 else
 
-  fprintf('zReadFASTA: Could not open file %s\n', Filename);
+  fprintf('Could not open file %s\n', Filename);
 
 end
diff --git a/models/HL/HL_1.0_models.zip b/models/HL/HL_1.0_models.zip
deleted file mode 100644
index 87a1533..0000000
Binary files a/models/HL/HL_1.0_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.10_models.zip b/models/HL/HL_1.10_models.zip
deleted file mode 100644
index ad7328e..0000000
Binary files a/models/HL/HL_1.10_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.11_models.zip b/models/HL/HL_1.11_models.zip
deleted file mode 100644
index 1ad3c21..0000000
Binary files a/models/HL/HL_1.11_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.12_models.zip b/models/HL/HL_1.12_models.zip
deleted file mode 100644
index 9717ba1..0000000
Binary files a/models/HL/HL_1.12_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.13_models.zip b/models/HL/HL_1.13_models.zip
deleted file mode 100644
index e78d2a8..0000000
Binary files a/models/HL/HL_1.13_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.14_models.zip b/models/HL/HL_1.14_models.zip
deleted file mode 100644
index a0ab05e..0000000
Binary files a/models/HL/HL_1.14_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.15_models.zip b/models/HL/HL_1.15_models.zip
deleted file mode 100644
index 9dc665c..0000000
Binary files a/models/HL/HL_1.15_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.17_models.zip b/models/HL/HL_1.17_models.zip
deleted file mode 100644
index 9831153..0000000
Binary files a/models/HL/HL_1.17_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.18_models.zip b/models/HL/HL_1.18_models.zip
deleted file mode 100644
index f487a35..0000000
Binary files a/models/HL/HL_1.18_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.1_models.zip b/models/HL/HL_1.1_models.zip
deleted file mode 100644
index 79118f5..0000000
Binary files a/models/HL/HL_1.1_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.2_models.zip b/models/HL/HL_1.2_models.zip
deleted file mode 100644
index d82a1e0..0000000
Binary files a/models/HL/HL_1.2_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.3_models.zip b/models/HL/HL_1.3_models.zip
deleted file mode 100644
index b2e7632..0000000
Binary files a/models/HL/HL_1.3_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.4_models.zip b/models/HL/HL_1.4_models.zip
deleted file mode 100644
index dc35312..0000000
Binary files a/models/HL/HL_1.4_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.5_models.zip b/models/HL/HL_1.5_models.zip
deleted file mode 100644
index 8d38ebb..0000000
Binary files a/models/HL/HL_1.5_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.6_models.zip b/models/HL/HL_1.6_models.zip
deleted file mode 100644
index 417243c..0000000
Binary files a/models/HL/HL_1.6_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.7_models.zip b/models/HL/HL_1.7_models.zip
deleted file mode 100644
index 72ab635..0000000
Binary files a/models/HL/HL_1.7_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.8_models.zip b/models/HL/HL_1.8_models.zip
deleted file mode 100644
index 2aaf11f..0000000
Binary files a/models/HL/HL_1.8_models.zip and /dev/null differ
diff --git a/models/HL/HL_1.9_models.zip b/models/HL/HL_1.9_models.zip
deleted file mode 100644
index 59adf6f..0000000
Binary files a/models/HL/HL_1.9_models.zip and /dev/null differ
diff --git a/models/HL/HL_3.2_models.zip b/models/HL/HL_3.2_models.zip
deleted file mode 100644
index a3504d8..0000000
Binary files a/models/HL/HL_3.2_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.0_models.zip b/models/IL/IL_1.0_models.zip
deleted file mode 100644
index ad4ff46..0000000
Binary files a/models/IL/IL_1.0_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.10_models.zip b/models/IL/IL_1.10_models.zip
deleted file mode 100644
index 6508ddd..0000000
Binary files a/models/IL/IL_1.10_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.11_models.zip b/models/IL/IL_1.11_models.zip
deleted file mode 100644
index 33a55e4..0000000
Binary files a/models/IL/IL_1.11_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.12_models.zip b/models/IL/IL_1.12_models.zip
deleted file mode 100644
index cb50551..0000000
Binary files a/models/IL/IL_1.12_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.13_models.zip b/models/IL/IL_1.13_models.zip
deleted file mode 100644
index 0e2504b..0000000
Binary files a/models/IL/IL_1.13_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.14_models.zip b/models/IL/IL_1.14_models.zip
deleted file mode 100644
index 9cc936d..0000000
Binary files a/models/IL/IL_1.14_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.15_models.zip b/models/IL/IL_1.15_models.zip
deleted file mode 100644
index 6e740c6..0000000
Binary files a/models/IL/IL_1.15_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.17_models.zip b/models/IL/IL_1.17_models.zip
deleted file mode 100644
index b30895f..0000000
Binary files a/models/IL/IL_1.17_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.18_models.zip b/models/IL/IL_1.18_models.zip
deleted file mode 100644
index 9e3e6b7..0000000
Binary files a/models/IL/IL_1.18_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.1_models.zip b/models/IL/IL_1.1_models.zip
deleted file mode 100644
index 78e3ddf..0000000
Binary files a/models/IL/IL_1.1_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.2_models.zip b/models/IL/IL_1.2_models.zip
deleted file mode 100644
index d30ee6f..0000000
Binary files a/models/IL/IL_1.2_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.3_models.zip b/models/IL/IL_1.3_models.zip
deleted file mode 100644
index 569532a..0000000
Binary files a/models/IL/IL_1.3_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.4_models.zip b/models/IL/IL_1.4_models.zip
deleted file mode 100644
index 92b413b..0000000
Binary files a/models/IL/IL_1.4_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.5_models.zip b/models/IL/IL_1.5_models.zip
deleted file mode 100644
index 82a1452..0000000
Binary files a/models/IL/IL_1.5_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.6_models.zip b/models/IL/IL_1.6_models.zip
deleted file mode 100644
index 78c45e7..0000000
Binary files a/models/IL/IL_1.6_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.7_models.zip b/models/IL/IL_1.7_models.zip
deleted file mode 100644
index 5653cf2..0000000
Binary files a/models/IL/IL_1.7_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.8_models.zip b/models/IL/IL_1.8_models.zip
deleted file mode 100644
index 313fa79..0000000
Binary files a/models/IL/IL_1.8_models.zip and /dev/null differ
diff --git a/models/IL/IL_1.9_models.zip b/models/IL/IL_1.9_models.zip
deleted file mode 100644
index 210c66f..0000000
Binary files a/models/IL/IL_1.9_models.zip and /dev/null differ
diff --git a/models/IL/IL_3.2_models.zip b/models/IL/IL_3.2_models.zip
deleted file mode 100644
index 829e134..0000000
Binary files a/models/IL/IL_3.2_models.zip and /dev/null differ
diff --git a/models/jar3d_2014-12-11.jar b/models/jar3d_2014-12-11.jar
deleted file mode 100644
index aed108e..0000000
Binary files a/models/jar3d_2014-12-11.jar and /dev/null differ
diff --git a/models/jar3dalign_2015-04-03.jar b/models/jar3dalign_2015-04-03.jar
deleted file mode 100644
index 42142a8..0000000
Binary files a/models/jar3dalign_2015-04-03.jar and /dev/null differ
diff --git a/python/CorrespondenceUtilities.py b/python/CorrespondenceUtilities.py
index 417c197..d0624b3 100644
--- a/python/CorrespondenceUtilities.py
+++ b/python/CorrespondenceUtilities.py
@@ -140,11 +140,11 @@ def readcorrespondencesfromfile(filenamewithpath):
 def alignmentheaderhtml(ModelToColumn,GroupToModel):
 
   ColumnHeader = [''] * len(ModelToColumn)
-  for a in ModelToColumn.iterkeys():
+  for a in ModelToColumn.keys():
     ColumnHeader[int(ModelToColumn[a])-1] = a
 
   PositionNumber = [''] * (len(ModelToColumn)+1)
-  for a in GroupToModel.iterkeys():
+  for a in GroupToModel.keys():
     colnum = ModelToColumn[GroupToModel[a]]
     m = re.search("Column_([0-9]+)$",a)
     if m is not None:
@@ -174,8 +174,7 @@ def alignmentrowshtml(DisplayColor,aligdata,HasName,HasScore, HasInteriorEdit, H
 
   t = ""
 
-  for a in sorted(aligdata.iterkeys(),key = keyforsortbynumber):
-#    print HasScore
+  for a in sorted(aligdata.keys(),key = keyforsortbynumber):
     if HasScore[a] == ".":
       Score = 0
       DisplayScore = ""
@@ -216,22 +215,22 @@ def alignsequencesandinstancesfromtext(MotifCorrespondenceText,SequenceCorrespon
 
   motifalig = {}
 
-  for a in InstanceToGroup.iterkeys():
+  for a in InstanceToGroup.keys():
     m = re.search("(Instance_[0-9]+)",a)
     motifalig[m.group(1)] = [''] * len(ModelToColumn)     # start empty
 
-  for a in sorted(InstanceToGroup.iterkeys()):
+  for a in sorted(InstanceToGroup.keys()):
     m = re.search("(Instance_[0-9]+)",a)
     t = int(ModelToColumn[GroupToModel[InstanceToGroup[a]]])
     motifalig[m.group(1)][t-1] += a[len(a)-1]
 
   sequencealig = {}
 
-  for a in SequenceToModel.iterkeys():
+  for a in SequenceToModel.keys():
     m = re.search("(Sequence_[0-9]+)",a)
     sequencealig[m.group(1)] = [''] * len(ModelToColumn)  # start empty
 
-  for a in sorted(SequenceToModel.iterkeys()):
+  for a in sorted(SequenceToModel.keys()):
     m = re.search("(Sequence_[0-9]+)",a)
     t = int(ModelToColumn[SequenceToModel[a]])
     sequencealig[m.group(1)][t-1] += a[len(a)-1]
@@ -242,7 +241,7 @@ def alignsequencesandinstancesfromtext(MotifCorrespondenceText,SequenceCorrespon
   header['positions'] = [''] * len(ModelToColumn)
   header['insertions'] = [''] * len(ModelToColumn)
 
-  for a in ModelToColumn.iterkeys():
+  for a in ModelToColumn.keys():
     header['columnname'][int(ModelToColumn[a])-1] = a
 
   for i in range(0,len(ModelToColumn)):
@@ -252,7 +251,7 @@ def alignsequencesandinstancesfromtext(MotifCorrespondenceText,SequenceCorrespon
     if re.search("Insertion",header['columnname'][i]):
       header['insertions'][i] = 'Insertion'
 
-  for a in GroupToModel.iterkeys():
+  for a in GroupToModel.keys():
     m = re.search("Column_([0-9]+)$",a)
     if m is not None:
       colnum = ModelToColumn[GroupToModel[a]]
@@ -265,12 +264,12 @@ def alignsequencesandinstancesfromfiles(MotifCorrespondenceFile,SequenceCorrespo
   with open(MotifCorrespondenceFile,"r") as f:
     MotifLines = f.readlines()
 
-  print "Read motif correspondence file " + MotifCorrespondenceFile
+  print("Read motif correspondence file " + MotifCorrespondenceFile)
 
   with open(SequenceCorrespondenceFile,"r") as f:
     SequenceLines = f.readlines()
 
-  print "Read sequence correspondence file " + SequenceCorrespondenceFile
+  print("Read sequence correspondence file " + SequenceCorrespondenceFile)
 
   header, motifalig, sequencealig = alignsequencesandinstancesfromtext(MotifLines,SequenceLines)
 
@@ -287,11 +286,11 @@ def alignsequencesandinstancesfromfileshtml(MotifCorrespondenceFile,SequenceCorr
 
     DisplayColor = {}
 
-    for i in InstanceToPDB.iterkeys():
+    for i in InstanceToPDB.keys():
       a = re.search("(Instance_[0-9]+)",i)
       DisplayColor[a.group(1)] = 'black'            # default display color
 
-    for i in SequenceToModel.iterkeys():
+    for i in SequenceToModel.keys():
       a = re.search("(Sequence_[0-9]+)",i)
       DisplayColor[a.group(1)] = 'black'            # default display color
 
@@ -299,24 +298,24 @@ def alignsequencesandinstancesfromfileshtml(MotifCorrespondenceFile,SequenceCorr
 
     aligdata = {}                                      # new dictionary
 
-    for a in InstanceToGroup.iterkeys():
+    for a in InstanceToGroup.keys():
       m = re.search("(Instance_[0-9]+)",a)
       aligdata[m.group(1)] = []
 
-    for a in SequenceToModel.iterkeys():
+    for a in SequenceToModel.keys():
       m = re.search("(Sequence_[0-9]+)",a)
       aligdata[m.group(1)] = []
 
-    for a in aligdata.iterkeys():
+    for a in aligdata.keys():
       for j in range(0,len(ModelToColumn)):
         aligdata[a].append('')                        # clumsy but effective
                                                       # sorting by key should keep insertions in order
-    for a in sorted(InstanceToGroup.iterkeys()):
+    for a in sorted(InstanceToGroup.keys()):
       m = re.search("(Instance_[0-9]+)",a)
       t = int(ModelToColumn[GroupToModel[InstanceToGroup[a]]])
       aligdata[m.group(1)][t-1] += a[len(a)-1]
 
-    for a in sorted(SequenceToModel.iterkeys()):
+    for a in sorted(SequenceToModel.keys()):
       m = re.search("(Sequence_[0-9]+)",a)
       t = int(ModelToColumn[SequenceToModel[a]])
       aligdata[m.group(1)][t-1] += a[len(a)-1]
@@ -333,12 +332,11 @@ def alignsequencesandinstancesfromfileshtml(MotifCorrespondenceFile,SequenceCorr
 
 if __name__ == "__main__":
 #  alignsequencesandinstancesfromfiles(sys.argv[1],sys.argv[2])
-#  print t
 
   header, motifalig, sequencealig = alignsequencesandinstancesfromfiles(sys.argv[1],sys.argv[2])
-  print "Result from alignsequencesandinstancesfromfiles: "
-  print header
-  print motifalig
-  print sequencealig
+  print("Result from alignsequencesandinstancesfromfiles: ")
+  print(header)
+  print(motifalig)
+  print(sequencealig)
 
 
diff --git a/python/GroupToModelDiagnostic.py b/python/GroupToModelDiagnostic.py
index 786fbcc..ed31ce1 100644
--- a/python/GroupToModelDiagnostic.py
+++ b/python/GroupToModelDiagnostic.py
@@ -22,30 +22,26 @@ def onemodeldiagnostic(motifID,libDirectory,diagDirectory,prevHTML,nextHTML):
     # read correspondences for the given motif group; there are many such correspondences
     InstanceToGroup, InstanceToPDB, InstanceToSequence, GroupToModel, ModelToColumn, SequenceToModel, HasName, HasScore, HasInteriorEdit, HasFullEdit, HasCutoffValue, HasCutoffScore, HasAlignmentScoreDeficit = readcorrespondencesfromfile(FN)
 
-    print "Read diagnostics from " + FN
+    print("Read diagnostics from " + FN)
 
     # default display color, indexed by instance; each instance will be displayed in one row
     DisplayColor = {}
 
     # loop through instances from the motif group and set the color that it will be displayed
-    for i in InstanceToPDB.iterkeys():
+    for i in InstanceToPDB.keys():
       a = re.search("(.+Instance_[0-9]+)",i)
       DisplayColor[a.group(1)] = 'blue'            # default display color
 
     # loop through sequences from the motif group and set the default display color in a dictionary
-    for i in SequenceToModel.iterkeys():
+    for i in SequenceToModel.keys():
       a = re.search("(.+Sequence_[0-9]+)",i)
       DisplayColor[a.group(1)] = 'black'            # default display color
 
     MisAlign = 0
 
-#    print GroupToModel
-#    print SequenceToModel
-#    print InstanceToPDB
-
-    for nt in sorted(InstanceToPDB.iterkeys()):
+    for nt in sorted(InstanceToPDB.keys()):
       if GroupToModel[InstanceToGroup[nt]] != SequenceToModel[InstanceToSequence[nt]]:
-        print nt + ' belongs to ' + GroupToModel[InstanceToGroup[nt]] + ' but was aligned to ' + SequenceToModel[InstanceToSequence[nt]]
+        print(nt + ' belongs to ' + GroupToModel[InstanceToGroup[nt]] + ' but was aligned to ' + SequenceToModel[InstanceToSequence[nt]])
         MisAlign += 0.5
 #        a = re.search("(.+Instance_[0-9]+)",nt)
 #        DisplayColor[a.group(1)] = 'red'
@@ -56,31 +52,31 @@ def onemodeldiagnostic(motifID,libDirectory,diagDirectory,prevHTML,nextHTML):
 
     aligdata = {}                                      # new dictionary
 
-    for a in InstanceToGroup.iterkeys():
+    for a in InstanceToGroup.keys():
       m = re.search("(.+Instance_[0-9]+)",a)
       aligdata[m.group(1)] = []                        # initialize this key with empty list
 
-    for a in SequenceToModel.iterkeys():
+    for a in SequenceToModel.keys():
       m = re.search("(.+Sequence_[0-9]+)",a)
       aligdata[m.group(1)] = []                        # initialize this key with empty list
 
-    for a in aligdata.iterkeys():
+    for a in aligdata.keys():
       for j in range(0,len(ModelToColumn)):
         aligdata[a].append('')                         # initialize with blank
                                                        # sorting by key should keep insertions in order
-    for a in sorted(InstanceToGroup.iterkeys(), key=columnkeyforsortbynumber):
+    for a in sorted(InstanceToGroup.keys(), key=columnkeyforsortbynumber):
       m = re.search("(.+Instance_[0-9]+)",a)
       t = int(ModelToColumn[GroupToModel[InstanceToGroup[a]]]) # map position in group to the correct column in the model and in the alignment
       aligdata[m.group(1)][t-1] += a[len(a)-1]         # last character of the key is the base for this position
 
-    for a in sorted(SequenceToModel.iterkeys(), key=positionkeyforsortbynumber):
+    for a in sorted(SequenceToModel.keys(), key=positionkeyforsortbynumber):
       m = re.search("(.+Sequence_[0-9]+)",a)
       t = int(ModelToColumn[SequenceToModel[a]])
       aligdata[m.group(1)][t-1] += a[len(a)-1]
 
 #    for a,b in aligdata.iteritems():
 #      for i in range(0,len(b)-1):
-#        print '<td>'+aligdata[a][i]+'</td>',
+#        print('<td>'+aligdata[a][i]+'</td>'),
 #      print
 
     f = open(diagDirectory+"\\"+motifID+"_GroupToModelDiagnostic.html","w")
@@ -126,27 +122,27 @@ def onemodeldiagnostic(motifID,libDirectory,diagDirectory,prevHTML,nextHTML):
     f.write("</html>")
     f.close()
 
-    print "Wrote html file with alignment of 3D instances and sequences for " + motifID
+    print("Wrote html file with alignment of 3D instances and sequences for " + motifID)
 
     return aligdata, MisAlign
 
 def allmodelsdiagnostic(directory):
 
-  print "Starting all models diagnostic in directory " + directory
+  print("Starting all models diagnostic in directory " + directory)
 
   libDirectory = directory + "\\" + "lib"                       # replace \\ with os. separator character
   diagDirectory = directory + "\\" + "diagnostic"
   #  diagDirectory = re.sub('bp_models','interactions',libDirectory)
 
   dirList = os.listdir(libDirectory)
-#  print dirList
+#  print(dirList)
 
   motifIDList = []
   for fn in dirList:
     if re.search("_correspondences.txt",fn):
       motifIDList += [re.sub("_correspondences.txt","",fn)]
 
-#  print motifIDList
+#  print(motifIDList)
 
   prevHTML = ""
 
@@ -162,7 +158,7 @@ def allmodelsdiagnostic(directory):
     motifID = motifIDList[i]
     currentHTML = motifID + "_GroupToModelDiagnostic.html"
 
-    print "Starting motif group " + motifID
+    print("Starting motif group " + motifID)
 
 #    m = re.search("(.*)(_diagnostics)(.*)",fn)
 
@@ -171,7 +167,7 @@ def allmodelsdiagnostic(directory):
       InteractionFile = libDirectory + "\\" + motifID + "_correspondences.txt"
       with open(InteractionFile,"r") as intf:
         for line in intf.readlines():
-          print line,
+          print(line),
 
     if i < len(motifIDList)-1:
       nextHTML = motifIDList[i+1] + "_GroupToModelDiagnostic.html"
diff --git a/python/correspondenceToSVG.py b/python/correspondenceToSVG.py
new file mode 100644
index 0000000..50ad1f2
--- /dev/null
+++ b/python/correspondenceToSVG.py
@@ -0,0 +1,346 @@
+# fastaToModelToSVG reads the alignment of a single sequence in a FASTA file,
+# reads the alignment to a motif group, and writes out an SVG file to
+# describe the basepair diagram to make
+
+import sys
+import os
+import re
+import string
+import numpy as np
+import math
+
+from CorrespondenceUtilities import readcorrespondencesfromfile
+from CorrespondenceUtilities import alignmentrowshtml
+from CorrespondenceUtilities import alignmentheaderhtml
+from CorrespondenceUtilities import keyforsortbynumber
+from CorrespondenceUtilities import positionkeyforsortbynumber
+from CorrespondenceUtilities import columnkeyforsortbynumber
+
+def correspondenceToInteractionList(libDirectory,motifID,correspondenceFile):
+  # read correspondences from the fasta file to the model
+  InstanceToGroup, InstanceToPDB, InstanceToSequence, GroupToModel, ModelToColumn, SequenceToModel, HasName, HasScore, HasInteriorEdit, HasFullEdit, HasCutoffValue, HasCutoffScore, HasAlignmentScoreDeficit = readcorrespondencesfromfile(correspondenceFile)
+
+#  print "Read alignment to model from " + correspondenceFile
+
+  sequenceNumber = 1             # some FASTA files may have multiple sequences, need to say which
+
+  ModelToSequence = {}
+  for sp in SequenceToModel:
+    ModelToSequence[SequenceToModel[sp]] = sp     # will use latest correspondence, for multiple insertions
+
+  FN = libDirectory + "\\" + motifID + "_correspondences.txt"
+
+  interactionsFile = libDirectory + "\\" + motifID + "_interactions.txt"
+
+  with open(interactionsFile,'r') as fh:
+    interactions = fh.readlines()
+
+  # read correspondences for the given motif group; there are many such correspondences
+  InstanceToGroup, InstanceToPDB, InstanceToSequence, GroupToModel, ModelToColumn, SequenceToModelDummy, ModelHasName, ModelHasScore, ModelInteriorEdit, ModelFullEdit, ModelCutoffValue, ModelCutoffScore, ModelDeficit = readcorrespondencesfromfile(FN)
+
+#  print(GroupToModel)
+
+  allBPs = ""
+
+  allInteractions = []
+
+  # record all interactions in terms of the sequence positions
+  for interaction in interactions:
+    fields = interaction.split(" ")
+    a = fields[0]  # motif group positions of the two interacting bases
+    b = fields[1]
+    interactionType = fields[2]
+
+    try:
+      aa = ModelToSequence[GroupToModel[motifID+"_Column_"+a]]
+      bb = ModelToSequence[GroupToModel[motifID+"_Column_"+b]]
+
+      aafields = aa.split('_')
+      bbfields = bb.split('_')
+
+      newInteraction = {}
+      newInteraction["firstSequencePosition"] = int(aafields[3])-1   # JAR3D counts from 1, Python counts from 0
+      newInteraction["secondSequencePosition"] = int(bbfields[3])-1
+      newInteraction["type"] = interactionType
+
+      allInteractions.append(newInteraction)
+    except:
+      print("Deleted interaction " + interaction)
+
+
+  return allInteractions
+
+def drawLWSymbol(orientation,edge,c,color,rotation=[]):
+
+  Hoogsteen = 2*np.array(([1,-1,-1,1],[1,1,-1,-1]))   # corners of square for Hoogsteen symbol
+  Sugar     = 3*np.array(([1,-0.5,-0.5],[0,math.sqrt(3)/2,-math.sqrt(3)/2]))  # corners of triangle
+  tWradius = 2
+  cWradius = 2.5
+
+  SVGtext = ""
+  if orientation == "c":
+    if edge == "W":
+      SVGtext += '<circle cx="%0.8f" cy="%0.8f" r="%0.8f" stroke="none" stroke-width="1.0" fill="%s"/>\n' % (c[0],c[1],cWradius,color)
+    elif edge == "H":
+      square = np.column_stack((c,c,c,c)) + np.matmul(rotation,Hoogsteen)
+      SVGtext += '<path d="M%0.8f %0.8f L%0.8f %0.8f L%0.8f %0.8f L%0.8f %0.8f Z" ' % tuple(np.reshape(square,8,order='F'))
+      SVGtext += 'style="fill:%s; stroke:none; stroke-width:1.0;"/>\n' % color
+    elif edge == "S":
+      triangle = np.column_stack((c,c,c)) + np.matmul(rotation,Sugar)
+      SVGtext += '<path d="M%0.8f %0.8f L%0.8f %0.8f L%0.8f %0.8f Z" ' % tuple(np.reshape(triangle,6,order='F'))
+      SVGtext += 'style="fill:%s; stroke:none; stroke-width:1.0;"/>\n' % color
+  elif orientation == "t":
+    if edge == "W":
+      SVGtext += '<circle cx="%0.8f" cy="%0.8f" r="%0.8f" stroke="%s" stroke-width="1.0" fill="rgb(100%%, 100%%, 100%%)"/>\n' % (c[0],c[1],tWradius,color)
+    elif edge == "H":
+      square = np.column_stack((c,c,c,c)) + np.matmul(rotation,Hoogsteen)
+      SVGtext += '<path d="M%0.8f %0.8f L%0.8f %0.8f L%0.8f %0.8f L%0.8f %0.8f Z" ' % tuple(np.reshape(square,8,order='F'))
+      SVGtext += 'style="fill:rgb(100%%, 100%%, 100%%); stroke:%s; stroke-width:1.0;"/>\n' % color
+    elif edge == "S":
+      triangle = np.column_stack((c,c,c)) + np.matmul(rotation,Sugar)
+      SVGtext += '<path d="M%0.8f %0.8f L%0.8f %0.8f L%0.8f %0.8f Z" ' % tuple(np.reshape(triangle,6,order='F'))
+      SVGtext += 'style="fill:rgb(100%%, 100%%, 100%%); stroke:%s; stroke-width:1.0;"/>\n' % color
+
+  return SVGtext
+
+def somethingBetween(SVG,i,j):
+  for a in range(0,len(SVG)):
+    if not a == i and not a == j and abs(np.linalg.norm(SVG[i]["p"]-SVG[j]["p"]) - np.linalg.norm(SVG[i]["p"]-SVG[a]["p"]) - np.linalg.norm(SVG[a]["p"]-SVG[j]["p"])) < 0.01:
+      return True
+
+  return False
+
+def interactionListToSVG(sequence,interactionList,numbers=[]):
+
+  leftX = 10.0
+  deltaX = 25.0
+  topStrandY = 20.0
+  bottomStrandY = 50.0
+  arcRadiusY = 8
+  arcShift = np.array([0,arcRadiusY])
+  radius = 5.0               # for circles around letters
+  textShift = 2.75           # shift capital letter text down to get into centers of circles
+  numberShiftTop = 6.6       # how far to put numbers above/below letters
+  numberShiftBottom = 12    # how far to put numbers above/below letters
+  GCseparation = 2.5         # how far apart the GC cWW basepair lines should be
+  bulge = (bottomStrandY - topStrandY) / 4.0        # how far out to move a bulged base
+  instrand = 0 * (bottomStrandY - topStrandY) / 4.5        # how far in to move an in-strand paired base
+  scarlet = "rgb(187,0,0)"
+  lightScarlet = "rgb(255,62,150)"
+  pink = "rgb(255,192,203)"
+
+  SVG = {}
+  SVGtext = ""
+
+  currentX = leftX
+
+  stacking = np.zeros((len(sequence),len(sequence)))
+  pairs = np.zeros((len(sequence),len(sequence)))
+
+  # track all stacking and pairing interactions
+  for interaction in interactionList:
+    t = interaction["type"]
+    i = interaction["firstSequencePosition"]
+    j = interaction["secondSequencePosition"]
+    if "s" in t:
+      stacking[i][j] = 1
+      stacking[j][i] = 1
+    elif "c" in t or "t" in t:
+      pairs[i][j] = 1
+      pairs[j][i] = 1
+
+  both = stacking + pairs
+
+  # assign x and y coordinates to the bases
+  if "*" in sequence:
+    s = sequence.find("*")    # location of the star
+    topNum = s
+    bottomNum = len(sequence)-s-1
+    width = deltaX * max(topNum-1,bottomNum-1)
+    deltaXTop = width / (topNum-1)
+    deltaXBottom = width / (bottomNum-1)
+    y = topStrandY
+    upper = range(0,s)
+    lower = range((s+1),len(sequence))
+
+    movedIn = False
+    for i in range(0,len(sequence)):
+      SVG[i] = {}
+      if i < s:
+        if np.sum(stacking[i,...]) == 0 and np.sum(pairs[i,...]) == 0:  # base all by itself, move out
+          SVG[i]["p"] = np.array([currentX,topStrandY-bulge])
+        elif not movedIn and i > 0 and i < s-1 and np.sum(pairs[i,upper]) > 0 and np.sum(pairs[i,lower]) > 0 and np.sum(both[0:i,i:(s-1)]) > 1:
+          SVG[i]["p"] = np.array([currentX,topStrandY+instrand])
+          movedIn = True
+        elif not movedIn and i < s-1 and pairs[0,i] > 0 and (i>1 or np.sum(both[0,upper]) > 1):
+          SVG[i]["p"] = np.array([currentX,topStrandY+instrand])
+          movedIn = True
+        elif not movedIn and i > 0 and pairs[i,s-1] > 0 and (s-1-i>1 or np.sum(both[s-1,upper]) > 1):
+          SVG[i]["p"] = np.array([currentX,topStrandY+instrand])
+          movedIn = True
+        else:
+          SVG[i]["p"] = np.array([currentX,topStrandY])
+          movedIn = False
+        currentX += deltaXTop
+      elif i == s:
+        currentX -= deltaXTop
+        movedIn = False
+        SVG[i]["p"] = np.array([float('inf'),float('inf')])
+      elif i > s:
+        if np.sum(stacking[i,...]) == 0 and np.sum(pairs[i,...]) == 0:  # base all by itself
+          SVG[i]["p"] = np.array([currentX,bottomStrandY+bulge])
+        elif i == s+1 and pairs[i,len(sequence)-1] > 0:
+          SVG[i]["p"] = np.array([currentX,bottomStrandY-instrand])
+          movedIn = True
+        elif not movedIn and i > s+1 and i+1 < len(sequence) and np.sum(pairs[i,lower]) > 0 and np.sum(pairs[i,upper]) and np.sum(both[(s+1):i,i:(len(sequence)-1)]) > 1:     # another interaction crosses over i
+          SVG[i]["p"] = np.array([currentX,bottomStrandY-instrand])
+          movedIn = True
+        elif not movedIn and i > s+1 and i+1 < len(sequence) and pairs[i,len(sequence)-1] > 0 and (len(sequence)-1-i > 1 or np.sum(both[len(sequence)-1,lower]) > 1):
+          SVG[i]["p"] = np.array([currentX,bottomStrandY-instrand])
+          movedIn = True
+        elif not movedIn and i > s+1 and pairs[i,s+1] > 0 and (i-(s+1)>1 or np.sum(both[s+1,lower]) > 1):
+          SVG[i]["p"] = np.array([currentX,bottomStrandY-instrand])
+          movedIn = True
+        else:
+          SVG[i]["p"] = np.array([currentX,bottomStrandY])
+          movedIn = False
+        currentX -= deltaXBottom
+  else:                                  # hairpin x,y layout
+    i = 0
+    while i < len(sequence)-1 and stacking[i,i+1] > 0:
+      SVG[i] = {}
+      SVG[i]["p"] = np.array([currentX,topStrandY])
+      currentX += deltaX
+      i += 1
+
+    i = len(sequence)-1
+    while i < len(sequence)-1 and stacking[i,i+1] > 0:
+      SVG[i] = {}
+      SVG[i]["p"] = np.array([currentX,bottomStrandY])
+      currentX += deltaX
+      i -= 1
+
+    print(SVG)
+
+  # draw the stacking interactions
+  for interaction in interactionList:
+    t = interaction["type"]
+    if t[0] == "s":
+      i = interaction["firstSequencePosition"]
+      j = interaction["secondSequencePosition"]
+      p1 = SVG[i]["p"]
+      p2 = SVG[j]["p"]
+      x1 = p1[0]
+      y1 = p1[1]
+      x2 = p2[0]
+      y2 = p2[1]
+
+      if abs(y1-y2) < 0.01 and abs(i-j) > 1 and somethingBetween(SVG,i,j):
+        if y1 > (topStrandY + bottomStrandY)/2:
+          SVGtext += '<path d="M%0.8f,%0.8f A%0.8f,%0.8f 0 0,0 %0.8f,%0.8f" fill="none" stroke="rgb(102,102,102)" stroke-width="2.0" />\n' % (x1,y1,(x2-x1)/2,arcRadiusY/2,x2,y2)
+        else:
+          SVGtext += '<path d="M%0.8f,%0.8f A%0.8f,%0.8f 0 0,1 %0.8f,%0.8f" fill="none" stroke="rgb(102,102,102)" stroke-width="2.0" />\n' % (x2,y2,(x2-x1)/2,arcRadiusY/2,x1,y1)
+      else:
+        SVGtext += '<line x1="%0.8f" y1="%0.8f" x2="%0.8f" y2="%0.8f" stroke="rgb(102,102,102)" stroke-width="2.0" />\n' % (x1,y1,x2,y2)
+
+  # draw out the basepairing interactions
+  for interaction in interactionList:
+    t = interaction["type"]
+    if t[0] == "c" or t[0] == "t":
+      i = interaction["firstSequencePosition"]
+      j = interaction["secondSequencePosition"]
+      p1 = SVG[i]["p"]
+      p2 = SVG[j]["p"]
+      x1 = p1[0]
+      y1 = p1[1]
+      x2 = p2[0]
+      y2 = p2[1]
+      unit = (p2-p1)/np.linalg.norm(p2-p1)  # unit vector from 1 to 2
+      perp = np.array([-unit[1],unit[0]])   # unit vector perpendicular to the interaction
+      rotation = np.column_stack((unit,perp))
+      pair = sequence[i] + sequence[j]
+
+      for a in range(min(i,j)+1,max(i,j)):
+        for b in range(0,min(i,j)):
+          pairs[a][b] *= 2              # mark this as having been crossed
+          pairs[b][a] *= 2              # mark this as having been crossed
+        for b in range(max(i,j)+1,len(sequence)):
+          pairs[a][b] *= 2              # mark this as having been crossed
+          pairs[b][a] *= 2              # mark this as having been crossed
+
+      if pairs[i][j] == 1:
+        color = scarlet
+      elif pairs[i][j] == 2:
+        color = pink
+      else:
+        color = lightScarlet            # if already crossed, draw lighter
+
+      # if the interaction is on the same horizontal level, use an elliptical arc
+      if abs(y1-y2) < 0.01 and abs(i-j) > 1 and somethingBetween(SVG,i,j):
+        if y1 > (topStrandY + bottomStrandY)/2:
+          sweepFlag = 0
+          arcShift = np.array([0,-arcRadiusY])
+          SVGtext += '<path d="M%0.8f,%0.8f A%0.8f,%0.8f 0 0,0 %0.8f,%0.8f" fill="none" stroke="%s" stroke-width="1.0" />\n' % (x1,y1,(x2-x1)/2,arcRadiusY,x2,y2,color)
+        else:
+          sweepFlag = 1
+          arcShift = np.array([0,arcRadiusY])
+          SVGtext += '<path d="M%0.8f,%0.8f A%0.8f,%0.8f 0 0,1 %0.8f,%0.8f" fill="none" stroke="%s" stroke-width="1.0" />\n' % (x2,y2,(x2-x1)/2,arcRadiusY,x1,y1,color)
+
+        # the following code works for everything but GC cWW and AU cWW.  We can do those later.
+        if t[1] == t[2]:
+          SVGtext += drawLWSymbol(t[0],t[1],(p1+p2)/2+arcShift,color,rotation)   # position relative to midpoint of interaction line
+        else:
+          SVGtext += drawLWSymbol(t[0],t[1],(p1+p2)/2-3*unit+arcShift,color,-rotation)   # position relative to midpoint of interaction line
+          SVGtext += drawLWSymbol(t[0],t[2],(p1+p2)/2+3*unit+arcShift,color,rotation)
+      elif t == "cWW" and (pair == "CG" or pair == "GC"):
+        # draw a double line
+        a = p1 + 0.5*GCseparation*perp
+        b = p2 + 0.5*GCseparation*perp
+        SVGtext += '<line x1="%0.8f" y1="%0.8f" x2="%0.8f" y2="%0.8f" stroke="%s" stroke-width="1.0" />\n' % (a[0],a[1],b[0],b[1],color)
+        a = p1 - 0.5*GCseparation*perp
+        b = p2 - 0.5*GCseparation*perp
+        SVGtext += '<line x1="%0.8f" y1="%0.8f" x2="%0.8f" y2="%0.8f" stroke="%s" stroke-width="1.0" />\n' % (a[0],a[1],b[0],b[1],color)
+      else:
+        SVGtext += '<line x1="%0.8f" y1="%0.8f" x2="%0.8f" y2="%0.8f" stroke="%s" stroke-width="1.0" />\n' % (x1,y1,x2,y2,color)
+        if t[1] == t[2]:
+          if not (t == "cWW" and (pair == 'AU' or pair == 'UA')):
+            SVGtext += drawLWSymbol(t[0],t[1],(p1+p2)/2,color,rotation)
+        else:
+          SVGtext += drawLWSymbol(t[0],t[1],(p1+p2)/2-3*unit,color,-rotation)   # position relative to midpoint of interaction line
+          SVGtext += drawLWSymbol(t[0],t[2],(p1+p2)/2+3*unit,color,rotation)
+
+  for i in range(0,len(sequence)-1):
+    if not i == s and not i+1 == s:
+      p1 = SVG[i]["p"]
+      p2 = SVG[i+1]["p"]
+      x1 = p1[0]
+      y1 = p1[1]
+      x2 = p2[0]
+      y2 = p2[1]
+      SVGtext += '<line x1="%0.8f" y1="%0.8f" x2="%0.8f" y2="%0.8f" stroke="rgb(0%%, 0%%, 0%%)" stroke-width="0.5" />\n' % (x1,y1,x2,y2)
+
+  # draw out the circles then letters then numbers
+  for i in range(0,len(sequence)):
+    if not sequence[i] == "*":
+      p = SVG[i]["p"]
+      x = p[0]
+      y = p[1]
+      c = sequence[i]
+      SVGtext += '<circle cx="%0.8f" cy="%0.8f" r="%0.8f" stroke="none" stroke-width="1.0" fill="rgb(100%%, 100%%, 100%%)"/>\n' % (x,y,radius)
+      SVGtext += '<circle cx="%0.8f" cy="%0.8f" r="%0.8f" stroke="rgb(0%%, 0%%, 0%%)" stroke-width="1.0" fill="none"/>\n' % (x,y,radius)
+      SVGtext += '<text x="%0.8f" y="%0.8f" text-anchor="middle" font-family="Verdana" font-size="7.5" fill="rgb(0%% 0%%, 0%%)" >%s</text>\n' % (x,y+textShift,c)
+    if "*" in sequence:
+      if i < s:
+        SVGtext += '<text x="%0.8f" y="%0.8f" text-anchor="middle" font-family="Verdana" font-size="7" fill="rgb(0%% 0%%, 0%%)" >%d</text>\n' % (x,y-numberShiftTop,numbers[i])
+      elif i > s:
+        SVGtext += '<text x="%0.8f" y="%0.8f" text-anchor="middle" font-family="Verdana" font-size="7" fill="rgb(0%% 0%%, 0%%)" >%d</text>\n' % (x,y+numberShiftBottom,numbers[i])
+
+  SVGtext = '<svg width="%d" height="70" version="1.1" xmlns="http://www.w3.org/2000/svg">\n\n' % (width+leftX*2) + SVGtext
+  SVGtext = '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' + SVGtext
+  SVGtext = '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ' + SVGtext
+  SVGtext = '<?xml version="1.0" encoding="UTF-8"?>\n' + SVGtext
+
+  SVGtext += "</svg>"
+
+
+  return SVGtext
\ No newline at end of file
diff --git a/python/correspondenceToVARNA.py b/python/correspondenceToVARNA.py
new file mode 100644
index 0000000..e44da1a
--- /dev/null
+++ b/python/correspondenceToVARNA.py
@@ -0,0 +1,99 @@
+# fastaToModelToVARNA reads the alignment of a single sequence in a FASTA file,
+# reads the alignment to a motif group, and writes out a VARNA file to
+# describe the basepair diagram to make
+
+import sys
+import os
+import re
+import string
+
+from CorrespondenceUtilities import readcorrespondencesfromfile
+from CorrespondenceUtilities import alignmentrowshtml
+from CorrespondenceUtilities import alignmentheaderhtml
+from CorrespondenceUtilities import keyforsortbynumber
+from CorrespondenceUtilities import positionkeyforsortbynumber
+from CorrespondenceUtilities import columnkeyforsortbynumber
+
+def correspondenceToVARNA(libDirectory,motifID,correspondenceFile,outputFileName):
+  # read correspondences from the fasta file to the model
+  InstanceToGroup, InstanceToPDB, InstanceToSequence, GroupToModel, ModelToColumn, SequenceToModel, HasName, HasScore, HasInteriorEdit, HasFullEdit, HasCutoffValue, HasCutoffScore, HasAlignmentScoreDeficit = readcorrespondencesfromfile(correspondenceFile)
+
+  print "Read alignment to model from " + correspondenceFile
+
+#  print(SequenceToModel)
+  sequenceNumber = 1             # some FASTA files may have multiple sequences, need to say which
+
+  FASTAdict = {}
+  for sp in SequenceToModel:
+    fields = sp.split("_")
+    FASTAdict[fields[3]] = fields[4]
+  FASTASequence = ""
+  for sp in range(0,len(SequenceToModel)):
+    FASTASequence += FASTAdict[str(sp+1)]
+
+  ModelToSequence = {}
+  for sp in SequenceToModel:
+    ModelToSequence[SequenceToModel[sp]] = sp     # will use latest correspondence, for multiple insertions
+
+  FN = libDirectory + "\\" + motifID + "_correspondences.txt"
+
+  interactionsFile = libDirectory + "\\" + motifID + "_interactions.txt"
+
+  with open(interactionsFile,'r') as fh:
+    interactions = fh.readlines()
+
+  # read correspondences for the given motif group; there are many such correspondences
+  InstanceToGroup, InstanceToPDB, InstanceToSequence, GroupToModel, ModelToColumn, SequenceToModelDummy, ModelHasName, ModelHasScore, ModelInteriorEdit, ModelFullEdit, ModelCutoffValue, ModelCutoffScore, ModelDeficit = readcorrespondencesfromfile(FN)
+
+#  print(GroupToModel)
+
+  allBPs = ""
+
+  for interaction in interactions:
+    fields = interaction.split(" ")
+    a = fields[0]
+    b = fields[1]
+    interactionType = fields[2]
+    if "c" in interactionType or "t" in interactionType:
+      try:
+        aa = ModelToSequence[GroupToModel[motifID+"_Column_"+a]]
+        bb = ModelToSequence[GroupToModel[motifID+"_Column_"+b]]
+
+  #      viroid_loop_4... has sequence position to Model as well, just need to work it backward in one case
+  #      is there a many to one problem, though?
+
+        print(a,b,interactionType,aa,bb)
+
+        aafields = aa.split('_')
+        bbfields = bb.split('_')
+        allBPs += "("+aafields[3]+","+bbfields[3]+")"
+        orientation = interactionType[0].replace("t","trans").replace("c","cis")
+        firstedge = string.lower(interactionType[1]).replace("w","wc")
+        secondedge = string.lower(interactionType[2]).replace("w","wc")
+        allBPs += ':edge5="'+firstedge+'",edge3="'+secondedge+'",stericity="'+orientation+'";'
+      except:
+        print("Missing interaction " + interaction)
+
+  option = {}
+  option["sequenceDBN"] = FASTASequence
+  option["structureDBN"] = "."*len(FASTASequence)
+  option["auxBPs"] = allBPs
+  if "Loop_1_" in outputFileName:
+    option["rotation"] = "270.0"
+  else:
+    option["rotation"] = "90.0"
+  option["eror"] = "True"
+  #option["drawBackbone"] = "false"
+  #option["annotations"] = "27:anchor=1,type=B"
+
+  VARNA = "java -cp C:\\Users\\zirbel\\Documents\\JAR3D\\viroid\\VARNAv3-93.jar fr.orsay.lri.varna.applications.VARNAcmd "
+  for a in option:
+    VARNA += " -" + a + " " + option[a]
+  VARNA += " -o " + outputFileName
+
+  print(VARNA)
+
+  return VARNA
+
+if __name__ == "__main__":
+  fastatomodelalignment(sys.argv[1],sys.argv[2],sys.argv[3],sys.argv[4])
diff --git a/python/fastatomodeltoVARNA.py b/python/fastatomodeltoVARNA.py
new file mode 100644
index 0000000..dcc4214
--- /dev/null
+++ b/python/fastatomodeltoVARNA.py
@@ -0,0 +1,101 @@
+# fastaToModelToVARNA reads the alignment of a single sequence in a FASTA file,
+# reads the alignment to a motif group, and writes out a VARNA file to
+# describe the basepair diagram to make
+
+import sys
+import os
+import re
+import string
+
+from CorrespondenceUtilities import readcorrespondencesfromfile
+from CorrespondenceUtilities import alignmentrowshtml
+from CorrespondenceUtilities import alignmentheaderhtml
+from CorrespondenceUtilities import keyforsortbynumber
+from CorrespondenceUtilities import positionkeyforsortbynumber
+from CorrespondenceUtilities import columnkeyforsortbynumber
+
+def correspondenceToVARNA(libDirectory,motifID,correspondenceFile,outputFile):
+  # read correspondences from the fasta file to the model
+  InstanceToGroup, InstanceToPDB, InstanceToSequence, GroupToModel, ModelToColumn, SequenceToModel, HasName, HasScore, HasInteriorEdit, HasFullEdit, HasCutoffValue, HasCutoffScore, HasAlignmentScoreDeficit = readcorrespondencesfromfile(alignmentfile)
+
+  print "Read alignment to model from " + alignmentfile
+
+  FN = libDirectory + "\\" + motifID + "_correspondences.txt"
+
+  # read correspondences for the given motif group; there are many such correspondences
+  InstanceToGroup, InstanceToPDB, InstanceToSequence, GroupToModel, ModelToColumn, SequenceToModelDummy, ModelHasName, ModelHasScore, ModelInteriorEdit, ModelFullEdit, ModelCutoffValue, ModelCutoffScore, ModelDeficit = readcorrespondencesfromfile(FN)
+
+#  print HasScore
+#  print ModelHasName
+
+  HasName.update(ModelHasName)
+  HasScore.update(ModelHasScore)
+
+  print "Read model correspondences from " + FN
+
+  # Loop through instances from 3D and from the sequence alignment and put in an alignment to display
+  DisplayColor = {}
+  aligdata = {}                                      # new dictionary
+
+  for a in InstanceToGroup.iterkeys():
+    m = re.search("(.+Instance_[0-9]+)",a)
+    aligdata[m.group(1)] = []                        # initialize this key with empty list
+    DisplayColor[m.group(1)] = 'blue'                # default display color
+
+  for a in SequenceToModel.iterkeys():
+    m = re.search("(Sequence_[0-9]+)",a)
+    aligdata[m.group(1)] = []                        # initialize this key with empty list
+    DisplayColor[m.group(1)] = 'black'               # default display color
+
+  for a in aligdata.iterkeys():
+    for j in range(0,len(ModelToColumn)):
+      aligdata[a].append('')                         # initialize with blank
+                                                     # sorting by key should keep insertions in order
+
+  for a in sorted(InstanceToGroup.iterkeys(), key=columnkeyforsortbynumber):
+    print a
+    m = re.search("(.+Instance_[0-9]+)",a)
+    print m.group(1)
+    t = int(ModelToColumn[GroupToModel[InstanceToGroup[a]]]) # map position in group to the correct column in the model and in the alignment
+    aligdata[m.group(1)][t-1] += a[len(a)-1]         # last character of the key is the base for this position
+
+  for a in sorted(SequenceToModel.iterkeys(), key=positionkeyforsortbynumber):
+    m = re.search("(Sequence_[0-9]+)",a)
+    t = int(ModelToColumn[SequenceToModel[a]])
+    aligdata[m.group(1)][t-1] += a[len(a)-1]
+
+  f = open(outputFile,"w")
+  f.write("<html><title>Alignment to "+motifID+"</title>\n")
+  f.write("<h1>Alignment of " + alignmentfile +" to "+motifID+"</h1>\n")
+  f.write("<a href=\"http://rna.bgsu.edu/rna3dhub/motif/view/" + motifID + "\" target=\"_blank\">Motif atlas entry for " + motifID + "</a><br>")
+  f.write("The correspondence between sequences from 3D structures and the motif group is shown in blue, JAR3D alignments of sequences to the motif group are shown in black, and sequences which are too long or too short to be aligned are indicated by : characters.")
+  f.write("<table>")
+  f.write(alignmentheaderhtml(ModelToColumn, GroupToModel)+'\n')
+  f.write(alignmentrowshtml(DisplayColor, aligdata, HasName, HasScore, HasInteriorEdit, HasFullEdit, HasCutoffValue, HasCutoffScore, HasAlignmentScoreDeficit))
+  f.write("</table>")
+
+  InteractionsFile = libDirectory + "\\" + motifID + "_interactions.txt"
+
+  f.write('<br><b>Conserved interactions between motif group positions in ' + motifID + ':</b>')
+  f.write('<pre>')
+  with open(InteractionsFile,"r") as mf:
+      for line in mf.readlines():
+        f.write(line)
+  f.write("</pre>")
+
+  ModelFile = libDirectory + "\\" + motifID + "_model.txt"
+  f.write('<b>JAR3D SCFG/MRF model for ' + motifID + ':</b>')
+  f.write('<pre>')
+  with open(ModelFile,"r") as mf:
+      for line in mf.readlines():
+        f.write(line)
+  f.write("</pre>")
+  f.write("</html>")
+  f.close()
+
+  print "Wrote html file with alignment of 3D instances and sequences for " + motifID
+
+  return aligdata
+
+if __name__ == "__main__":
+  fastatomodelalignment(sys.argv[1],sys.argv[2],sys.argv[3],sys.argv[4])
diff --git a/python/makeCorrespondencesAndDiagram.py b/python/makeCorrespondencesAndDiagram.py
new file mode 100644
index 0000000..e6c3cfd
--- /dev/null
+++ b/python/makeCorrespondencesAndDiagram.py
@@ -0,0 +1,137 @@
+
+# about jar3dalign_2015-04-03.jar
+# Main-Class: edu.bgsu.rna.jar3d.JAR3DCorrespondences
+#       String fastaFileName = args[0];
+#       String modelDirPath = args[1];
+#       String modelName = args[2];
+#       int rotation = Integer.parseInt(args[3]);
+#       String outputFileName = args[4];
+
+# http://varna.lri.fr/index.php?lang=en&css=varna&page=command
+# java -cp VARNAvX-Y.jar fr.orsay.lri.varna.applications.VARNAcmd [-i inputFile|-sequenceDBN XXX -structureDBN YYY] -o outFile [opts]
+# java -cp VARNAv3-93.jar fr.orsay.lri.varna.applications.VARNAcmd -sequenceDBN ACGU -structureDBN .... -o test.png
+
+import os
+from correspondenceToSVG import correspondenceToInteractionList
+from correspondenceToSVG import interactionListToSVG
+
+JAR3DPath = "C:\\Users\\zirbel\\Documents\\JAR3D\\"
+JAR3DAligner = "jar3dalign_2015-04-03.jar"
+viroidPath = "C:\\Users\\zirbel\\Documents\\JAR3D\\viroid\\"
+viroidDataFile = viroidPath + "WT sequences plus model IDs.csv"
+fastaFile = viroidPath + "temp.fasta"
+
+with open(viroidDataFile,'r') as fh:
+    viroidData = fh.readlines()
+
+#viroidData = viroidData[2:]
+
+html = "<html><body>"
+
+for data in viroidData:
+    print(data)
+    fields = data.split(",")
+    loopNum = fields[0]
+    sequence = fields[1]
+
+    if (loopNum == "1" or loopNum == "27"):
+        continue
+
+    numbers = []
+    if "*" in sequence:            # internal loop
+        s = sequence.find("*")
+        for i in range(0,len(sequence)):
+            if i < s:
+                numbers.append(int(fields[2])+i)
+            elif i > s:
+                numbers.append(int(fields[3])+i-s-1)
+            else:
+                numbers.append(0)    # * should not have a number
+    else:                          # hairpin loop
+        a = int(fields[2])
+        b = int(fields[3])
+        if a < b:                  # regular hairpin
+            for i in range(0,len(sequence)):
+                numbers.append(int(fields[2])+i)
+        else:                      # unusual case of a hairpin at the end of a circular RNA
+            for i in range(0,len(sequence)):
+                if len(sequence) - i > b:
+                    numbers.append(a+i)
+                else:
+                    numbers.append(b-len(sequence)+i)
+
+    with open(fastaFile,'w') as fh:
+        fh.write("> header\n")          # note that the header is necessary!
+        fh.write(sequence+"\n")
+
+    for m in range(1,len(fields)-3):    # counter through model numbers 1 to 10
+        modelName = fields[m+3].replace("\n","").replace(" ","")
+
+        html += "Loop %s Model %d " % (loopNum, m)
+        html += '<a href="http://rna.bgsu.edu/rna3dhub/motif/view/%s">%s</a><br>' % (modelName,modelName)
+
+        if "IL" in modelName:
+            maxRotation = 1
+            type = "IL"
+        else:
+            maxRotation = 0
+            type = "HL"
+
+        bestScore = -float('inf')
+        bestRotation = 0
+        for rotation in range(0,maxRotation+1):
+            align = "java -jar " + JAR3DPath + JAR3DAligner + " "
+            align += fastaFile + " "
+            align += JAR3DPath + type + "\\1.18\\lib\\" + " "
+            align += modelName + " "
+            align += str(rotation) + " "
+            correspondenceFile = viroidPath + "correspondences_" + str(rotation) + ".txt"
+
+            align += correspondenceFile
+            print("Loop " + loopNum + " " + str(m) + " " + fastaFile + " " + modelName + " " + str(rotation))
+            os.system(align)
+
+            if type == "IL":
+                with open(correspondenceFile,'r') as fh:
+                    correspondenceData = fh.readlines()
+
+                for line in correspondenceData:
+                    if "Sequence_1 has_score " in line:
+                        lineFields = line.split(" ")
+                        currentScore = float(lineFields[2])
+
+                        if currentScore > bestScore:
+                            bestRotation = rotation
+                            bestScore = currentScore
+
+        rotation = bestRotation
+        print("Best rotation is "+str(rotation))
+        correspondenceFile = viroidPath + "correspondences_" + str(rotation) + ".txt"
+
+        imageFile = viroidPath + "Loop_" + loopNum + "_Model_" + "%02d" % m + "_" + modelName + "_" + str(rotation) + ".svg"
+
+        html += '<img src="%s"><br>' % ("Loop_" + loopNum + "_Model_" + "%02d" % m + "_" + modelName + "_" + str(rotation) + ".svg")
+
+        interactionList = correspondenceToInteractionList(JAR3DPath + type + "\\1.18\\lib",modelName,correspondenceFile)
+        if rotation == 1:
+            s = sequence.find("*")
+            map = range(s+1,len(sequence)) + [s] + range(0,s)   # works for internal loops; junctions harder
+            for i in range(0,len(interactionList)):
+                interactionList[i]["firstSequencePosition"] = map[interactionList[i]["firstSequencePosition"]]
+                interactionList[i]["secondSequencePosition"] = map[interactionList[i]["secondSequencePosition"]]
+
+        SVGtext = interactionListToSVG(sequence,interactionList,numbers)
+
+#        print(SVGtext)
+
+        with open(imageFile,'w') as fh:
+            fh.write(SVGtext)
+
+        html += "</body></html>"
+
+        with open(viroidPath + "alldiagrams.html",'w') as fh:
+            fh.write(html)
+
+#        VARNA = correspondenceToVARNA(JAR3DPath + type + "\\1.18\\lib",modelName,correspondenceFile,VARNAFile)
+#        os.system(VARNA)
+
diff --git a/src/main/java/edu/bgsu/rna/jar3d/Alignment.java b/src/main/java/edu/bgsu/rna/jar3d/Alignment.java
index 2889620..b671a45 100644
--- a/src/main/java/edu/bgsu/rna/jar3d/Alignment.java
+++ b/src/main/java/edu/bgsu/rna/jar3d/Alignment.java
@@ -64,7 +64,8 @@ public class Alignment {
 	 * @param DNA
 	 * @return
 	 */
-	public static Vector<Sequence> loadFastaColumnsDNA(String fileName, int StartCol, int EndCol, int DNA) 		{
+	public static Vector<Sequence> loadFastaColumnsDNA(String fileName, int StartCol, int EndCol, int DNA)
+		{
 		Vector<Sequence> sData = new Vector<Sequence>();
 		String temp="";
 		String organism="";
@@ -110,8 +111,8 @@ public class Alignment {
 				}
 				else
 				{
-					if (DNA > 0) {
-						// change A to U, G to C, etc.
+					if (DNA > 0)
+					{
 						temp = temp.replace("A", "w");
 						temp = temp.replace("a", "w");
 						temp = temp.replace("C", "x");
@@ -144,7 +145,6 @@ public class Alignment {
                 letters = d + letters;
 			}
 
-			// System.out.println(String.format("Alignment.loadFastaColumnsDNA: filename %s organism %s letters %s",fileName,organism,letters));
 
 			if (EndCol > 0)
 				sData.add(new Sequence(organism.substring(1,organism.length()),letters.substring(StartCol,EndCol)));
@@ -223,7 +223,7 @@ public class Alignment {
 		String letters="";
 		String second = "";
 		String first  = "";
-
+		
 		reverseSData.add(new Sequence("","")); // save space for header information to be added later as element 0 of this vector
 
 		for (int i=1; i < sequenceData.size(); i++)
@@ -243,67 +243,13 @@ public class Alignment {
 		return reverseSData;
 	}
 
-
-	/**
-	 * This method rotates strand orders r times in sequenceData and returns a new vector of sequence data
-	 * @param sequenceData
-	 * @return
-	 */
-	public static List<Sequence> rotate(List<Sequence> sequenceData, int rotation) {
-		List<Sequence> rotatedSData = new Vector<Sequence>();
-
-		String temp="";
-		String organism="";
-		String letters= "";
-		String second = "";
-		String first  = "";
-
-		rotatedSData.add(new Sequence("","")); // save space for header information to be added later as element 0 of this vector
-
-		for (int s=1; s < sequenceData.size(); s++)		{
-			temp = sequenceData.get(s).letters;
-			organism = sequenceData.get(s).organism;
-
-			String[] parts = temp.split("\\*");  // split on "*"
-			int n = parts.length;
-			StringBuilder result = new StringBuilder();
-
-			for (int k = 0; k < n; k++) {
-				result.append(parts[(k + rotation) % n]);
-				if (k < n-1) {
-					result.append("*");
-				}
-			}
-
-		    letters = result.toString();
-
-			System.out.println(String.format("Alignment rotate: rotation %d",rotation));
-			System.out.println(String.format("Alignment rotate: organism %s",organism));
-			System.out.println(String.format("Alignment rotate: letters  %s",letters));
-
-			// print the stack so we know how we got here
-			// StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
-			// StringBuilder sb = new StringBuilder();
-			// for (StackTraceElement element : stackTrace) {
-			// 	System.out.println(element.toString());
-			// }
-
-			// pause so we can see the stack trace
-			// try {
-			// 	Thread.sleep(1000);
-			// } catch (InterruptedException e) {
-			// 	e.printStackTrace();  // or handle interruption another way
-			// }
-
-			rotatedSData.add(new Sequence(organism,letters));
-
-		}
-		return rotatedSData;
-	}
-
-
 	/**
-	 * This method initiates parsing.
+	 * This method initiates parsing.  It loops through all Sequence objects in sData.
+	 * It adds node data just once, to a new Sequence object called S.  Then it adds the organism and letters from each Sequence object.
+	 * Then it runs the parseSequence method of the Sequence class.
+	 * It runs through all nodes to store max log probability information
+	 * Finally, it calls the showParse method of the first node of the model, which accumulates a very, very wide version of the
+	 * alignments in row-column format.  Many columns of the alignment then need to get removed later.
 	 * @param sData
 	 * @param nodeFileName
 	 * @param range
@@ -613,7 +559,8 @@ public class Alignment {
 		return scores;
 	}
 
-	public static double[] getSortedILAlignment(List<Sequence> sData, List<String> modNames, int range) 	{
+	public static double[] getSortedILAlignment(List<Sequence> sData, List<String> modNames, int range)
+	{
 		Vector<String> pData = new Vector<String>();                           // parse data
 		double[] modelSums = new double[modNames.size()];      // sum of alignment scores
 		double[] rmodelSums = new double[modNames.size()];     // sum with sequences reversed
@@ -777,9 +724,9 @@ public class Alignment {
 		return scores;
 	}
 
-
+	
 	// doParse2 is probably outmoded and should be avoided - CLZ 2013-03-04
-
+	
 	public static ParseData doParse2(List<Sequence> sData, String nodeFileName, int range)
 	{
 		Node current;
@@ -882,7 +829,7 @@ public class Alignment {
 				// double tempo = sData.get(m+1).getMaxNodeLogProbabilityOf(0, 0);  // stopped working! same number for all m, even though fine in doParse
 				double tempo = sData.get(m+1).getMaxLogProbability(0);
 				scores[m] = tempo;
-
+		
 				System.out.println("getILScoresSingle:  getMaxNodeLogProbabilityOf: "+sData.get(m+1).getMaxNodeLogProbabilityOf(0, 0));
 				System.out.println("getILScoresSingle:  scores[m]:                  "+scores[m]);
 				System.out.println("getILScoresSingle:  getMaxLogProbability:       "+sData.get(m+1).getMaxLogProbability(0));
@@ -898,9 +845,8 @@ public class Alignment {
 			int range, boolean saveSeqRes) {
 
 		List<Sequence> sData = loop.getSequences();
-
 		Query query = loop.getQuery();
-
+		
 		// 2013-11-05 CLZ Last argument cannot be null, must be something like "IL"
 		// 2013-11-05 CLZ Last argument seems to be reliably obtained from loop
 		List<LoopResult> results = doLoopDBQuery((int)loop.getId(), query, sData, modNames, groupData, range, loop, loop.getTypeString(), saveSeqRes);
@@ -911,19 +857,19 @@ public class Alignment {
 
 		return results;
 	}
-
+	
 	public static List<SequenceResult> doSingleDBQuery(Loop loop, MotifGroup group, String model_id, int range) {
-
+		
 		List<Sequence> sData = loop.getSequences();
 		Query query = loop.getQuery();
-
+		
 		// 2013-11-05 CLZ Last argument cannot be null, must be something like "IL"
 		// 2013-11-05 CLZ Last argument seems to be reliably obtained from loop
 		List<SequenceResult> results = doSingleDBQuery(query, sData, group, model_id, range, loop, loop.getTypeString());
-
+		
 		return results;
 	}
-
+	
 	//Takes a JAR3D query and submits results to MySQL database
 		public static List<LoopResult> doLoopDBQuery(int loopID, Query query, List<Sequence> sData, List<String> modNames,
 				HashMap<String, MotifGroup> groupData, int range, Loop loop, String type) {
@@ -935,120 +881,135 @@ public class Alignment {
 	public static List<LoopResult> doLoopDBQuery(int loopID, Query query, List<Sequence> sData, List<String> modNames,
 			HashMap<String, MotifGroup> groupData, int range, Loop loop, String type, Boolean saveSeqRes) {
 
-		// new code to handle all required rotations at once
-		int maxRotation = 0;
-		if (type.equalsIgnoreCase("HL")) {
-			maxRotation = 0;
-		} else if (type.equalsIgnoreCase("IL")){
-			maxRotation = 1;
-		} else if (type.startsWith("J")) {
-			// J3, J4, ...
-			maxRotation = Integer.parseInt(type.substring(1)) - 1;
-		}
-
-		List<Sequence>[] rotatedData = new Vector[maxRotation+1];  // Array of Vector<Sequence>
-		int[] bestRotation = new int[modNames.size()];             // 0 for HL, 0 or 1 for IL, etc.
-		double[] scores = new double[modNames.size()];
+		// TODO 2013-11-07 CLZ generalize this so that it can apply to HL, IL, 3WJ, 4WJ, etc.
+		// Currently there is only space for rotations 0 and 1
+		
+		
+		double[] modelSums = new double[modNames.size()];      // sum of alignment scores
+		double[] rmodelSums = new double[modNames.size()];     // sum with sequences reversed
+		double[] modelScores = new double[modNames.size()];
+		double[] rmodelScores = new double[modNames.size()];
+		double[][] modelScoreMat = new double[modNames.size()][sData.size()];
+		double[][] rmodelScoreMat = new double[modNames.size()][sData.size()];
+		List<String> shortModNames = new Vector<String>();                   // for easier display
+		int[] reversed = new int[modNames.size()];             // is best model reversed?
+		double[] scores = new double[2*modNames.size()];
 		List<LoopResult> loopRes = new Vector<LoopResult>();
-
-		// rotate sequence data however many times are needed; 0 for HL, 0 and 1 for IL, etc.
-		for (int r = 0; r <= maxRotation; r++) {
-			rotatedData[r] = Alignment.rotate(sData,r);
+		List<Sequence> rsData = new Vector<Sequence>();
+		
+		if(type.equalsIgnoreCase("IL")){
+			rsData = Alignment.reverse(sData);  // reversed sequence data
 		}
-
-		List<String> shortModNames = new Vector<String>();                   // for easier display
+		
 	    shortModNames = new Vector<String>(modNames);
-		Vector<String> tinyModNames = new Vector<String>(shortModNames);
-
-		// Parse all sequences against all groups in all rotations
+	    Vector<String> tinyModNames = new Vector<String>(shortModNames);
+	    //Parse all sequences against all groups
 	    MotifGroup group;
-	    for (int k = 0; k < modNames.size(); k++) {
+	    for(int k = 0; k < modNames.size(); k++)
+		{
 	    	group = groupData.get(modNames.get(k));
-			for (int r = 0; r <= maxRotation; r++) {
-				rotatedData[r] = Alignment.doParse(rotatedData[r], group.Model, range, true, false, false);
-			}
-		}
-
-	    // Record model scores for each sequence, sum over sequences
-		double[][] modelRotationScoreSum = new double[modNames.size()][maxRotation+1];      // sum of alignment scores
-		double[][][] modelRotationSequenceScore = new double[modNames.size()][maxRotation+1][sData.size()];
-
-		for (int r = 0; r <= maxRotation; r++) {
-			for (int m = 0; m < modNames.size(); m++) {
-				for (int s = 1; s < sData.size(); s++) {
-					double tempo = rotatedData[r].get(s).getMaxLogProbability(m);
-					modelRotationScoreSum[m][r] += tempo;
-					modelRotationSequenceScore[m][r][s] = tempo;
-				}
+			sData  = Alignment.doParse(sData, group.Model, range, true, false, false);
+			if(type.equalsIgnoreCase("IL")){
+				rsData = Alignment.doParse(rsData, group.Model, range, true, false, false);
 			}
 		}
 
-		// for each group find the best rotation
-	    for (int m = 0; m < modNames.size(); m++) {
-			scores[m] = -9999;
-			bestRotation[m] = 0;
-			for (int r = 0; r <= maxRotation; r++) {
-				// number of sequences is sData.size()-1, 0th place is empty to leave space for headers
-				double tempScore = modelRotationScoreSum[m][r]/(sData.size()-1);
-				if (tempScore > scores[m]) {
-					scores[m] = tempScore;
-					bestRotation[m] = r;
-				}
-			}
-			System.out.println(String.format("Alignment: groupName %s best rotation %d score %8.2f",modNames.get(m),bestRotation[m],scores[m]));
-		}
+	    //Add up model scores for each sequence, find mean score, compare regular and reversed scores
+	    for(int m = 0; m < sData.size(); m++)
+	    {
+	    	for(int x = 0; x < sData.get(m).getMaxLogProbabilitySize(); x++)
+	    	{
+	    		double tempo = sData.get(m).getMaxLogProbability(x);
+	    		modelSums[x] += tempo;
+	    		modelScoreMat[x][m] = tempo;
+	    		if(type.equalsIgnoreCase("IL")){
+	    			tempo = rsData.get(m).getMaxLogProbability(x);
+	    			rmodelSums[x] += tempo;
+	    			rmodelScoreMat[x][m] = tempo;
+	    		}
+	    	}
+	    }
+	    
+	    for(int g = 0; g < modelSums.length; g++)
+	    {
+	    	modelScores[g] = (modelSums[g]/(sData.size()-1));
+	    	scores[2*g]   = Math.max(modelScores[g],-9999);
+	    	if(type.equalsIgnoreCase("IL")){
+	    		rmodelScores[g] = (rmodelSums[g]/(sData.size()-1));
+	    		scores[2*g+1] = Math.max(rmodelScores[g],-9999);
+	    	}
+	    	if(type.equalsIgnoreCase("IL")){
+	    		if(rmodelScores[g] > modelScores[g])          // choose between forward and reversed for each model
+	    		{
+	    			modelScores[g] = rmodelScores[g];
+	    			shortModNames.set(g, shortModNames.get(g)+" reversed");
+	    			reversed[g] = 1;
+	    		}
+	    		else {
+	    			reversed[g] = 0;
+	    		}
+	    	}else{
+	    		reversed[g] = 0;
+	    	}
+	    }
 
-		// re-sort models & their totals ... doesn't seem to be used anymore
+		// re-sort models & their totals
 		// weird indexing array to keep track of the order things should be in
 		// it starts out as [0 1 2 3 4 5]
 		// then gets re-sorted according to modelScores
 		// ie [0 2 3 1 5 4] means that in other vectors, their index 0 is the first
 		// index 3 is second, 2 is the third, ect
+
 		int[] indices = new int[modNames.size()];
-		for(int m = 0; m < modNames.size(); m++) {
-			indices[m] = m;
+		for(int k = 0; k < modNames.size(); k++) {
+			indices[k] = k;
 		}
+		
+		//Calculate extra information (edit distances, cutoffs) and output
+		int numInputSeqs = sData.size()-1;
+		for(int g = 0; g < modNames.size(); g++) {
 
-		// Calculate extra information (edit distances, cutoffs) and output
-		for (int m = 0; m < modNames.size(); m++) {
-
-			int index = indices[m];
+			int index = indices[g];
 			String groupName = tinyModNames.get(index);
 			String sig;
-			int rotation = bestRotation[m];
+			int rotation;                 
 			double[] groupScores = new double[sData.size()];
 			group = groupData.get(groupName);
+			if (reversed[index] == 0) {  //not reversed
+				rotation = 0;
+				sig = group.Signature[0];
+				for(int col = 1; col < numInputSeqs+1; col++)
+				{
+					groupScores[col-1] = modelScoreMat[index][col];
+				}
+			} else {  //reversed
+				rotation = 1;
+				sig = group.Signature[1];
 
-			// System.out.println(String.format("Alignment: groupName %s",groupName));
-
-			sig = group.Signature[0]; // don't reverse the signature, too confusing
-
-			System.out.println(String.format("group.Signature %s", group.Signature));
-
-			for (int s = 1; s < sData.size(); s++) {
-				groupScores[s-1] = modelRotationSequenceScore[index][rotation][s];
+				for(int col = 1; col < numInputSeqs+1; col++) {
+					groupScores[col-1] = rmodelScoreMat[index][col];
+				}
 			}
-
+			
 			double[] deficits = getDeficits(group.Best_Score, groupScores);
 
-			// sequences are already rotated; pass in the optimal rotation, 0 additional rotation
-			// EditDistance functions need to work on J3, J4, etc.
-			int[] InteriorMinDist = getMinEditDistance(group,rotatedData[rotation],type,0,true);
-			int[] FullMinDist = getMinEditDistance(group,rotatedData[rotation],type,0,false);
-
+			int[] InteriorMinDist = getMinEditDistance(group,sData,type,rotation,true);
+			int[] FullMinDist = getMinEditDistance(group,sData,type,rotation,false);
+			
 			boolean[] cutoffs = getCutoffs(group,groupScores,InteriorMinDist);
 			double[] cutoffscores = getCutoffScores(group,groupScores,InteriorMinDist);
 
 			if (true) {
 				LoopResult loopR;
-				if (saveSeqRes) {
+				if(saveSeqRes){
 					List<SequenceResult> seqRes = new ArrayList<SequenceResult>();
-					for (int s = 1; s < sData.size(); s++) {
-						SequenceResult seqR = new BasicSequenceResult(sData.get(s), groupScores[s-1], deficits[s-1], InteriorMinDist[s-1], FullMinDist[s-1],rotation,cutoffs[s-1],cutoffscores[s-1]);
+					for(int m = 0; m < sData.size() - 1; m++) {
+						SequenceResult seqR = new BasicSequenceResult(sData.get(m + 1), groupScores[m], deficits[m], InteriorMinDist[m], FullMinDist[m],rotation,cutoffs[m],cutoffscores[m]);
 						seqRes.add(seqR);
 					}
 					loopR = new BasicLoopResult(groupName, rotation, sig, seqRes);
-				} else {
+				}
+				else{
 					double medianScore = ArrayMath.median(groupScores);
 					double meanScore = ArrayMath.mean(groupScores);
 					double meanDeficit = ArrayMath.mean(deficits);
@@ -1061,11 +1022,11 @@ public class Alignment {
 					double meanCutoffScore = ArrayMath.mean(cutoffscores);
 
 					loopR = new BasicLoopResult(groupName, rotation, sig,
-						medianScore, meanScore,
-						meanDeficit, medianDeficit,
-						meanInteriorEditDistance, medianInteriorEditDistance,
-						meanFullEditDistance, medianFullEditDistance,
-						meanCutoff, meanCutoffScore);
+							medianScore, meanScore,
+							meanDeficit, medianDeficit,
+							meanInteriorEditDistance, medianInteriorEditDistance,
+							meanFullEditDistance, medianFullEditDistance,
+							meanCutoff, meanCutoffScore);
 				}
 				loopR.setLoop(loop);
 				loopRes.add(loopR);
@@ -1075,11 +1036,11 @@ public class Alignment {
 		System.gc();
 		System.runFinalization();
 		System.gc();
-
+		
 		return loopRes;
 	}
-
-	// Takes a JAR3D query and submits results to MySQL database
+	
+	//Takes a JAR3D query and submits results to MySQL database
 	public static List<SequenceResult> doSingleDBQuery(Query query, List<Sequence> sData,
 			MotifGroup group, String model_id, int range, Loop loop, String type) {
 
@@ -1093,11 +1054,11 @@ public class Alignment {
 		double[] rmodelScores = new double[sData.size()];
 		int reversed;
 		List<Sequence> rsData = new Vector<Sequence>();
-
+		
 		if(type.equalsIgnoreCase("IL")){
 			rsData = Alignment.reverse(sData);  // reversed sequence data
 		}
-
+		
 	    sData  = Alignment.doParse(sData, group.Model, range, true, true, false);
 			if(type.equalsIgnoreCase("IL")){
 				rsData = Alignment.doParse(rsData, group.Model, range, true, true, false);
@@ -1114,7 +1075,7 @@ public class Alignment {
 	    		rmodelScores[m] = tempo;
 	    	}
 	    }
-
+	    
 	    modelScore = (modelSum/(sData.size()-1));
 	    if(type.equalsIgnoreCase("IL")){
 	    	rmodelScore = (rmodelSum/(sData.size()-1));
@@ -1132,20 +1093,20 @@ public class Alignment {
 	    }else{
 	    	reversed = 0;
 	    }
-
+	    
 	    double[] groupScores = new double[sData.size()];
 	    for(int i=1; i <sData.size(); i++){
 	    	groupScores[i-1] = modelScores[i];
 	    }
-
+	    
 	    double[] deficits = getDeficits(group.Best_Score, groupScores);
-
+	    
 	    int[] InteriorMinDist = getMinEditDistance(group,sData,type,reversed,true);
 		int[] FullMinDist = getMinEditDistance(group,sData,type,reversed,false);
-
+		
 		boolean[] cutoffs = getCutoffs(group,groupScores,InteriorMinDist);
 		double[] cutoffscores = getCutoffScores(group,groupScores,InteriorMinDist);
-
+	    
 	    List<SequenceResult> seqRes = new ArrayList<SequenceResult>();
 		for(int m = 0; m < sData.size() - 1; m++) {
 			SequenceResult seqR;
@@ -1156,76 +1117,56 @@ public class Alignment {
 			}
 			seqRes.add(seqR);
 		}
-
+		
 		LoopResult result = new BasicLoopResult(model_id, reversed, "sig", seqRes);
-
+	    
 		for(SequenceResult res : seqRes) {
 			res.setLoopResult(result);
 		}
-
+		
 	    //Try to clean up the memory we used
 	    System.gc();
 	    System.runFinalization();
 	    System.gc();
 
 	    return seqRes;
-
+			
 	}
-
+	
 	public static List<Sequence> doParse(List<Sequence> sData, String nodeInfo, int range, boolean fullModelText, boolean calculateCorrespondences)
 	{
 		return doParse(sData,nodeInfo,range,fullModelText,calculateCorrespondences,false);
 	}
 
-	// Overloaded doParse that can take model/node data as a string instead of a file name
-	// It loops through all Sequence objects in sData.
-	// It adds node data just once, to a new Sequence object called S.  Then it adds the organism and letters from each Sequence object.
-	// Then it runs the parseSequence method of the Sequence class.
-	// It runs through all nodes to store max log probability information
-	// Finally, it calls the showParse method of the first node of the model, which accumulates a
-	// very, very wide version of the alignments in row-column format.
-	// Many columns of the alignment then need to get removed later.
-
-	public static List<Sequence> doParse(List<Sequence> sData, String nodeInfo, int range, boolean fullModelText, boolean calculateCorrespondences, boolean saveNodeProbs) 	{
+	//Overloaded doParse that can take model/node data as a string instead of a file name
+	public static List<Sequence> doParse(List<Sequence> sData, String nodeInfo, int range, boolean fullModelText, boolean calculateCorrespondences, boolean saveNodeProbs)
+	{
 		Node current;
 		List<Double> mProbs = new Vector<Double>();
 		double mlp;
-
-		// System.out.println("Alignment.doParse: nodeInfo " + nodeInfo);
-
+		
+//		System.out.println("Alignment.doParse:" + nodeInfo);
+		
 		Sequence S = new Sequence("","");                    // blank sequence to use repeatedly
-		if (fullModelText){
+		if(fullModelText){
 			S.addNodeDataModelText(nodeInfo);				 // add model data from string
-		} else {
+		}else{
 			S.addNodeData(nodeInfo);	                     // add model data from file
 		}
-
+		
 		sData.get(0).parseData = ((Node)S.first).header(); // add a header line
 
 		Sequence firstS = sData.get(1);          // first sequence, which matches the model
 		firstS.setNucleotides();
 		firstS.setArrays();
 
-		for (int i = 1; i < sData.size(); i++) {
+		for (int i = 1; i < sData.size(); i++)
+		{
 			S.organism = sData.get(i).organism;             // focus on one sequence
 			S.letters  = sData.get(i).letters;
-
-			// don't know why there is an extra * at the end of the sequences
-			// System.out.println(String.format("Alignment.doParse: organism %s",S.organism));
-			// System.out.println(String.format("Alignment.doParse: letters  %s",S.letters));
-
-			// print the stack to know what called this
-			// StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
-			// StringBuilder sb = new StringBuilder();
-			// for (StackTraceElement element : stackTrace) {
-			// 	System.out.println(element.toString());
-			// }
-
 			S.setNucleotides();                                    // strip dashes from sequence
 			S.setArrays();                                         // define cti, itc, convert letters to numbers
 
-			// System.out.println(String.format("Alignment.doParse S.nucleotides %s", S.nucleotides));
-
 			// keep copies of cti and itc for the first sequence, which must match the model
 			S.ctiFirst = new int[firstS.cti.length];
 			S.itcFirst = new int[firstS.itc.length];
@@ -1237,7 +1178,7 @@ public class Alignment {
 
 			mlp = S.parseSequence(range);                             	      // parse this sequence
 			sData.get(i).appendProbabilities(mlp); 							  // save mlp
-
+		
 			// We also need to store the parse information somewhere!  All we have is a parse sequence.
 			// We need to store the max log probabilities too
 
@@ -1257,7 +1198,7 @@ public class Alignment {
 					System.out.println("doParse: retrieve mProbs gives           "+sData.get(i).getMaxNodeLogProbabilityOf(0,0));
 				sData.get(i).parseData = ((InitialNode)S.first).showParse(S.nucleotides);
 			}
-
+			
 			if (calculateCorrespondences) {
 				String correspondences = ((InitialNode)S.first).showCorrespondences(S.nucleotides);
 				correspondences = correspondences.replace("JAR3D_aligns_to", "aligns_to_JAR3D");
@@ -1267,7 +1208,7 @@ public class Alignment {
 				sData.get(i).correspondences += "Sequence_"+i+" has_name "+sData.get(i).organism.replace(" ","_")+"\n";
 				sData.get(i).correspondences += "Sequence_"+i+" has_score "+sData.get(i).getMaxLogProbability(0)+"\n";
 			}
-		}
+		}				
 
 		if (calculateCorrespondences) {
 			for (int i = 1; i < sData.size(); i++)
@@ -1288,7 +1229,7 @@ public class Alignment {
 	{
         double totalProb;
         int userange;
-
+        
 		Sequence S = new Sequence("","");                    // blank sequence to use repeatedly
 		if(fullModelText){
 			S.addNodeDataModelText(nodeInfo);				 // add model data from string
@@ -1322,7 +1263,7 @@ public class Alignment {
 				userange = S.letters.length();
 			else
 				userange = range;
-
+			
 			totalProb = S.calculateTotalProbability(userange); // calculate total probability for this sequence
 			sData.get(i).totalProbability = totalProb;      // record total probability for each sequence
 		}
@@ -1331,23 +1272,21 @@ public class Alignment {
 
 
 	public static int[] getMinEditDistance(MotifGroup group, List<Sequence> sData, String type, int rotation, boolean interior){
-
-		// load sequences from the current motif group
+		//Calculate edit distances
 		Vector<Sequence> modsData = Alignment.parseFastaText(group.Sequences,0,0);
-
-		// Calculate edit distances
-		// we assume that the sequences in sData are already rotated appropriately
 		int[][] EditDistances;
-		EditDistances = SimpleAlign.calcEditDistances(sData,modsData,false,interior);
-
-		// for each sequence in sData, return the minimum edit distance to model sequences
+		if(type.equalsIgnoreCase("IL")){
+			EditDistances = SimpleAlign.calcILEditDistances(sData,modsData,rotation,false,interior);
+		}else {
+			EditDistances = SimpleAlign.calcHLEditDistances(sData,modsData,false,interior);
+		}
 		int[] MinDist = new int[EditDistances.length];
-		for (int i = 0; i < EditDistances.length; i++) {
+		for(int i = 0; i < EditDistances.length; i ++){
 			MinDist[i] = ArrayMath.min(EditDistances[i]);
 		}
 		return MinDist;
 	}
-
+	
 	public static boolean[] getCutoffs(MotifGroup group, double[] groupScores, int[] InteriorMinDist){
 		boolean[] cutoffs = new boolean[InteriorMinDist.length];
 		for(int i = 0; i < InteriorMinDist.length; i++){
@@ -1376,7 +1315,7 @@ public class Alignment {
 		}
 		return cutoffscores;
 	}
-
+	
 	public static double[] getDeficits(double best_score, double[] groupScores) {
 		double [] deficits =  new double[groupScores.length];
 		for(int i = 0; i < groupScores.length; i++) {
diff --git a/src/main/java/edu/bgsu/rna/jar3d/Application.java b/src/main/java/edu/bgsu/rna/jar3d/Application.java
index 80acaef..5959075 100644
--- a/src/main/java/edu/bgsu/rna/jar3d/Application.java
+++ b/src/main/java/edu/bgsu/rna/jar3d/Application.java
@@ -17,10 +17,9 @@ import edu.bgsu.rna.jar3d.results.LoopResult;
 import edu.bgsu.rna.jar3d.results.SequenceResult;
 
 /**
- * An Application is simple way to load sequences and models,
- * run the models over the sequences and save the results.
+ * An Application is simple way to load sequences and models, run the models over the sequences
+ * and save the results.
  * This can only load from the file system currently and uses only bp models at the moment.
- * In addition, it will only run internal loops.
  */
 public class Application {
 
@@ -57,7 +56,7 @@ public class Application {
 	 *
 	 * @param loader The query loader to use.
 	 * @param saver The result saver to use.
-	 * @param modelType The model type to use.  Like "bp" for basepair.
+	 * @param modelType The model type to use.
 	 * @param version The version to use.
 	 * @param rangeLimit The range limit to scan.
 	 */
@@ -88,26 +87,7 @@ public class Application {
 	 * @throws QueryLoadingFailed
 	 */
 	public List<List<LoopResult>> runQuery(String queryId, String base) throws QueryLoadingFailed {
-		// DBLoader.java is where the work of the query actually happens
-		// query is of type ImmutableQuery
 		Query query = loader.load(queryId);
-
-		// System.out.println("Application.runQuery should have run the loader");
-		// System.out.println(String.format("queryId: %s", queryId));
-		// System.out.println(String.format("base   : %s", base));
-
-		// // query contains a list of loops, which have sequences in them; query also contains more
-		// for (Loop loop: query) {
-		// 	String type = loop.getLoopType().getShortName();
-		// 	System.out.println("Application.runQuery loop contents");
-		// 	System.out.println(type);
-		// 	List<Sequence> sData = loop.getSequences();
-		// 	for (int i = 1; i < sData.size(); i++) {
-		// 		System.out.println(String.format("organism: %s",sData.get(i).organism));
-		// 		System.out.println(String.format("letters : %s",sData.get(i).letters));
-		// 	}
-		// }
-
 		return runQuery(query, base);
 	}
 
@@ -148,6 +128,7 @@ public class Application {
 		Vector<String> modelNames = Sequence.getModelNames(base, modelType, false);
 		HashMap<String,MotifGroup> groupData = webJAR3D.loadMotifGroups(base, modelType);
 
+
 		for(Loop loop: query) {
 			List<LoopResult> results = motifParse(modelNames, groupData, loop, true);
 			allResults.add(results);
@@ -157,8 +138,6 @@ public class Application {
 
 	/**
 	 * Run a query and return the results.
-	 * Handle HL and IL with the paths provided.
-	 * For J3 and higher, modify the path in a natural way.
 	 *
 	 * @param ILbase The base path to the IL models.
 	 * @param HLbase The base path to the HL models
@@ -173,82 +152,50 @@ public class Application {
 
 		for(Loop loop: query) {
 			String type = loop.getLoopType().getShortName();
-			String model_base;
-
-			// use loop type to set the directory for models
-			if (type.equals("HL")) {
-				model_base = HLbase;
-			} else if (type.equals("IL")) {
-				model_base = ILbase;
-			} else {
-				// Modify the HL path to get the J3, J4, ... path
-				model_base = HLbase.replace("/HL/", "/" + type + "/");
-			}
-
-			// process all loop types using the same code
-			System.out.println("Looking for a list of motifs to use in "+model_base);
-			File mf = new File(model_base);
-			String parent_folder = mf.getParent();
-			System.out.println("Setting user directory to "+parent_folder);
-			System.setProperty("user.dir", parent_folder);
-
-			Vector<String> ModelNames = Sequence.getModelNames(model_base, modelType, false);
-			HashMap<String,MotifGroup> GroupData = webJAR3D.loadMotifGroups(model_base, modelType);
-
-			// process the sequences using the identified models
-			results = motifParse(ModelNames, GroupData, loop, false);
-
-			// old code that duplicated the same commands
-			// if (type.equals("HL")) {
-			// 	// Load HL Motif Group information
-			// 	File hlf = new File(HLbase);
-
-			// 	String hlfolder = hlf.getParent();
+			if (type.equals("HL")){
+				//Load HL Motif Group information
+				File hlf = new File(HLbase);
+				String hlfolder = hlf.getParent();
 
-			// 	System.out.println("Looking for a list of motifs to use in "+HLbase);
-			// 	System.out.println("Looking for motifs in "+hlfolder);
+				System.out.println("Looking for a list of motifs to use in "+HLbase);
+				System.out.println("Looking for motifs in "+hlfolder);
 
-			// 	System.setProperty("user.dir", hlfolder);
+				System.setProperty("user.dir", hlfolder);
 
-			// 	Vector<String> HLModelNames = Sequence.getModelNames(HLbase, modelType, false);
-			// 	HashMap<String,MotifGroup> HLGroupData = webJAR3D.loadMotifGroups(HLbase, modelType);
+				Vector<String> HLModelNames = Sequence.getModelNames(HLbase, modelType, false);
+				HashMap<String,MotifGroup> HLGroupData = webJAR3D.loadMotifGroups(HLbase, modelType);
+				results = motifParse(HLModelNames, HLGroupData, loop, false);
+			} else if (type.equals("IL")){
+				//Load IL Motif Group information
+				File ilf = new File(ILbase);
+				String ilfolder = ilf.getParent();
 
-			// 	// process the sequences using HL models
-			// 	results = motifParse(HLModelNames, HLGroupData, loop, false);
-			// } else if (type.equals("IL")) {
-			// 	// Load IL Motif Group information
-			// 	File ilf = new File(ILbase);
-			// 	String ilfolder = ilf.getParent();
+				System.out.println("Looking for a list of motifs to use in "+ILbase);
+				System.out.println("Looking for motifs in "+ilfolder);
 
-			// 	System.out.println("Looking for a list of motifs to use in "+ILbase);
-			// 	System.out.println("Looking for motifs in "+ilfolder);
+				System.setProperty("user.dir", ilfolder);
 
-			// 	System.setProperty("user.dir", ilfolder);
-
-			// 	Vector<String> ILModelNames = Sequence.getModelNames(ILbase, modelType, false);
-			// 	HashMap<String,MotifGroup> ILGroupData = webJAR3D.loadMotifGroups(ILbase, modelType);
-
-			// 	// process the sequences using IL models
-			// 	results = motifParse(ILModelNames, ILGroupData, loop, false);
-			// } else {
-			// 	// Load J3 or J4 ... Motif Group information
-			// 	// Modify the HL path to get the JX path
-			// 	String JLbase = HLbase.replace("/HL/", "/" + type + "/");
-
-			// 	File jlf = new File(JLbase);
-			// 	String jlfolder = jlf.getParent();
+				Vector<String> ILModelNames = Sequence.getModelNames(ILbase, modelType, false);
+				HashMap<String,MotifGroup> ILGroupData = webJAR3D.loadMotifGroups(ILbase, modelType);
+				results = motifParse(ILModelNames, ILGroupData, loop, false);
+			}
+		} else if (type.startsWith("J")){
+			// Load J3 or J4 ... Motif Group information
+			// Modify the HL path to get the JX path
+			String JLbase = HLbase.replace("/HL/", "/" + type + "/");
 
-			// 	System.out.println("Looking for a list of motifs to use in "+JLbase);
-			// 	System.out.println("Looking for motifs in "+jlfolder);
+			File jlf = new File(JLbase);
+			String jlfolder = jlf.getParent();
 
-			// 	System.setProperty("user.dir", jlfolder);
+			System.out.println("Looking for a list of motifs to use in "+JLbase);
+			System.out.println("Looking for motifs in "+jlfolder);
 
-			// 	Vector<String> JLModelNames = Sequence.getModelNames(JLbase, modelType, false);
-			// 	HashMap<String,MotifGroup> JLGroupData = webJAR3D.loadMotifGroups(JLbase, modelType);
+			System.setProperty("user.dir", jlfolder);
 
-			// 	// process the sequences using the appropriate junction models
-			// 	results = motifParse(JLModelNames, JLGroupData, loop, false);
-			// }
+			Vector<String> JLModelNames = Sequence.getModelNames(JLbase, modelType, false);
+			HashMap<String,MotifGroup> JLGroupData = webJAR3D.loadMotifGroups(JLbase, modelType);
+			results = motifParse(JLModelNames, JLGroupData, loop, false);
+		}
 		saver.save(results);
 		}
 		saver.cleanUp();
@@ -312,16 +259,6 @@ public class Application {
 
 		System.out.println("Application.motifParse: " +loop.getLoopType());
 
-/**
-		// 2013-11-05 CLZ Old code only ran for internal loops.
-		// Others returned empty results and saving crashed.
-		if (loop.getLoopType() == LoopType.INTERNAL) {
-			result = Alignment.doLoopDBQuerey(loop, modelNames, groupData, rangeLimit);
-		} else {
-			result = new ArrayList<LoopResult>();
-		}
-*/
-
 		result = Alignment.doLoopDBQuery(loop, modelNames, groupData, rangeLimit, saveSeqRes);
 
 		return result;
diff --git a/src/main/java/edu/bgsu/rna/jar3d/SimpleAlign.java b/src/main/java/edu/bgsu/rna/jar3d/SimpleAlign.java
index 9600969..2dd886f 100644
--- a/src/main/java/edu/bgsu/rna/jar3d/SimpleAlign.java
+++ b/src/main/java/edu/bgsu/rna/jar3d/SimpleAlign.java
@@ -1,26 +1,24 @@
 package edu.bgsu.rna.jar3d;
 
-import java.util.*;
+import java.util.*; 
 
 public class SimpleAlign {
-
+	
 	public static String[] getSeqStrings(List<Sequence> sData){
 		//pulls sequence strings from a vector of Sequence objects
-
+		
 		int n = sData.size();
 		String seqs[] = new String[n-1];
-
-		// start at 1 because position 0 is for headers
 		for(int i = 1; i < n; i++){
 			Sequence seq = (Sequence)sData.get(i);
 			seqs[i-1] = (String)seq.letters;
 		}
-		return seqs;
+		return seqs;	
 	}
-
+	
 	public static String[] SimpleAlignment(String seq1, String seq2){
 		//does a very basic alignment between seq1 and seq2
-
+		
 		int n1 = seq1.length();
 		int n2 = seq2.length();
 		int[][] Scores = new int[n1+1][n2+1];
@@ -77,22 +75,22 @@ public class SimpleAlign {
 		}
 		return aligned;
 	}
-
+	
 	public static int editDist(String seq1, String seq2){
 		//calculates the Levenshtein distance between seq1 and seq2
-
+		
 //		System.out.println("==="+seq1+"==="+seq2+"===");
 
 		seq1 = seq1.toUpperCase().replaceAll("-", "");
 		seq2 = seq2.toUpperCase().replaceAll("-", "");
-
+		
 		if(seq1.length()==0&seq2.length()==0) return 0;
 		if(seq1.length()==0) 				  return seq2.length();
 		if(seq2.length()==0) 				  return seq1.length();
-
+		
 		int n1 = seq1.length();
 		int n2 = seq2.length();
-
+		
 		int[][] Scores = new int[n1+1][n2+1];
 		for(int i = 0; i <= n1; i ++){
 			Scores[i][0] = i;
@@ -117,57 +115,7 @@ public class SimpleAlign {
 		}
 		return Scores[n1][n2];
 	}
-
-	public static int[][] calcEditDistances(List<Sequence> sD1,List<Sequence> sD2,boolean Verbose,boolean Interior){
-		// calculate all-against-all edit distance between sequences in sD1 and sD2
-		// Interior true means to leave off the first and last letter of each strand
-		// this function breaks the strings at the * character and adds up edit
-		// distances across the strands; the number of strands must be the same
-		// no reversal or rotation is done; the sequences should already be rotated appropriately
-
-		// omit the sequence in position 0, that is for a header
-		String[] seqs1 = getSeqStrings(sD1);
-		String[] seqs2 = getSeqStrings(sD2);
-		int n1 = seqs1.length;
-		int n2 = seqs2.length;
-
-		int[][] EdDists = new int[n1][n2];
-
-		String part1 = "";
-		String part2 = "";
-
-		// loop over all pairs of sequences
-		for (int i = 0; i < n1; i++) {
-			// split into strands
-			String[] parts1 = seqs1[i].split("\\*");
-			// System.out.println(String.format("SimpleAlign: seqs1 is %s", seqs1));
-			for (int j = 0; j < n2; j++) {
-				String[] parts2 = seqs2[j].split("\\*");
-				int ed = 0;
-				if (parts1.length != parts2.length) {
-					System.out.println(String.format("Error: Strings %s and %s have different numbers of parts!",seqs1[i],seqs2[j]));
-				} else {
-					// System.out.println(String.format("SimpleAlign: seqs2 is %s", seqs2));
-					for (int k = 0; k < parts1.length; k++) {
-						if (Interior == true) {
-							// omit first and last position of each strand
-							part1 = parts1[k].substring(1, parts1[k].length() - 1);
-							part2 = parts2[k].substring(1, parts2[k].length() - 1);
-						} else {
-							// use the whole strand
-							part1 = parts1[k];
-							part2 = parts2[k];
-						}
-						ed = ed + editDist(part1,part2);
-					}
-				}
-				EdDists[i][j] = ed;
-			}
-		}
-
-		return EdDists;
-	}
-
+	
 	public static int[][] calcILEditDistances(List<Sequence> sD1,List<Sequence> sD2,int rotation){
 		return calcILEditDistances(sD1,sD2,rotation,false,true);
 	}
@@ -175,19 +123,19 @@ public class SimpleAlign {
 	public static int[][] calcILEditDistances(List<Sequence> sD1,List<Sequence> sD2,int rotation, boolean Verbose){
 		return calcILEditDistances(sD1,sD2,rotation,Verbose,true);
 	}
-
+	
 	public static int[][] calcILEditDistances(List<Sequence> sD1,List<Sequence> sD2,int rotation, boolean Verbose,boolean Interior){
 		//calculates the edit distance between every sequence in fasta file seqFile1
 		//and every sequence in faste file seqFile2.  the first dim of the returned
 		//2d array corresponds to the files in seqFile1, the second to seqFile2
 		//this function assumes the fasta files involved are for internal loops
 		//and use a '*' character to denote the break in strands
-
+		
 		//reverse sequences in seqFile1 if reverse is true
 		if (rotation == 1){
 			sD1 = Alignment.reverse(sD1);
 		}
-
+		
 		String[] seqs1 = getSeqStrings(sD1);
 		String[] seqs2 = getSeqStrings(sD2);
 		int n1 = seqs1.length;
@@ -233,8 +181,8 @@ public class SimpleAlign {
 				breakpoint = seqs2[i].indexOf("*");
 				seqs2left[i] = seqs2[i].substring(0, breakpoint);
 				seqs2right[i] = seqs2[i].substring(breakpoint+1,seqs2[i].length());
-			}
-
+			}			
+		
 		}
 		int leftDist;
 		int rightDist;
@@ -254,21 +202,21 @@ public class SimpleAlign {
 		}
 		return EdDists;
 	}
-
+	
 	public static int[][] calcHLEditDistances(List<Sequence> sD1,List<Sequence> sD2){
 		return calcHLEditDistances(sD1,sD2,false,true);
 	}
-
+	
 	public static int[][] calcHLEditDistances(List<Sequence> sD1,List<Sequence> sD2, boolean Verbose){
 		return calcHLEditDistances(sD1,sD2,Verbose,true);
 	}
-
+	
 	public static int[][] calcHLEditDistances(List<Sequence> sD1,List<Sequence> sD2,boolean Verbose,boolean Interior){
 		//calculates the edit distance between every sequence in fasta file seqFile1
 		//and every sequence in faste file seqFile2.  the first dim of the returned
 		//2d array corresponds to the files in seqFile1, the second to seqFile2
 		//this function assumes the fasta files involved are for hairpin loops
-
+	
 		String[] seqs1 = getSeqStrings(sD1);
 		String[] seqs2 = getSeqStrings(sD2);
 		int n1 = seqs1.length;
diff --git a/src/main/java/edu/bgsu/rna/jar3d/io/loaders/DBLoader.java b/src/main/java/edu/bgsu/rna/jar3d/io/loaders/DBLoader.java
index a05d696..62ca96d 100644
--- a/src/main/java/edu/bgsu/rna/jar3d/io/loaders/DBLoader.java
+++ b/src/main/java/edu/bgsu/rna/jar3d/io/loaders/DBLoader.java
@@ -24,7 +24,7 @@ public class DBLoader implements QueryLoader {
     private PreparedStatement sqlForQueryInfo;
 
     private PreparedStatement sqlForLoops;
-
+    
     private PreparedStatement updateQueryInfo;
 
     public DBLoader(String username, String password, String dbConnection) throws SQLException {
@@ -42,7 +42,7 @@ public class DBLoader implements QueryLoader {
     	sqlForLoops.setLong(2, index);
     	ResultSet results = sqlForLoops.executeQuery();
     	long id = -1;
-
+    	
     	String type = "";
     	List<Sequence> sequences = new ArrayList<Sequence>();
     	while (results.next()) {
@@ -51,9 +51,6 @@ public class DBLoader implements QueryLoader {
     		id = results.getLong("loop_id");
     		int seq_id = results.getInt("seq_id");
     		sequences.add(new Sequence(seq_id, "", sequence));
-
-			System.out.println(String.format("DBLoader.loadLoop %s %s %d",sequence,type,id));
-
     	}
     	results.close();
 
@@ -64,22 +61,22 @@ public class DBLoader implements QueryLoader {
         String loopCountSql = "SELECT MAX(loop_id) AS max FROM `jar3d_query_sequences` where query_id = ?;";
         PreparedStatement sqlForLoopCount = connection.prepareStatement(loopCountSql);
         sqlForLoopCount.setString(1, queryId);
-
+        
         List<Loop> loops = new ArrayList<Loop>();
         ResultSet result = sqlForLoopCount.executeQuery();
         boolean found = result.first();
         if (!found) {
         	throw new QueryLoadingFailed("Could not find any loops for query: " + queryId);
         }
-
+        
         int loopCount = result.getInt("max") + 1;
         result.close();
-
+        
         for (int i = 0; i < loopCount; i++) {
-        	Loop loop = loadLoop(queryId, i);
+        	Loop loop = loadLoop(queryId, i); 
         	if(loop.getId()!=-1) {loops.add(loop);}
         }
-
+        
         return loops;
     }
 
@@ -91,28 +88,25 @@ public class DBLoader implements QueryLoader {
         String hlSet;
         List<Loop> loops;
         boolean onlyStructured;
-
-
-		System.out.println(String.format("DBLoader.load queryId %s",queryId));
-
+        
 		try {
 	        sqlForQueryInfo.setString(1, queryId);
 	        updateQueryInfo.setString(1, queryId);
-
+	        
 	        updateQueryInfo.executeUpdate();
 	        ResultSet result = sqlForQueryInfo.executeQuery();
 	        boolean found = result.first();
-
+	        
 	        if (!found) {
 	        	throw new QueryLoadingFailed("Could not find query with id: " + queryId);
 	        }
-
+	        
 	        modelType = result.getString("model_type");
 	        groupSet = result.getString("group_set");
 	        String[] parts = groupSet.split("/");
 	        ilSet = parts[0];
 	        hlSet = parts[1];
-
+	        
 	        int structured = result.getInt("structured_models_only");
 	        if (structured == 1) {
 	        	onlyStructured = true;
@@ -120,20 +114,18 @@ public class DBLoader implements QueryLoader {
 	        	onlyStructured = false;
 	        }
 	        result.close();
-
-			System.out.println(String.format("DBLoader.load queryId %s",queryId));
-
+	        
 	        loops = loadLoops(queryId);
 		} catch (SQLException e) {
 			System.out.println(sqlForQueryInfo);
 			throw new QueryLoadingFailed("Could not load: " + queryId, e);
 		}
-
+		
         Query query = new ImmutableQuery(queryId, loops, onlyStructured, ilSet, hlSet, modelType);
-
+        
         return query;
 	}
-
+	
 	public void cleanUp() {
 		try {
 			connection.close();
diff --git a/src/main/java/edu/bgsu/rna/jar3d/loop/Loop.java b/src/main/java/edu/bgsu/rna/jar3d/loop/Loop.java
index 699ee37..3379c7b 100644
--- a/src/main/java/edu/bgsu/rna/jar3d/loop/Loop.java
+++ b/src/main/java/edu/bgsu/rna/jar3d/loop/Loop.java
@@ -6,64 +6,62 @@ import edu.bgsu.rna.jar3d.Sequence;
 import edu.bgsu.rna.jar3d.query.Query;
 
 /**
- * A loop is a set of sequences which can be run against a model.
- * This interface defines the basic functions of a loop.
- * It serves both as a container for the list of sequences,
- * as well as a way to store some meta data about the loop.
+ * A loop is a set of sequences which can be run against a model. This interface defines the basic functions of a loop.
+ * It serves both as a container for the list of sequences, as well as a way to store some meta data about the loop.
  */
 public interface Loop extends Iterable<Sequence> {
 
 	/**
 	 * Get a list of all sequences in this loop as strings.
-	 *
+	 * 
 	 * @return The sequences as strings.
 	 */
 	public List<String> getSequenceStrings();
 
 	/**
 	 * Get the short name for the type of loop this is.
-	 *
+	 * 
 	 * @return The type.
 	 */
 	public String getTypeString();
 
 	/**
 	 * Get the LoopType.
-	 *
+	 * 
 	 * @return The loop type.
 	 */
 	public LoopType getLoopType();
 
 	/**
-	 * Get a numeric ID for this loop.
+	 * Get a numeric ID for this loop. 
 	 * @return
 	 */
 	public long getId();
 
 	/**
 	 * Get a human readable name for this loop.
-	 *
+	 * 
 	 * @return The name
 	 */
 	public String getName();
 
 	/**
 	 * Transform this loop into a list of Sequence objects.
-	 *
+	 * 
 	 * @return This loop as a series of Sequences.
 	 */
 	public List<Sequence> getSequences();
 
 	/**
 	 * Get the query this loop belongs to.
-	 *
+	 * 
 	 * @return The query.
 	 */
 	public Query getQuery();
 
 	/**
 	 * Set the Query this loop belongs to.
-	 *
+	 * 
 	 * @param query The query.
 	 */
 	public void setQuery(Query query);
diff --git a/src/main/java/edu/bgsu/rna/jar3d/loop/LoopType.java b/src/main/java/edu/bgsu/rna/jar3d/loop/LoopType.java
index 65b91c3..849184a 100644
--- a/src/main/java/edu/bgsu/rna/jar3d/loop/LoopType.java
+++ b/src/main/java/edu/bgsu/rna/jar3d/loop/LoopType.java
@@ -3,39 +3,18 @@ package edu.bgsu.rna.jar3d.loop;
 import edu.bgsu.rna.jar3d.Sequence;
 
 /**
- * This enum represents the possible types of loops this code can process.
+ * This enum represents the possible types of loops this can process. Currently, only hairpin and internal are used.
  */
 public enum LoopType {
 
-	/** Type for all hairpin loops. */
-	HAIRPIN("hairpin", "HL", 1),
-
 	/** Type for all internal loops. */
 	INTERNAL("internal", "IL", 2),
 
-	/** Type for junction loops. */
-	JUNCTION("junction", "JL", 0),
-
-	/** Type for 3-way junction loops. */
-	J3("junction", "J3", 3),
-
-	/** Type for 4-way junction loops. */
-	J4("junction", "J4", 4),
-
-	/** Type for 4-way junction loops. */
-	J5("junction", "J5", 5),
-
-	/** Type for 4-way junction loops. */
-	J6("junction", "J6", 6),
-
-	/** Type for 4-way junction loops. */
-	J7("junction", "J7", 7),
-
-	/** Type for 4-way junction loops. */
-	J8("junction", "J8", 8),
+	/** Type for all hairpin loops. */
+	HAIRPIN("hairpin", "HL", 1),
 
-	/** Type for 4-way junction loops. */
-	J9("junction", "J9", 9),
+	/** Type for junction loops. */
+	JUNCTION("junction", "JL", 3),
 
 	/** Type for all other loop types. */
 	UNKNOWN("unknown", "?L", -1);
@@ -71,85 +50,36 @@ public enum LoopType {
 	 */
 	public static LoopType fromString(String type) {
 		System.out.println(type);
-		if (type.equalsIgnoreCase("HL") || type.equalsIgnoreCase("hairpin")) {
-			return HAIRPIN;
-		}
 		if (type.equalsIgnoreCase("IL") || type.equalsIgnoreCase("internal")) {
 			return INTERNAL;
 		}
-		if (type.equalsIgnoreCase("J3")) {
-			return J3;
-		}
-		if (type.equalsIgnoreCase("J4")) {
-			return J4;
-		}
-		if (type.equalsIgnoreCase("J5")) {
-			return J5;
-		}
-		if (type.equalsIgnoreCase("J6")) {
-			return J6;
-		}
-		if (type.equalsIgnoreCase("J7")) {
-			return J7;
-		}
-		if (type.equalsIgnoreCase("J8")) {
-			return J8;
-		}
-		if (type.equalsIgnoreCase("J9")) {
-			return J9;
+		if (type.equalsIgnoreCase("HL") || type.equalsIgnoreCase("hairpin")) {
+			return HAIRPIN;
 		}
-		if (type.equalsIgnoreCase("JL") || type.equalsIgnoreCase("junction")) {
+		if (type.startsWith("J") || type.equalsIgnoreCase("junction")) {
 			return JUNCTION;
 		}
 		return UNKNOWN;
 	}
 
 	/**
-	 * Infer the loop type from a Sequence.
-	 * Use the number of * characters to count the strands.
+	 * Infer the loop type from a Sequence. If the sequence has no * then it is a hairpin. If it has one * then it is
+	 * an internal loop. Otherwise it is a junction loop.
 	 *
 	 * @param sequence
 	 * @return The loop type.
 	 */
 	public static LoopType fromSequence(Sequence sequence) {
 		String seq = sequence.getSequence();
-
-		String[] parts = seq.split("\\*");  // escape * with \\, since it's a regex
-        int strand_count = parts.length;
-
-		// System.out.println(String.format("LoopType fromSequence sequence %s strand_count %d",seq,strand_count));
-
-		if (strand_count == 1) {
+		int firstStar = seq.indexOf("*");
+		int lastStar = seq.lastIndexOf("*");
+		if (firstStar == -1) {
 			return HAIRPIN;
-		} else if (strand_count == 2) {
+		}
+		if (firstStar == lastStar) {
 			return INTERNAL;
-		} else if (strand_count == 3) {
-			return J3;
-		} else if (strand_count == 4) {
-			return J4;
-		} else if (strand_count == 5) {
-			return J5;
-		} else if (strand_count == 6) {
-			return J6;
-		} else if (strand_count == 7) {
-			return J7;
-		} else if (strand_count == 8) {
-			return J8;
-		} else if (strand_count == 9) {
-			return J9;
 		}
-
-		return UNKNOWN;
-
-		// int firstStar = seq.indexOf("*");
-		// int lastStar = seq.lastIndexOf("*");
-		// if (firstStar == -1) {
-		// 	return HAIRPIN;
-		// }
-		// if (firstStar == lastStar) {
-		// 	return INTERNAL;
-		// }
-		// return JUNCTION;
+		return JUNCTION;
 	}
 
 	/**
diff --git a/src/main/java/edu/bgsu/rna/jar3d/query/Query.java b/src/main/java/edu/bgsu/rna/jar3d/query/Query.java
index 284fb0e..ecac3db 100644
--- a/src/main/java/edu/bgsu/rna/jar3d/query/Query.java
+++ b/src/main/java/edu/bgsu/rna/jar3d/query/Query.java
@@ -5,59 +5,57 @@ import java.util.List;
 import edu.bgsu.rna.jar3d.loop.Loop;
 
 /**
- * A query represents a set of loops to scan with models.
- * This works as both a container for the loops and some meta
- * data about the query.
- * For example, this contains information about what type of models should be used, the type
+ * A query represents a set of loops to scan with models. This works as both a container for the loops and some meta
+ * data about the query. For example, this contains information about what type of models should be used, the type
  * of internal and hairpin loop models that should be used and the model type.
  */
 public interface Query extends Iterable<Loop> {
 
 	/**
 	 * The ID for this query.
-	 *
+	 * 
 	 * @return The id
 	 */
 	public String getId();
 
 	/**
 	 * Get the name of the internal loop model set to use.
-	 *
+	 * 
 	 * @return The set name.
 	 */
 	public String getILSetName();
 
 	/**
 	 * Get the name of the hairpin loop models to use.
-	 *
+	 * 
 	 * @return The set name.
 	 */
 	public String getHLSetName();
 
 	/**
 	 * Get the type of model to use.
-	 *
+	 * 
 	 * @return The model type.
 	 */
 	public String modelType();
 
 	/**
 	 * Return true if this query uses only the structured models.
-	 *
+	 * 
 	 * @return If this query uses only structured models.
 	 */
 	public boolean onlyStructured();
 
 	/**
 	 * Get all loops in this Query.
-	 *
+	 * 
 	 * @return The loops.
 	 */
 	public List<Loop> getLoops();
 
 	/**
 	 * Get the Loop at the given index in this Query.
-	 *
+	 * 
 	 * @param index Index to get.
 	 * @return The Loop.
 	 */
@@ -65,7 +63,7 @@ public interface Query extends Iterable<Loop> {
 
 	/**
 	 * Get the number of loops in this query.
-	 *
+	 * 
 	 * @return The count.
 	 */
 	public int loopCount();
