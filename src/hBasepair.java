
/**
 * hBasepair is in development.  It's supposed to model basepairs in helices
 * in which basepairs near the beginning or near the end get deleted, instead of
 * randomly here and there in the middle of the basepair.
 * 
 * @author zirbel
 *
 */
public class hBasepair extends BasicNode {
	
	// these strings are used to print out generated strands
	String leftGen,rightGen;
	// this defines a var to hold which letter pair is chosen for generation
    int pair;
    // these character arrays are used with a set of probabilities to determine the pairs generated by this node
    //    Subtract 1 from each of the following numbers:
    //    % 1-AA  2-CA  3-GA  4-UA  5-AC  6-CC  7-GC  8-UC 
    //    % 9-AG 10-CG 11-GG 12-UG 13-AU 14-CU 15-GU 16-UU
    char lLetAry[] = new char[]{'A','C','G','U','A','C','G','U','A','C','G','U','A','C','G','U'};
    char rLetAry[] = new char[]{'A','A','A','A','C','C','C','C','G','G','G','G','U','U','U','U'};
    char letters[] = new char[]{'A','C','G','U'};
    // these are arrays of probabilities that are used to determine the pairs Generated
    double[] pairProb;
    double pairLogProb[];
    // arrays of logs of all probabilities
    
    // this is the probability that this basePairNode does not generate anything
    double deleteProb;
    double deleteLogProb;
    
    double[][] maxProb;
    
    InsertionDistribution lInsDist, rInsDist;
    
    double[][] delTrans;
	
	hBasepair(Node prev, double[][] dProb, double[] pProb, double[] lLenDist, double[] lLetDist, double[] rLenDist, double[] rLetDist, int rI, int lI)
	{
		super(prev, "BasepairNode", rI, lI);
		delTrans = dProb;
		// normalize is a function that makes sure all the array's elements add up to 1
		pairProb = rnaMath.normalize(pProb);
        
        pairLogProb = rnaMath.log(pairProb);
        
        deleteLogProb = Math.log(deleteProb);
        
        lInsDist = new InsertionDistribution(lLenDist, lLetDist);
        rInsDist = new InsertionDistribution(rLenDist, rLetDist);
 	}

	
	/**
	 * This method calls all the methods needed to generate the letters of this Node
	 */
	
	public String generate(boolean del)
  	{        
		// use the transition probability and del boolean to change
		// current deleteProb?
		if(del)
		{
			return "(" + super.child.generate(Math.random() < delTrans[1][1]) + ")";
		}
		else
		{
			pair = rnaMath.rando(pairProb);
			leftGen = lLetAry[pair] + lInsDist.generate();
			rightGen = rInsDist.generate() + rLetAry[pair];
			return "(" + leftGen + super.child.generate(Math.random() < delTrans[0][1]) + rightGen + ")";
		}
  	}

   	
	void computeMaxLogProb(Sequence seq, int i, int j)
  	{
  		if ((i >= super.iMin) && (i <= super.iMax) && (j >= super.jMin) && (j <= super.jMax)  && (i <= j)) {
			double p;	// maximum log probability found so far
			double pll;	// contribution to total log prob from left insertion length
			double pli;	// contribution to total log prob from left inserted letters
			double prl; // contribution to total log prob from right insertion length
			double pri; // contribution to total log prob from right inserted letters
			double priarray[] = new double[rInsDist.logLengthDist.length];
			double pnew; // probability of current insertion possibility
			int a; 		// number of insertions on the left
			int b; 		// number of insertions on the right
			int aa=0, bb=0;
			int pc;		// paircode for the letters at i and j
			boolean Deleted;
			
			// consider the possibility that this node generates nothing at all
			
			p = deleteLogProb + super.child.getMaxLogProb(i,j);
			Deleted = true;
			
			// consider the possibility of generating a pair and various numbers of insertions
			
			// for loop that sets maxLogProb[i-super.iMin][j-super.jMin]

			pc = seq.code[i] + 4*seq.code[j];
			
			pli = 0;					// 0 left insertions so far
			
			priarray[0] = 0;
			for(b = 1; b < Math.min(j-i-1,rInsDist.lengthDist.length); b++)
  			{
				priarray[b] = priarray[b-1] + rInsDist.logLetterDist[seq.code[j-b]];
  			} // end for loop

			for(a = 0; a < Math.min(j-i-1,lInsDist.logLengthDist.length); a++)
  	  		{
  				pll = lInsDist.logLengthDist[a];
  				if (a > 0) {
  					pli = pli + lInsDist.logLetterDist[seq.code[i+a]];
  				}
  				pri = 0;				// 0 right insertions so far
  				for(b = 0; b < Math.min(j-i-1-a,rInsDist.lengthDist.length); b++)
  	  			{
  					prl = rInsDist.logLengthDist[b];
  					pri = priarray[b];
					pnew = super.child.getMaxLogProb(i+a+1,j-b-1);
					pnew = pnew + pairLogProb[pc];
					pnew = pnew + pll + pli + prl + pri;
  	  				if (pnew > p) {
  	  					p = pnew;
  	  					aa = a;
  	  					bb = b;
  	  					Deleted = false;
  	  				} // end if
  	  			} // end for loop
  	  		} // end for loop
  			maxLogProb[i-iMin][j-jMin] = p;
  			if (Deleted)
  			{
  	  			myGen[i-iMin][j-jMin] = new genData(true);
  			}
  			else
  			{
  				// Should we keep both gendatas here? how to set that up?
  				
  				// LOOK AT THIS! I don't know if I'm getting the pairs out correctly,
  				// I dont know if we ever even determine the max probability for pairs.
  	  			myGen[i-iMin][j-jMin] = new genData(seq.nucleotides.charAt(i),seq.nucleotides.charAt(j),aa,bb);
  			}
  		} // if loop
  	} // method declaration
   	
   	
  	
	public void traceback(int i, int j)
  	{
  		if ((i >= super.iMin) && (i <= super.iMax) && (j >= super.jMin) && (j <= super.jMax)  && (i <= j))
  		{
   			setOptimalAndRelease(i,j);

   			// if setOptimalAndReleased was already done, don't go on to the child!
//			alreadyDone = setOptimalAndRelease(i,j);
   			
   			if(optimalGen1.deleted)
  			{
  				super.child.traceback(i,j);
  			}
  			else
  			{	  			
	  			int a = optimalGen1.numLeftIns;
	  			int b = optimalGen1.numRightIns;
	  			super.child.traceback(i+1+a,j-1-b); // i+1+a = i +pair+insertions
  			}
  		}
  		else
  			System.out.println("Out of range");
  	}
   	
  	
	public String showParse(String n)
  	{
  		// I think that the one that should be the deleted one to keep is optimalGen2?
  		if (optimalGen1.deleted)
  		{
  			String left = "";
  			for(int f = 0; f < lInsDist.lengthDist.length; f++)
  				left += "-";
  			
  			String right = "";
  			for(int g = 0; g < rInsDist.lengthDist.length; g++)
  				right = "-"+right;
  			// does this need deletion stuff too?
  			return "(" + left + super.child.showParse(n) + right + ")";
  		}
  		else
  		{
  			int a = optimalGen1.numLeftIns;
  			int b = optimalGen1.numRightIns;
  			int i = optimalGen1.i;
  			int j = optimalGen1.j;
  			
  			String left = n.substring(i,i+a+1);
  			int lSize = left.length();
  			for(int f = 0; f < lInsDist.lengthDist.length - lSize; f++)
  				left += "-";
  			
  			String right = n.substring(j-b,j+1);
  			int rSize = right.length();
  			for(int g = 0; g < rInsDist.lengthDist.length - rSize; g++)
  				right = "-"+right;
  			
  			return "(" + left + super.child.showParse(n) + right + ")";
  		}
  	}
  	
  	
	public String header()
  	{
		String left = "(";
		for(int f = 0; f < lInsDist.lengthDist.length-1; f++)
			left += "-";
		
		String right = ")";
		for(int g = 0; g < rInsDist.lengthDist.length-1; g++)
			right = "-"+right;
		
		return "(" + left + super.child.header() + right + ")";
  	}

}// class
